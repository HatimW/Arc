var Arc = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // js/storage/preferences.js
  function schedule(callback) {
    if (typeof globalScope.requestIdleCallback === "function") {
      return globalScope.requestIdleCallback(callback, { timeout: 500 });
    }
    return setTimeout(callback, 0);
  }
  function cancel(handle) {
    if (handle == null) return;
    if (typeof globalScope.cancelIdleCallback === "function") {
      globalScope.cancelIdleCallback(handle);
    } else {
      clearTimeout(handle);
    }
  }
  function flushPendingWrite() {
    if (!pendingPayload) {
      return;
    }
    if (!canUseStorage()) {
      pendingPayload = null;
      return;
    }
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(pendingPayload));
    } catch (err) {
      console.warn("Failed to persist UI preferences", err);
    }
    pendingPayload = null;
  }
  function schedulePersist() {
    if (pendingWriteHandle != null) {
      return;
    }
    pendingWriteHandle = schedule(() => {
      pendingWriteHandle = null;
      flushPendingWrite();
    });
  }
  function canUseStorage() {
    try {
      return typeof localStorage !== "undefined";
    } catch (err) {
      return false;
    }
  }
  function readPreferences() {
    if (cache) {
      return cache;
    }
    if (!canUseStorage()) {
      cache = {};
      return cache;
    }
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        cache = {};
        return cache;
      }
      const parsed = JSON.parse(raw);
      cache = parsed && typeof parsed === "object" ? parsed : {};
    } catch (err) {
      console.warn("Failed to read UI preferences", err);
      cache = {};
    }
    return cache;
  }
  function loadUIPreferences() {
    const stored = readPreferences();
    return stored ? { ...stored } : {};
  }
  function updateUIPreferences(patch) {
    if (!patch || typeof patch !== "object") {
      return loadUIPreferences();
    }
    const current = { ...readPreferences() };
    let changed = false;
    for (const [key, value] of Object.entries(patch)) {
      if (typeof value === "undefined") continue;
      if (current[key] !== value) {
        current[key] = value;
        changed = true;
      }
    }
    if (!changed) {
      return { ...current };
    }
    cache = current;
    pendingPayload = { ...current };
    schedulePersist();
    return { ...current };
  }
  var STORAGE_KEY, cache, pendingWriteHandle, pendingPayload, globalScope;
  var init_preferences = __esm({
    "js/storage/preferences.js"() {
      STORAGE_KEY = "arc-ui-preferences";
      cache = null;
      pendingWriteHandle = null;
      pendingPayload = null;
      globalScope = typeof globalThis !== "undefined" ? globalThis : window;
      if (globalScope && typeof globalScope.addEventListener === "function") {
        globalScope.addEventListener(
          "beforeunload",
          () => {
            if (pendingWriteHandle != null) {
              cancel(pendingWriteHandle);
              pendingWriteHandle = null;
            }
            flushPendingWrite();
          },
          { once: true }
        );
      }
    }
  });

  // js/state.js
  function arrayShallowEqual(a, b) {
    const arrA = Array.isArray(a) ? a : [];
    const arrB = Array.isArray(b) ? b : [];
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i = 0; i < arrA.length; i += 1) {
      if (arrA[i] !== arrB[i]) {
        return false;
      }
    }
    return true;
  }
  function sanitizeEntryFilters(value) {
    if (!value || typeof value !== "object") return {};
    const next = {};
    if (Array.isArray(value.types)) {
      const unique = Array.from(
        new Set(
          value.types.map((entry) => typeof entry === "string" ? entry.trim() : "").filter(Boolean)
        )
      );
      if (unique.length) next.types = unique;
    }
    if (Object.prototype.hasOwnProperty.call(value, "block")) {
      next.block = String(value.block ?? "");
    }
    if (Object.prototype.hasOwnProperty.call(value, "week")) {
      const raw = value.week;
      if (raw === "" || raw === null || typeof raw === "undefined") {
        next.week = "";
      } else if (Number.isFinite(Number(raw))) {
        next.week = String(Number(raw));
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, "onlyFav")) {
      next.onlyFav = Boolean(value.onlyFav);
    }
    if (Object.prototype.hasOwnProperty.call(value, "sort")) {
      next.sort = String(value.sort ?? "");
    }
    return next;
  }
  function sanitizeLectureState(value, { forPersist = false } = {}) {
    if (!value || typeof value !== "object") return {};
    const next = {};
    const stringKeys = ["query", "blockId", "week", "status", "tag", "sort"];
    stringKeys.forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        next[key] = String(value[key] ?? "");
      }
    });
    if (Array.isArray(value.openBlocks)) {
      const uniqueBlocks = Array.from(
        new Set(value.openBlocks.map((block) => String(block ?? "")))
      );
      next.openBlocks = uniqueBlocks;
    }
    if (Array.isArray(value.openWeeks)) {
      const uniqueWeeks2 = Array.from(
        new Set(value.openWeeks.map((week) => String(week ?? "")))
      );
      next.openWeeks = uniqueWeeks2;
    }
    if (Object.prototype.hasOwnProperty.call(value, "openSnapshot")) {
      const stamp = Number(value.openSnapshot);
      next.openSnapshot = Number.isFinite(stamp) ? stamp : 0;
    }
    if (!forPersist && Object.prototype.hasOwnProperty.call(value, "scrollTop")) {
      const top = Number(value.scrollTop);
      next.scrollTop = Number.isFinite(top) && top > 0 ? Math.max(0, Math.round(top)) : 0;
    }
    return next;
  }
  function sanitizeEntryLayout(value) {
    if (!value || typeof value !== "object") return {};
    const next = {};
    if (Object.prototype.hasOwnProperty.call(value, "mode")) {
      next.mode = value.mode === "grid" ? "grid" : "list";
    }
    if (Object.prototype.hasOwnProperty.call(value, "columns")) {
      const cols = Number(value.columns);
      if (!Number.isNaN(cols)) {
        next.columns = Math.max(1, Math.min(6, Math.round(cols)));
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, "scale")) {
      const scl = Number(value.scale);
      if (!Number.isNaN(scl)) {
        next.scale = Math.max(0.6, Math.min(1.4, scl));
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, "controlsVisible")) {
      next.controlsVisible = Boolean(value.controlsVisible);
    }
    return next;
  }
  function sanitizeExamLayout(value) {
    if (!value || typeof value !== "object") return {};
    const next = {};
    if (value.mode === "row" || value.mode === "grid") {
      next.mode = value.mode;
    }
    if (Object.prototype.hasOwnProperty.call(value, "detailsVisible")) {
      next.detailsVisible = Boolean(value.detailsVisible);
    }
    return next;
  }
  function setTab(value) {
    if (value == null) return false;
    const next = String(value);
    if (state.tab === next) return false;
    state.tab = next;
    return true;
  }
  function setSubtab(tab, sub) {
    if (!state.subtab || typeof state.subtab !== "object") {
      state.subtab = {};
    }
    if (tab == null) return false;
    const tabKey = String(tab);
    if (!tabKey) return false;
    const next = sub == null ? "" : String(sub);
    if (state.subtab[tabKey] === next) return false;
    state.subtab[tabKey] = next;
    return true;
  }
  function setQuery(value) {
    const next = value == null ? "" : String(value);
    if (state.query === next) return false;
    state.query = next;
    return true;
  }
  function setFilters(patch) {
    if (!patch) return;
    const current = state.filters && typeof state.filters === "object" ? state.filters : { ...DEFAULT_ENTRY_FILTERS };
    const next = { ...current };
    let changed = false;
    if (Array.isArray(patch.types)) {
      const unique = Array.from(
        new Set(
          patch.types.map((entry) => typeof entry === "string" ? entry.trim() : "").filter(Boolean)
        )
      );
      if (unique.length) {
        if (!arrayShallowEqual(current.types, unique)) {
          next.types = unique;
          changed = true;
        }
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "block")) {
      const value = String(patch.block ?? "");
      if ((current.block ?? "") !== value) {
        next.block = value;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "week")) {
      const raw = patch.week;
      let normalized2;
      if (raw === "" || raw === null || typeof raw === "undefined") {
        normalized2 = "";
      } else if (Number.isFinite(Number(raw))) {
        normalized2 = String(Number(raw));
      }
      if (typeof normalized2 !== "undefined" && (current.week ?? "") !== normalized2) {
        next.week = normalized2;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "onlyFav")) {
      const value = Boolean(patch.onlyFav);
      if (Boolean(current.onlyFav) !== value) {
        next.onlyFav = value;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "sort")) {
      const value = String(patch.sort ?? "");
      if ((current.sort ?? "") !== value) {
        next.sort = value;
        changed = true;
      }
    }
    if (!changed) {
      return;
    }
    state.filters = next;
    updateUIPreferences({ filters: sanitizeEntryFilters(next) });
  }
  function setBuilder(patch) {
    Object.assign(state.builder, patch);
  }
  function setBlockBoardState(patch) {
    if (!patch) return;
    if (!state.blockBoard) {
      state.blockBoard = {
        collapsedBlocks: [],
        hiddenTimelines: [],
        autoCollapsed: [],
        autoHidden: [],
        manualExpanded: [],
        manualTimeline: []
      };
    }
    const current = state.blockBoard;
    if (!Array.isArray(current.hiddenTimelines)) {
      current.hiddenTimelines = [];
    }
    if (!Array.isArray(current.autoCollapsed)) {
      current.autoCollapsed = [];
    }
    if (!Array.isArray(current.autoHidden)) {
      current.autoHidden = [];
    }
    if (!Array.isArray(current.manualExpanded)) {
      current.manualExpanded = [];
    }
    if (!Array.isArray(current.manualTimeline)) {
      current.manualTimeline = [];
    }
    if (Array.isArray(patch.collapsedBlocks)) {
      const unique = Array.from(new Set(patch.collapsedBlocks.map((id) => String(id))));
      current.collapsedBlocks = unique;
    }
    if (Array.isArray(patch.hiddenTimelines)) {
      const uniqueHidden = Array.from(new Set(patch.hiddenTimelines.map((id) => String(id))));
      current.hiddenTimelines = uniqueHidden;
    }
    if (Array.isArray(patch.autoCollapsed)) {
      const autoSet = Array.from(new Set(patch.autoCollapsed.map((id) => String(id))));
      current.autoCollapsed = autoSet;
    }
    if (Array.isArray(patch.autoHidden)) {
      const autoHiddenSet = Array.from(new Set(patch.autoHidden.map((id) => String(id))));
      current.autoHidden = autoHiddenSet;
    }
    if (Array.isArray(patch.manualExpanded)) {
      const manualExpandedSet = Array.from(new Set(patch.manualExpanded.map((id) => String(id))));
      current.manualExpanded = manualExpandedSet;
    }
    if (Array.isArray(patch.manualTimeline)) {
      const manualTimelineSet = Array.from(new Set(patch.manualTimeline.map((id) => String(id))));
      current.manualTimeline = manualTimelineSet;
    }
    if (Object.prototype.hasOwnProperty.call(patch, "showDensity")) {
      const show = Boolean(patch.showDensity);
      if (show) {
        current.hiddenTimelines = current.hiddenTimelines.filter((id) => id !== "__all__");
      } else if (!current.hiddenTimelines.includes("__all__")) {
        current.hiddenTimelines = [...current.hiddenTimelines, "__all__"];
      }
    }
  }
  function setLecturesState(patch) {
    if (!patch) return;
    if (!state.lectures) {
      state.lectures = { ...DEFAULT_LECTURE_STATE };
    }
    const current = state.lectures;
    const next = { ...current };
    let changed = false;
    const stringKeys = ["query", "blockId", "week", "status", "tag"];
    stringKeys.forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(patch, key)) {
        const value = String(patch[key] ?? "");
        if ((current?.[key] ?? "") !== value) {
          next[key] = value;
          changed = true;
        }
      }
    });
    if (Object.prototype.hasOwnProperty.call(patch, "sort")) {
      const value = patch.sort;
      let normalized2 = current?.sort ?? "";
      if (typeof value === "string") {
        normalized2 = value;
      } else if (value && typeof value === "object") {
        const field = typeof value.field === "string" && value.field.trim() ? value.field.trim() : "position";
        const direction = value.direction === "desc" ? "desc" : "asc";
        normalized2 = `${field}-${direction}`;
      }
      if ((current?.sort ?? "") !== normalized2) {
        next.sort = normalized2;
        changed = true;
      }
    }
    if (Array.isArray(patch.openBlocks)) {
      const unique = Array.from(
        new Set(patch.openBlocks.map((block) => String(block ?? "")))
      );
      if (!arrayShallowEqual(current?.openBlocks, unique)) {
        next.openBlocks = unique;
        changed = true;
      }
    }
    if (Array.isArray(patch.openWeeks)) {
      const unique = Array.from(
        new Set(patch.openWeeks.map((week) => String(week ?? "")))
      );
      if (!arrayShallowEqual(current?.openWeeks, unique)) {
        next.openWeeks = unique;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "openSnapshot")) {
      const stamp = Number(patch.openSnapshot);
      const normalized2 = Number.isFinite(stamp) ? stamp : 0;
      if ((current?.openSnapshot ?? 0) !== normalized2) {
        next.openSnapshot = normalized2;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "scrollTop")) {
      const top = Number(patch.scrollTop);
      const normalized2 = Number.isFinite(top) && top > 0 ? Math.max(0, Math.round(top)) : 0;
      if ((current?.scrollTop ?? 0) !== normalized2) {
        next.scrollTop = normalized2;
        changed = true;
      }
    }
    if (!changed) {
      return;
    }
    state.lectures = next;
    updateUIPreferences({ lectures: sanitizeLectureState(next, { forPersist: true }) });
  }
  function setCardsState(patch) {
    if (!patch) return;
    if (!state.cards) {
      state.cards = { collapsedBlocks: [], collapsedWeeks: [], initialized: false };
    }
    const { collapsedBlocks: collapsedBlocks2, collapsedWeeks: collapsedWeeks2 } = patch;
    if (Array.isArray(collapsedBlocks2)) {
      const unique = Array.from(new Set(collapsedBlocks2.filter(Boolean)));
      state.cards.collapsedBlocks = unique;
    }
    if (Array.isArray(collapsedWeeks2)) {
      const unique = Array.from(new Set(collapsedWeeks2.filter(Boolean)));
      state.cards.collapsedWeeks = unique;
    }
    state.cards.initialized = true;
  }
  function setCohort(items) {
    state.cohort = items;
  }
  function setFlashSession(sess) {
    state.flashSession = sess;
  }
  function setQuizSession(sess) {
    state.quizSession = sess;
  }
  function setExamSession(sess) {
    state.examSession = sess;
  }
  function setExamAttemptExpanded(examId, expanded2) {
    state.examAttemptExpanded[examId] = expanded2;
  }
  function setExamLayout(patch) {
    if (!patch) return;
    const current = state.examLayout && typeof state.examLayout === "object" ? state.examLayout : { ...DEFAULT_EXAM_LAYOUT };
    const next = { ...current };
    let changed = false;
    if (patch.mode === "row" || patch.mode === "grid") {
      if (current.mode !== patch.mode) {
        next.mode = patch.mode;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "detailsVisible")) {
      const value = Boolean(patch.detailsVisible);
      if (Boolean(current.detailsVisible) !== value) {
        next.detailsVisible = value;
        changed = true;
      }
    }
    if (!changed) {
      return;
    }
    state.examLayout = next;
    updateUIPreferences({ examLayout: sanitizeExamLayout(next) });
  }
  function setBlockMode(patch) {
    Object.assign(state.blockMode, patch);
  }
  function resetBlockMode() {
    state.blockMode = { section: "", assignments: {}, reveal: {}, order: {} };
  }
  function setEntryLayout(patch) {
    if (!patch) return;
    const current = state.entryLayout && typeof state.entryLayout === "object" ? state.entryLayout : { ...DEFAULT_ENTRY_LAYOUT };
    const next = { ...current };
    let changed = false;
    if (Object.prototype.hasOwnProperty.call(patch, "columns")) {
      const cols = Number(patch.columns);
      if (!Number.isNaN(cols)) {
        const normalized2 = Math.max(1, Math.min(6, Math.round(cols)));
        if (current.columns !== normalized2) {
          next.columns = normalized2;
          changed = true;
        }
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "scale")) {
      const scl = Number(patch.scale);
      if (!Number.isNaN(scl)) {
        const normalized2 = Math.max(0.6, Math.min(1.4, scl));
        if (current.scale !== normalized2) {
          next.scale = normalized2;
          changed = true;
        }
      }
    }
    if (patch.mode === "list" || patch.mode === "grid") {
      if (current.mode !== patch.mode) {
        next.mode = patch.mode;
        changed = true;
      }
    }
    if (Object.prototype.hasOwnProperty.call(patch, "controlsVisible")) {
      const value = Boolean(patch.controlsVisible);
      if (Boolean(current.controlsVisible) !== value) {
        next.controlsVisible = value;
        changed = true;
      }
    }
    if (!changed) {
      return;
    }
    state.entryLayout = next;
    updateUIPreferences({ entryLayout: sanitizeEntryLayout(next) });
  }
  function setStudySelectedMode(mode2) {
    if (!state.study) state.study = { selectedMode: "Flashcards" };
    if (mode2 === "Flashcards" || mode2 === "Quiz" || mode2 === "Blocks") {
      state.study.selectedMode = mode2;
    }
  }
  function setStudySessions(map) {
    state.studySessions = map ? { ...map } : {};
    state.studySessionsLoaded = true;
  }
  function setStudySessionEntry(mode2, entry) {
    if (!mode2) return;
    const next = { ...state.studySessions || {} };
    if (entry) {
      next[mode2] = entry;
    } else {
      delete next[mode2];
    }
    state.studySessions = next;
  }
  function clearStudySessionsState() {
    state.studySessions = {};
    state.studySessionsLoaded = false;
  }
  var DEFAULT_ENTRY_FILTERS, DEFAULT_LECTURE_STATE, DEFAULT_ENTRY_LAYOUT, DEFAULT_EXAM_LAYOUT, preferences, initialFilters, initialLectures, initialEntryLayout, initialExamLayout, state;
  var init_state = __esm({
    "js/state.js"() {
      init_preferences();
      DEFAULT_ENTRY_FILTERS = {
        types: ["disease", "drug", "concept"],
        block: "",
        week: "",
        onlyFav: false,
        sort: "updated-desc"
      };
      DEFAULT_LECTURE_STATE = {
        query: "",
        blockId: "",
        week: "",
        status: "",
        tag: "",
        sort: "position-asc",
        openBlocks: [],
        openWeeks: [],
        openSnapshot: 0,
        scrollTop: 0
      };
      DEFAULT_ENTRY_LAYOUT = {
        mode: "list",
        columns: 3,
        scale: 1,
        controlsVisible: false
      };
      DEFAULT_EXAM_LAYOUT = {
        mode: "grid",
        detailsVisible: false
      };
      preferences = loadUIPreferences();
      initialFilters = { ...DEFAULT_ENTRY_FILTERS, ...sanitizeEntryFilters(preferences.filters) };
      initialLectures = { ...DEFAULT_LECTURE_STATE, ...sanitizeLectureState(preferences.lectures || {}) };
      initialEntryLayout = { ...DEFAULT_ENTRY_LAYOUT, ...sanitizeEntryLayout(preferences.entryLayout) };
      initialExamLayout = { ...DEFAULT_EXAM_LAYOUT, ...sanitizeExamLayout(preferences.examLayout) };
      state = {
        tab: "Block Board",
        subtab: {
          Diseases: "Browse",
          Drugs: "Browse",
          Concepts: "Browse",
          Lists: "Diseases",
          Study: "Builder",
          Exams: "",
          // placeholder
          Settings: ""
        },
        query: "",
        filters: initialFilters,
        lectures: initialLectures,
        entryLayout: initialEntryLayout,
        blockBoard: {
          collapsedBlocks: [],
          hiddenTimelines: [],
          autoCollapsed: [],
          autoHidden: [],
          manualExpanded: [],
          manualTimeline: []
        },
        builder: {
          blocks: [],
          weeks: [],
          lectures: [],
          types: ["disease", "drug", "concept"],
          tags: [],
          onlyFav: false,
          manualPicks: [],
          collapsedBlocks: [],
          collapsedWeeks: [],
          activeBlockId: "",
          activeWeekKey: ""
        },
        cards: {
          collapsedBlocks: [],
          collapsedWeeks: [],
          initialized: false
        },
        cohort: [],
        review: { count: 20, format: "flashcards" },
        quizSession: null,
        flashSession: null,
        examSession: null,
        examAttemptExpanded: {},
        examLayout: initialExamLayout,
        blockMode: { section: "", assignments: {}, reveal: {}, order: {} },
        study: { selectedMode: "Flashcards" },
        studySessions: {},
        studySessionsLoaded: false
      };
    }
  });

  // js/utils.js
  function uid() {
    const g = globalThis;
    return g.crypto?.randomUUID?.() || Math.random().toString(36).slice(2);
  }
  function debounce(fn, delay = 150) {
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), delay);
    };
  }
  function cloneArrayBuffer(buffer) {
    if (typeof buffer.slice === "function") {
      return buffer.slice(0);
    }
    const copy = new ArrayBuffer(buffer.byteLength);
    new Uint8Array(copy).set(new Uint8Array(buffer));
    return copy;
  }
  function cloneArrayBufferView(view, seen) {
    if (typeof view?.constructor?.from === "function") {
      return view.constructor.from(view);
    }
    if (ArrayBuffer.isView(view)) {
      const bufferCopy = deepClone(view.buffer, seen);
      if (typeof DataView !== "undefined" && view instanceof DataView) {
        return new DataView(bufferCopy, view.byteOffset, view.byteLength);
      }
      return new view.constructor(bufferCopy, view.byteOffset, view.length ?? void 0);
    }
    return view;
  }
  function deepClone(value, seen = /* @__PURE__ */ new WeakMap()) {
    if (value == null || typeof value !== "object") {
      return value;
    }
    if (structuredCloneFn) {
      try {
        return structuredCloneFn(value);
      } catch (err) {
      }
    }
    if (seen.has(value)) {
      return seen.get(value);
    }
    if (value instanceof Date) {
      return new Date(value.getTime());
    }
    if (value instanceof RegExp) {
      const copy = new RegExp(value.source, value.flags);
      copy.lastIndex = value.lastIndex;
      return copy;
    }
    if (ArrayBuffer.isView(value)) {
      const cloned = cloneArrayBufferView(value, seen);
      seen.set(value, cloned);
      return cloned;
    }
    if (value instanceof ArrayBuffer) {
      const copy = cloneArrayBuffer(value);
      seen.set(value, copy);
      return copy;
    }
    if (Array.isArray(value)) {
      const result2 = [];
      seen.set(value, result2);
      for (let i = 0; i < value.length; i += 1) {
        result2[i] = deepClone(value[i], seen);
      }
      return result2;
    }
    if (value instanceof Map) {
      const result2 = /* @__PURE__ */ new Map();
      seen.set(value, result2);
      value.forEach((mapValue, key) => {
        const clonedKey = typeof key === "object" && key !== null ? deepClone(key, seen) : key;
        result2.set(clonedKey, deepClone(mapValue, seen));
      });
      return result2;
    }
    if (value instanceof Set) {
      const result2 = /* @__PURE__ */ new Set();
      seen.set(value, result2);
      value.forEach((entry) => {
        result2.add(deepClone(entry, seen));
      });
      return result2;
    }
    const result = {};
    seen.set(value, result);
    for (const [key, val] of Object.entries(value)) {
      result[key] = deepClone(val, seen);
    }
    return result;
  }
  function parseDateValue(value) {
    if (!value) return Number.NaN;
    if (value instanceof Date) {
      const time2 = value.getTime();
      return Number.isNaN(time2) ? Number.NaN : time2;
    }
    const date = new Date(value);
    const time = date.getTime();
    return Number.isNaN(time) ? Number.NaN : time;
  }
  function findActiveBlockId(blocks, now = Date.now()) {
    if (!Array.isArray(blocks) || blocks.length === 0) return "";
    const nowTs = Number.isFinite(now) ? now : Date.now();
    let current = null;
    let upcoming = null;
    let recent = null;
    blocks.forEach((block) => {
      if (!block || block.blockId == null) return;
      const id = String(block.blockId);
      const start = parseDateValue(block.startDate);
      const end = parseDateValue(block.endDate);
      const hasStart = Number.isFinite(start);
      const hasEnd = Number.isFinite(end);
      if (hasStart && hasEnd) {
        if (start <= nowTs && nowTs <= end) {
          if (!current || start < current.start || start === current.start && end < current.end) {
            current = { id, start, end };
          }
          return;
        }
        if (start > nowTs) {
          if (!upcoming || start < upcoming.start) {
            upcoming = { id, start };
          }
          return;
        }
        if (!recent || end > recent.end) {
          recent = { id, end };
        }
        return;
      }
      if (hasStart) {
        if (start <= nowTs) {
          if (!recent || start > recent.end) {
            recent = { id, end: start };
          }
        } else if (!upcoming || start < upcoming.start) {
          upcoming = { id, start };
        }
        return;
      }
      if (hasEnd) {
        if (nowTs <= end) {
          if (!current || end < current.end) {
            current = { id, start: end, end };
          }
        } else if (!recent || end > recent.end) {
          recent = { id, end };
        }
      }
    });
    if (current) return current.id;
    if (upcoming) return upcoming.id;
    if (recent) return recent.id;
    const first = blocks.find((block) => block && block.blockId != null);
    return first ? String(first.blockId) : "";
  }
  function resolveLatestBlockId(blocks = []) {
    if (!Array.isArray(blocks) || blocks.length === 0) return null;
    let latestId = null;
    let latestScore = -Infinity;
    let fallbackId = null;
    const total = blocks.length;
    blocks.forEach((block, index) => {
      if (!block || block.blockId == null) return;
      const blockId = String(block.blockId);
      if (!fallbackId) fallbackId = blockId;
      const orderScore = Number(block?.order);
      const createdScore = Number(block?.createdAt);
      const startScore = parseDateValue(block?.startDate);
      const endScore = parseDateValue(block?.endDate);
      let score;
      if (Number.isFinite(orderScore)) {
        score = orderScore;
      } else if (Number.isFinite(createdScore)) {
        score = createdScore;
      } else if (Number.isFinite(startScore)) {
        score = startScore;
      } else if (Number.isFinite(endScore)) {
        score = endScore;
      } else {
        score = total - index;
      }
      if (latestId == null || score > latestScore) {
        latestId = blockId;
        latestScore = score;
      }
    });
    return latestId ?? fallbackId;
  }
  function setToggleState(element, active, className = "active") {
    if (!element) return;
    const isActive = Boolean(active);
    if (element.dataset) {
      element.dataset.toggle = "true";
      element.dataset.active = isActive ? "true" : "false";
    }
    if (className && element.classList) {
      element.classList.toggle(className, isActive);
    }
    if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
      const role = element.getAttribute("role");
      if ((element.tagName === "BUTTON" || role === "button") && typeof element.setAttribute === "function") {
        element.setAttribute("aria-pressed", isActive ? "true" : "false");
      }
    }
  }
  var structuredCloneFn;
  var init_utils = __esm({
    "js/utils.js"() {
      structuredCloneFn = typeof globalThis.structuredClone === "function" ? globalThis.structuredClone.bind(globalThis) : null;
    }
  });

  // js/lectures/scheduler.js
  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }
  function sanitizeLabel(label, order) {
    if (typeof label === "string" && label.trim()) return label.trim();
    return `Pass ${order}`;
  }
  function sanitizeAction(action) {
    if (typeof action === "string") {
      const trimmed = action.trim();
      if (trimmed) return trimmed;
    }
    return "";
  }
  function inferAnchor(offsetMinutes) {
    if (!Number.isFinite(offsetMinutes)) return "today";
    if (offsetMinutes < DAY_MINUTES) return "today";
    if (offsetMinutes < DAY_MINUTES * 2) return "tomorrow";
    return "upcoming";
  }
  function startOfDay(timestamp) {
    const date = new Date(timestamp);
    date.setHours(0, 0, 0, 0);
    return date.getTime();
  }
  function computeAnchoredDue(startAt, step, plannerDefaults) {
    const offsetMinutes = toNumber(step?.offsetMinutes, 0);
    const base = startAt + Math.round(offsetMinutes * MINUTE_MS);
    if (!plannerDefaults || typeof plannerDefaults !== "object") return base;
    const anchorName = typeof step?.anchor === "string" && step.anchor.trim() ? step.anchor.trim() : inferAnchor(offsetMinutes);
    const anchorOffsets = plannerDefaults.anchorOffsets || {};
    const anchorMinutes = toNumber(anchorOffsets[anchorName], null);
    if (anchorMinutes == null) return base;
    const anchorBase = startOfDay(base) + Math.round(anchorMinutes * MINUTE_MS);
    if (!Number.isFinite(anchorBase)) return base;
    if (offsetMinutes >= 0 && anchorBase < base) {
      return base;
    }
    return anchorBase;
  }
  function normalizePassPlan(plan) {
    const source = plan && typeof plan === "object" ? plan : {};
    const mergedSchedule = Array.isArray(source.schedule) ? source.schedule : DEFAULT_PASS_PLAN.schedule;
    const normalizedSchedule = (Array.isArray(mergedSchedule) ? mergedSchedule : []).map((step, index) => {
      const order = toNumber(step?.order, index + 1);
      const offsetMinutes = toNumber(step?.offsetMinutes, DEFAULT_PASS_PLAN.schedule[index]?.offsetMinutes ?? 0);
      const anchor = typeof step?.anchor === "string" && step.anchor.trim() ? step.anchor.trim() : inferAnchor(offsetMinutes);
      const label = sanitizeLabel(step?.label, order);
      const action = sanitizeAction(step?.action ?? DEFAULT_PASS_PLAN.schedule[index]?.action);
      return { order, offsetMinutes, anchor, label, action };
    }).sort((a, b) => a.order - b.order);
    return {
      id: typeof source.id === "string" && source.id.trim() ? source.id.trim() : DEFAULT_PASS_PLAN.id,
      schedule: normalizedSchedule
    };
  }
  function normalizePlannerDefaults(raw) {
    const source = raw && typeof raw === "object" ? raw : {};
    const anchorOffsets = {};
    const defaultAnchors = DEFAULT_PLANNER_DEFAULTS.anchorOffsets;
    const incomingAnchors = source.anchorOffsets && typeof source.anchorOffsets === "object" ? source.anchorOffsets : {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(defaultAnchors),
      ...Object.keys(incomingAnchors)
    ]);
    for (const key of allKeys) {
      const fallback = defaultAnchors[key] ?? 0;
      const value = incomingAnchors[key];
      anchorOffsets[key] = toNumber(value, fallback);
    }
    const passesSource = Array.isArray(source.passes) ? source.passes : DEFAULT_PLANNER_DEFAULTS.passes;
    const normalizedPlan = normalizePassPlan({ schedule: passesSource });
    const paletteSource = Array.isArray(source.passColors) && source.passColors.length ? source.passColors : DEFAULT_PASS_COLORS;
    const passColors = paletteSource.map((color, index) => {
      if (typeof color === "string") {
        const trimmed = color.trim();
        if (trimmed) return trimmed;
      }
      return DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
    });
    const palette2 = passColors.length ? passColors : DEFAULT_PASS_COLORS.slice();
    return {
      anchorOffsets,
      passes: normalizedPlan.schedule.map((step) => ({
        order: step.order,
        label: step.label,
        offsetMinutes: step.offsetMinutes,
        anchor: step.anchor,
        action: step.action
      })),
      passColors: palette2
    };
  }
  function sanitizeAttachments(raw) {
    if (!Array.isArray(raw)) return [];
    return raw.filter((att) => att != null).map((att) => typeof att === "object" ? deepClone(att) : att);
  }
  function normalizeLecturePasses({
    plan,
    passes,
    plannerDefaults,
    startAt,
    now = Date.now()
  } = {}) {
    const normalizedPlan = normalizePassPlan(plan || DEFAULT_PASS_PLAN);
    const schedule2 = normalizedPlan.schedule;
    const existingList = Array.isArray(passes) ? passes : [];
    const existingByOrder = /* @__PURE__ */ new Map();
    existingList.forEach((entry, index) => {
      if (!entry || typeof entry !== "object") return;
      const order = toNumber(entry.order, index + 1);
      if (!existingByOrder.has(order)) {
        existingByOrder.set(order, entry);
      }
    });
    const planner = normalizePlannerDefaults(plannerDefaults || {});
    const anchorConfig = {
      anchorOffsets: planner.anchorOffsets,
      schedule: planner.passes
    };
    const startTimestamp = Number.isFinite(startAt) ? startAt : now;
    const normalizedPasses = schedule2.map((step, index) => {
      const existing = existingByOrder.get(step.order) || existingList[index] || {};
      const dueCandidate = Number.isFinite(existing?.due) ? existing.due : null;
      const due = dueCandidate != null ? dueCandidate : computeAnchoredDue(startTimestamp, step, anchorConfig);
      const completedAt = Number.isFinite(existing?.completedAt) ? existing.completedAt : null;
      const label = sanitizeLabel(existing?.label ?? step.label, step.order);
      const anchor = typeof (existing?.anchor ?? step.anchor) === "string" ? existing?.anchor ?? step.anchor : inferAnchor(step.offsetMinutes);
      const attachments = sanitizeAttachments(existing.attachments);
      const action = sanitizeAction(existing?.action ?? step.action);
      return {
        order: step.order,
        label,
        offsetMinutes: step.offsetMinutes,
        anchor,
        due,
        completedAt,
        attachments,
        action
      };
    });
    return normalizedPasses;
  }
  function calculateNextDue(passes) {
    if (!Array.isArray(passes) || !passes.length) return null;
    const dueTimes = passes.filter((pass) => pass && !pass.completedAt).map((pass) => Number.isFinite(pass.due) ? pass.due : null).filter((due) => due != null).sort((a, b) => a - b);
    return dueTimes.length ? dueTimes[0] : null;
  }
  function deriveLectureStatus(passes, base = {}) {
    const total = Array.isArray(passes) ? passes.length : 0;
    const completed = Array.isArray(passes) ? passes.filter((pass) => Number.isFinite(pass?.completedAt)).length : 0;
    const lastCompletedAt = Array.isArray(passes) ? passes.reduce((max, pass) => {
      const ts = Number.isFinite(pass?.completedAt) ? pass.completedAt : null;
      if (ts == null) return max;
      return max == null ? ts : Math.max(max, ts);
    }, null) : null;
    let state2 = "pending";
    if (total === 0) {
      state2 = "unscheduled";
    } else if (completed === 0) {
      state2 = "pending";
    } else if (completed < total) {
      state2 = "in-progress";
    } else {
      state2 = "complete";
    }
    const merged = {
      ...base,
      completedPasses: completed,
      lastCompletedAt,
      state: state2
    };
    return merged;
  }
  function markPassCompleted(lecture, passIndex, completedAt = Date.now()) {
    if (!lecture || typeof lecture !== "object") return null;
    const passes = Array.isArray(lecture.passes) ? lecture.passes.map((pass) => ({ ...pass })) : [];
    if (!Number.isFinite(passIndex)) return { ...lecture, passes, nextDueAt: calculateNextDue(passes), status: deriveLectureStatus(passes, lecture.status) };
    if (passes.length === 0) {
      return { ...lecture, passes, nextDueAt: calculateNextDue(passes), status: deriveLectureStatus(passes, lecture.status) };
    }
    const clamped = Math.floor(passIndex);
    if (clamped < 0 || clamped >= passes.length) {
      return { ...lecture, passes, nextDueAt: calculateNextDue(passes), status: deriveLectureStatus(passes, lecture.status) };
    }
    if (passes[clamped]) {
      passes[clamped].completedAt = completedAt;
    }
    const status = deriveLectureStatus(passes, lecture.status);
    const nextDueAt = calculateNextDue(passes);
    return {
      ...lecture,
      passes,
      status,
      nextDueAt
    };
  }
  function groupLectureQueues(lectures, { now = Date.now() } = {}) {
    const result = {
      overdue: [],
      today: [],
      tomorrow: [],
      upcoming: []
    };
    if (!Array.isArray(lectures) || !lectures.length) return result;
    const startToday = startOfDay(now);
    const startTomorrow = startToday + DAY_MINUTES * MINUTE_MS;
    const startDayAfter = startTomorrow + DAY_MINUTES * MINUTE_MS;
    const addEntry = (bucket, entry) => {
      result[bucket].push(entry);
    };
    for (const lecture of lectures) {
      if (!lecture || typeof lecture !== "object") continue;
      const passes = Array.isArray(lecture.passes) ? lecture.passes : [];
      const nextPass = passes.find((pass) => pass && !Number.isFinite(pass.completedAt));
      const due = Number.isFinite(nextPass?.due) ? nextPass.due : null;
      const entry = { lecture, pass: nextPass || null, due };
      if (due == null) {
        addEntry("upcoming", entry);
        continue;
      }
      if (due <= now) {
        addEntry("overdue", entry);
      } else if (due < startTomorrow) {
        addEntry("today", entry);
      } else if (due < startDayAfter) {
        addEntry("tomorrow", entry);
      } else {
        addEntry("upcoming", entry);
      }
    }
    for (const key of Object.keys(result)) {
      result[key].sort((a, b) => {
        if (a.due == null && b.due == null) return 0;
        if (a.due == null) return 1;
        if (b.due == null) return -1;
        return a.due - b.due;
      });
    }
    return result;
  }
  function clonePassPlan(plan = DEFAULT_PASS_PLAN) {
    return clone(plan || DEFAULT_PASS_PLAN);
  }
  function plannerDefaultsToPassPlan(defaults) {
    const normalized2 = normalizePlannerDefaults(defaults || {});
    const schedule2 = (normalized2?.passes || []).map((step, index) => {
      const order = toNumber(step?.order, index + 1);
      const offsetMinutes = toNumber(
        step?.offsetMinutes,
        DEFAULT_PASS_PLAN.schedule[index]?.offsetMinutes ?? 0
      );
      const anchor = typeof step?.anchor === "string" && step.anchor.trim() ? step.anchor.trim() : inferAnchor(offsetMinutes);
      const label = sanitizeLabel(step?.label, order);
      const action = sanitizeAction(step?.action ?? DEFAULT_PASS_PLAN.schedule[index]?.action);
      return { order, offsetMinutes, anchor, label, action };
    }).sort((a, b) => a.order - b.order);
    return {
      id: normalized2?.id || "planner-defaults",
      schedule: schedule2
    };
  }
  var DAY_MINUTES, MINUTE_MS, DEFAULT_PASS_COLORS, clone, DEFAULT_PASS_PLAN, DEFAULT_PLANNER_DEFAULTS;
  var init_scheduler = __esm({
    "js/lectures/scheduler.js"() {
      init_utils();
      DAY_MINUTES = 24 * 60;
      MINUTE_MS = 60 * 1e3;
      DEFAULT_PASS_COLORS = [
        "#38bdf8",
        "#0ea5e9",
        "#34d399",
        "#10b981",
        "#facc15",
        "#f97316",
        "#f472b6",
        "#a855f7",
        "#818cf8",
        "#2dd4bf"
      ];
      clone = deepClone;
      DEFAULT_PASS_PLAN = {
        id: "default",
        schedule: [
          { order: 1, label: "Pass 1", offsetMinutes: 0, anchor: "today", action: "Notes" },
          { order: 2, label: "Pass 2", offsetMinutes: 24 * 60, anchor: "tomorrow", action: "Review" },
          { order: 3, label: "Pass 3", offsetMinutes: 72 * 60, anchor: "upcoming", action: "Quiz" }
        ]
      };
      DEFAULT_PLANNER_DEFAULTS = {
        anchorOffsets: {
          today: 0,
          tomorrow: 8 * 60,
          upcoming: 8 * 60
        },
        passes: DEFAULT_PASS_PLAN.schedule.map((entry) => ({
          order: entry.order,
          label: entry.label,
          offsetMinutes: entry.offsetMinutes,
          anchor: entry.anchor
        })),
        passColors: DEFAULT_PASS_COLORS
      };
    }
  });

  // js/storage/lecture-schema.js
  function lectureKey(blockId, lectureId) {
    return `${blockId}${KEY_SEPARATOR}${lectureId}`;
  }
  function cloneDefaultPassPlan() {
    return deepClone(DEFAULT_PASS_PLAN);
  }
  function cloneDefaultStatus() {
    return deepClone(DEFAULT_LECTURE_STATUS);
  }
  function normalizeLectureRecord(blockId, lecture, now = Date.now()) {
    if (!lecture || blockId == null || lecture.id == null) return null;
    const key = lecture.key || lectureKey(blockId, lecture.id);
    const name = typeof lecture.name === "string" ? lecture.name : "";
    const weekRaw = lecture.week;
    let week = null;
    if (typeof weekRaw === "number" && Number.isFinite(weekRaw)) {
      week = weekRaw;
    } else if (typeof weekRaw === "string" && weekRaw.trim()) {
      const parsed = Number(weekRaw);
      if (!Number.isNaN(parsed)) week = parsed;
    }
    const startRaw = lecture.startAt;
    let startAt = null;
    if (Number.isFinite(startRaw)) {
      startAt = startRaw;
    } else if (typeof startRaw === "string" && startRaw.trim()) {
      const parsedStart = Number(startRaw);
      if (!Number.isNaN(parsedStart)) {
        startAt = parsedStart;
      }
    }
    if (!Number.isFinite(startAt)) {
      startAt = Number.isFinite(lecture.createdAt) ? lecture.createdAt : now;
    }
    const tags = Array.isArray(lecture.tags) ? lecture.tags.filter((tag) => typeof tag === "string" && tag.trim()).map((tag) => tag.trim()) : [];
    const passPlan = lecture.passPlan ? normalizePassPlan({ ...cloneDefaultPassPlan(), ...lecture.passPlan }) : normalizePassPlan(cloneDefaultPassPlan());
    const plannerDefaults = normalizePlannerDefaults(lecture.plannerDefaults || {});
    const passes = normalizeLecturePasses({
      plan: passPlan,
      passes: lecture.passes,
      plannerDefaults,
      startAt,
      now
    });
    const statusBase = lecture.status ? { ...cloneDefaultStatus(), ...lecture.status } : cloneDefaultStatus();
    const status = deriveLectureStatus(passes, statusBase);
    const nextDueAt = calculateNextDue(passes);
    const createdAt = typeof lecture.createdAt === "number" ? lecture.createdAt : now;
    const updatedAt = now;
    return {
      key,
      blockId,
      id: lecture.id,
      name,
      week,
      tags,
      passes,
      passPlan,
      plannerDefaults,
      status,
      nextDueAt,
      startAt,
      createdAt,
      updatedAt
    };
  }
  var KEY_SEPARATOR, DEFAULT_LECTURE_STATUS;
  var init_lecture_schema = __esm({
    "js/storage/lecture-schema.js"() {
      init_scheduler();
      init_utils();
      init_scheduler();
      KEY_SEPARATOR = "|";
      DEFAULT_LECTURE_STATUS = {
        state: "pending",
        completedPasses: 0,
        lastCompletedAt: null
      };
    }
  });

  // js/storage/idb.js
  function fallbackToMemory(message, error) {
    if (message) {
      console.warn(message, error);
    }
    return new MemoryDB();
  }
  function openDB() {
    if (!("indexedDB" in globalThis)) {
      return Promise.resolve(fallbackToMemory("IndexedDB unavailable, using in-memory storage."));
    }
    return new Promise((resolve) => {
      let settled = false;
      let req;
      try {
        req = indexedDB.open(DB_NAME, DB_VERSION);
      } catch (err) {
        settled = true;
        resolve(fallbackToMemory("IndexedDB threw during open, using in-memory storage.", err));
        return;
      }
      const timer = setTimeout(() => {
        if (!settled) {
          settled = true;
          resolve(fallbackToMemory("IndexedDB open timeout, using in-memory storage."));
        }
      }, 5e3);
      req.onerror = () => {
        if (settled) return;
        settled = true;
        clearTimeout(timer);
        resolve(fallbackToMemory("IndexedDB failed to open, using in-memory storage.", req.error));
      };
      req.onupgradeneeded = (event) => {
        const db = req.result;
        const tx = req.transaction;
        if (!db.objectStoreNames.contains("items")) {
          const items = db.createObjectStore("items", { keyPath: "id" });
          items.createIndex("by_kind", "kind");
          items.createIndex("by_updatedAt", "updatedAt");
          items.createIndex("by_favorite", "favorite");
          items.createIndex("by_blocks", "blocks", { multiEntry: true });
          items.createIndex("by_weeks", "weeks", { multiEntry: true });
          items.createIndex("by_lecture_ids", "lectures.id", { multiEntry: true });
          items.createIndex("by_search", "tokens");
        }
        if (!db.objectStoreNames.contains("blocks")) {
          const blocks = db.createObjectStore("blocks", { keyPath: "blockId" });
          blocks.createIndex("by_title", "title");
          blocks.createIndex("by_createdAt", "createdAt");
        }
        if (!db.objectStoreNames.contains("exams")) {
          const exams = db.createObjectStore("exams", { keyPath: "id" });
          exams.createIndex("by_createdAt", "createdAt");
        }
        if (!db.objectStoreNames.contains("settings")) {
          db.createObjectStore("settings", { keyPath: "id" });
        }
        if (!db.objectStoreNames.contains("exam_sessions")) {
          const sessions = db.createObjectStore("exam_sessions", { keyPath: "examId" });
          sessions.createIndex("by_updatedAt", "updatedAt");
        }
        if (!db.objectStoreNames.contains("study_sessions")) {
          const sessions = db.createObjectStore("study_sessions", { keyPath: "mode" });
          sessions.createIndex("by_updatedAt", "updatedAt");
        }
        let lecturesStore = null;
        if (!db.objectStoreNames.contains("lectures")) {
          lecturesStore = db.createObjectStore("lectures", { keyPath: "key" });
          lecturesStore.createIndex("by_block", "blockId");
          lecturesStore.createIndex("by_tags", "tags", { multiEntry: true });
          lecturesStore.createIndex("by_nextDue", "nextDueAt");
        } else if (tx) {
          try {
            lecturesStore = tx.objectStore("lectures");
            if (lecturesStore) {
              const indexNames = Array.from(lecturesStore.indexNames || []);
              if (!indexNames.includes("by_block")) {
                lecturesStore.createIndex("by_block", "blockId");
              }
              if (!indexNames.includes("by_tags")) {
                lecturesStore.createIndex("by_tags", "tags", { multiEntry: true });
              }
              if (!indexNames.includes("by_nextDue")) {
                lecturesStore.createIndex("by_nextDue", "nextDueAt");
              }
            }
          } catch (err) {
            console.warn("Failed to ensure lecture indexes", err);
          }
        }
        if (tx && lecturesStore && event.oldVersion < 5) {
          try {
            const blocksStore = tx.objectStore("blocks");
            if (blocksStore && typeof blocksStore.getAll === "function") {
              const readReq = blocksStore.getAll();
              readReq.onsuccess = () => {
                const blocks = Array.isArray(readReq.result) ? readReq.result : [];
                const now = Date.now();
                for (const block of blocks) {
                  const originalLectures = Array.isArray(block?.lectures) ? block.lectures : [];
                  const hadLecturesField = Object.prototype.hasOwnProperty.call(block || {}, "lectures");
                  if (originalLectures.length) {
                    const sanitized = { ...block };
                    delete sanitized.lectures;
                    try {
                      blocksStore.put(sanitized);
                    } catch (err) {
                      console.warn("Failed to persist migrated block", err);
                    }
                    for (const lecture of originalLectures) {
                      const normalized2 = normalizeLectureRecord(block.blockId, lecture, now);
                      if (!normalized2) continue;
                      try {
                        lecturesStore.put(normalized2);
                      } catch (err) {
                        console.warn("Failed to migrate lecture", err);
                      }
                    }
                  } else if (hadLecturesField) {
                    const sanitized = { ...block };
                    delete sanitized.lectures;
                    try {
                      blocksStore.put(sanitized);
                    } catch (err) {
                      console.warn("Failed to clean block lectures field", err);
                    }
                  }
                }
              };
              readReq.onerror = () => {
                console.warn("Failed to read blocks during lecture migration", readReq.error);
              };
            }
          } catch (err) {
            console.warn("Lecture migration failed", err);
          }
        }
      };
      req.onsuccess = () => {
        if (settled) return;
        settled = true;
        clearTimeout(timer);
        resolve(req.result);
      };
    });
  }
  var DB_NAME, DB_VERSION, MEMORY_STORAGE_KEY, STORE_KEY_PATHS, enqueue, clone2, MemoryRequest, MemoryIndex, MemoryStore, MemoryTransaction, MemoryDB;
  var init_idb = __esm({
    "js/storage/idb.js"() {
      init_lecture_schema();
      init_utils();
      DB_NAME = "arc-db";
      DB_VERSION = 5;
      MEMORY_STORAGE_KEY = "arc-memory-db";
      STORE_KEY_PATHS = {
        items: "id",
        blocks: "blockId",
        exams: "id",
        settings: "id",
        exam_sessions: "examId",
        study_sessions: "mode",
        lectures: "key"
      };
      enqueue = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : ((cb) => Promise.resolve().then(cb));
      clone2 = deepClone;
      MemoryRequest = class {
        constructor(tx, executor) {
          this.result = void 0;
          this.error = null;
          this.onsuccess = null;
          this.onerror = null;
          tx._requestStarted();
          enqueue(() => {
            try {
              this.result = executor();
              if (typeof this.onsuccess === "function") {
                this.onsuccess({ target: this });
              }
              tx._requestFinished();
            } catch (err) {
              this.error = err;
              if (typeof this.onerror === "function") {
                this.onerror({ target: this });
              }
              tx._requestFailed(err);
            }
          });
        }
      };
      MemoryIndex = class {
        constructor(store2, extractor, multiEntry = false) {
          this.store = store2;
          this.extractor = extractor;
          this.multiEntry = multiEntry;
        }
        getAll(value) {
          return new MemoryRequest(this.store.tx, () => {
            const results = [];
            for (const item of this.store._map().values()) {
              const extracted = this.extractor(item);
              if (this.multiEntry && Array.isArray(extracted)) {
                if (extracted.includes(value)) results.push(clone2(item));
              } else if (extracted === value) {
                results.push(clone2(item));
              }
            }
            return results;
          });
        }
        getAllKeys(value) {
          return new MemoryRequest(this.store.tx, () => {
            const results = [];
            for (const [key, item] of this.store._map()) {
              const extracted = this.extractor(item);
              if (this.multiEntry && Array.isArray(extracted)) {
                if (extracted.includes(value)) results.push(key);
              } else if (extracted === value) {
                results.push(key);
              }
            }
            return results;
          });
        }
      };
      MemoryStore = class {
        constructor(tx, name) {
          this.tx = tx;
          this.name = name;
        }
        _map() {
          if (!this.tx.db.maps[this.name]) {
            this.tx.db.maps[this.name] = /* @__PURE__ */ new Map();
          }
          return this.tx.db.maps[this.name];
        }
        _keyFromValue(value) {
          const keyPath = STORE_KEY_PATHS[this.name];
          if (!keyPath) return void 0;
          return value?.[keyPath];
        }
        get(key) {
          return new MemoryRequest(this.tx, () => {
            const found = this._map().get(key);
            return clone2(found);
          });
        }
        getAll() {
          return new MemoryRequest(this.tx, () => {
            return Array.from(this._map().values()).map(clone2);
          });
        }
        put(value) {
          return new MemoryRequest(this.tx, () => {
            const key = this._keyFromValue(value);
            if (key == null) throw new Error(`Missing key for store ${this.name}`);
            this._map().set(key, clone2(value));
            this.tx.db._persist();
            return clone2(value);
          });
        }
        delete(key) {
          return new MemoryRequest(this.tx, () => {
            this._map().delete(key);
            this.tx.db._persist();
            return void 0;
          });
        }
        clear() {
          return new MemoryRequest(this.tx, () => {
            this._map().clear();
            this.tx.db._persist();
            return void 0;
          });
        }
        index(name) {
          if (this.name === "items") {
            switch (name) {
              case "by_kind":
                return new MemoryIndex(this, (item) => item.kind || null);
              case "by_blocks":
                return new MemoryIndex(this, (item) => item.blocks || [], true);
              case "by_weeks":
                return new MemoryIndex(this, (item) => item.weeks || [], true);
              case "by_favorite":
                return new MemoryIndex(this, (item) => !!item.favorite);
              default:
                break;
            }
          } else if (this.name === "lectures") {
            switch (name) {
              case "by_block":
                return new MemoryIndex(this, (item) => item.blockId || null);
              case "by_tags":
                return new MemoryIndex(this, (item) => item.tags || [], true);
              case "by_nextDue":
                return new MemoryIndex(this, (item) => item.nextDueAt ?? null);
              default:
                break;
            }
          }
          return {
            getAll: () => new MemoryRequest(this.tx, () => []),
            getAllKeys: () => new MemoryRequest(this.tx, () => [])
          };
        }
      };
      MemoryTransaction = class {
        constructor(db, names, mode2) {
          this.db = db;
          this.names = Array.isArray(names) ? names : [names];
          this.mode = mode2;
          this._stores = /* @__PURE__ */ new Map();
          this._pending = 0;
          this._failed = false;
          this._completePending = false;
          this._errorPending = null;
          this._oncomplete = null;
          this._onerror = null;
          Object.defineProperty(this, "oncomplete", {
            get: () => this._oncomplete,
            set: (fn) => {
              this._oncomplete = fn;
              if (this._completePending && typeof fn === "function") {
                this._completePending = false;
                enqueue(() => fn({ target: this }));
              }
            }
          });
          Object.defineProperty(this, "onerror", {
            get: () => this._onerror,
            set: (fn) => {
              this._onerror = fn;
              if (this._errorPending && typeof fn === "function") {
                const err = this._errorPending;
                this._errorPending = null;
                enqueue(() => fn({ target: this, error: err }));
              }
            }
          });
        }
        objectStore(name) {
          if (!this._stores.has(name)) {
            this._stores.set(name, new MemoryStore(this, name));
          }
          return this._stores.get(name);
        }
        _requestStarted() {
          this._pending += 1;
        }
        _requestFinished() {
          if (this._pending > 0) this._pending -= 1;
          if (this._pending === 0 && !this._failed) {
            if (typeof this._oncomplete === "function") {
              enqueue(() => this._oncomplete({ target: this }));
            } else {
              this._completePending = true;
            }
          }
        }
        _requestFailed(error) {
          this._failed = true;
          if (typeof this._onerror === "function") {
            enqueue(() => this._onerror({ target: this, error }));
          } else {
            this._errorPending = error;
          }
        }
      };
      MemoryDB = class {
        constructor() {
          this.maps = {};
          this.persistKey = MEMORY_STORAGE_KEY;
          this.canPersist = false;
          if (typeof localStorage !== "undefined") {
            try {
              const testKey = `${MEMORY_STORAGE_KEY}-test`;
              localStorage.setItem(testKey, "1");
              localStorage.removeItem(testKey);
              this.canPersist = true;
            } catch (err) {
              this.canPersist = false;
            }
          }
          for (const name of Object.keys(STORE_KEY_PATHS)) {
            this.maps[name] = /* @__PURE__ */ new Map();
          }
          this._load();
        }
        _load() {
          if (!this.canPersist) return;
          try {
            const raw = localStorage.getItem(this.persistKey);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            for (const name of Object.keys(STORE_KEY_PATHS)) {
              const list = parsed?.[name];
              if (Array.isArray(list)) {
                for (const entry of list) {
                  const keyPath = STORE_KEY_PATHS[name];
                  const key = entry?.[keyPath];
                  if (key != null) {
                    this.maps[name].set(key, clone2(entry));
                  }
                }
              }
            }
          } catch (err) {
            console.warn("Failed to load memory DB from storage", err);
            for (const name of Object.keys(STORE_KEY_PATHS)) {
              this.maps[name].clear();
            }
          }
        }
        _persist() {
          if (!this.canPersist) return;
          try {
            const payload = {};
            for (const name of Object.keys(STORE_KEY_PATHS)) {
              payload[name] = Array.from(this.maps[name].values()).map(clone2);
            }
            localStorage.setItem(this.persistKey, JSON.stringify(payload));
          } catch (err) {
            console.warn("Failed to persist memory DB", err);
            this.canPersist = false;
          }
        }
        transaction(names, mode2 = "readonly") {
          return new MemoryTransaction(this, names, mode2);
        }
        close() {
        }
      };
    }
  });

  // js/storage/lectures.js
  function prom(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function lectureStore(mode2 = "readonly") {
    const db = await openDB();
    return db.transaction("lectures", mode2).objectStore("lectures");
  }
  async function fetchLecturesForBlock(storeRef, blockId) {
    if (!blockId) return [];
    try {
      if (typeof storeRef.index === "function") {
        const idx = storeRef.index("by_block");
        if (idx && typeof idx.getAll === "function") {
          const results = await prom(idx.getAll(blockId));
          return Array.isArray(results) ? results : [];
        }
      }
    } catch (err) {
      console.warn("Failed to use lecture block index, falling back to scan", err);
    }
    const all = await prom(storeRef.getAll());
    return (Array.isArray(all) ? all : []).filter((entry) => entry?.blockId === blockId);
  }
  function buildNormalizedLecture(blockId, input, existing, now) {
    const lectureId = input?.id ?? existing?.id;
    if (blockId == null || lectureId == null) return null;
    const tags = Array.isArray(input?.tags) ? input.tags : Array.isArray(existing?.tags) ? existing.tags : void 0;
    const explicitPasses = Array.isArray(input?.passes);
    const passPlanChanged = Boolean(input?.passPlan);
    const plannerDefaultsChanged = Boolean(input?.plannerDefaults);
    const startProvided = input?.startAt !== void 0;
    const passContextChanged = passPlanChanged || plannerDefaultsChanged || startProvided;
    const shouldPreserveScheduleState = !explicitPasses && !passContextChanged;
    let passes;
    if (explicitPasses) {
      passes = input.passes;
    } else if (passContextChanged && Array.isArray(existing?.passes)) {
      passes = existing.passes.map((pass) => {
        if (!pass || typeof pass !== "object") return pass;
        const next = { ...pass };
        delete next.due;
        return next;
      });
    } else {
      passes = Array.isArray(existing?.passes) ? existing.passes : void 0;
    }
    const passPlan = passPlanChanged ? { ...existing?.passPlan || {}, ...input.passPlan } : existing?.passPlan;
    const status = input?.status ? { ...existing?.status || {}, ...input.status } : existing?.status;
    const plannerDefaults = plannerDefaultsChanged ? { ...existing?.plannerDefaults || {}, ...input.plannerDefaults } : existing?.plannerDefaults;
    const nextDueAt = input?.nextDueAt !== void 0 ? input.nextDueAt : existing?.nextDueAt;
    const composite = {
      ...existing || {},
      ...input || {},
      blockId,
      id: lectureId,
      key: lectureKey(blockId, lectureId),
      tags,
      passes,
      passPlan,
      plannerDefaults,
      status,
      nextDueAt
    };
    const normalized2 = normalizeLectureRecord(blockId, composite, now);
    if (existing?.createdAt != null) normalized2.createdAt = existing.createdAt;
    if (existing && !input?.passPlan && existing.passPlan) normalized2.passPlan = clone3(existing.passPlan);
    if (existing && shouldPreserveScheduleState && !input?.status && existing.status) {
      normalized2.status = clone3(existing.status);
    }
    if (existing && shouldPreserveScheduleState && Array.isArray(existing.passes)) {
      normalized2.passes = clone3(existing.passes);
    }
    if (existing && !Array.isArray(input?.tags) && Array.isArray(existing.tags)) {
      normalized2.tags = clone3(existing.tags);
    }
    if (existing && shouldPreserveScheduleState && input?.nextDueAt === void 0 && existing.nextDueAt !== void 0) {
      normalized2.nextDueAt = existing.nextDueAt ?? null;
    }
    return normalized2;
  }
  async function listLecturesByBlock(blockId) {
    try {
      const store2 = await lectureStore();
      const rows = await fetchLecturesForBlock(store2, blockId);
      return rows.map(clone3);
    } catch (err) {
      console.warn("listLecturesByBlock failed", err);
      return [];
    }
  }
  async function listAllLectures() {
    try {
      const store2 = await lectureStore();
      const rows = await prom(store2.getAll());
      return Array.isArray(rows) ? rows.map(clone3) : [];
    } catch (err) {
      console.warn("listAllLectures failed", err);
      return [];
    }
  }
  async function saveLecture(lecture) {
    if (!lecture || lecture.blockId == null) {
      throw new Error("Missing lecture identity for save");
    }
    const store2 = await lectureStore("readwrite");
    let lectureId = lecture.id;
    if (lectureId == null) {
      const rows = await fetchLecturesForBlock(store2, lecture.blockId);
      let maxId = 0;
      for (const row of rows) {
        const value = Number(row?.id);
        if (Number.isFinite(value) && value > maxId) {
          maxId = value;
        }
      }
      lectureId = maxId + 1;
    }
    if (typeof lectureId === "string") {
      const parsed = Number(lectureId);
      if (!Number.isNaN(parsed)) {
        lectureId = parsed;
      }
    }
    const key = lectureKey(lecture.blockId, lectureId);
    const existing = await prom(store2.get(key));
    const now = Date.now();
    const normalized2 = buildNormalizedLecture(lecture.blockId, { ...lecture, id: lectureId }, existing, now);
    if (!normalized2) throw new Error("Failed to normalize lecture payload");
    await prom(store2.put(normalized2));
    return clone3(normalized2);
  }
  async function deleteLectureRecord(blockId, lectureId) {
    if (blockId == null || lectureId == null) return;
    const store2 = await lectureStore("readwrite");
    await prom(store2.delete(lectureKey(blockId, lectureId)));
  }
  async function removeLecturesForBlock(blockId) {
    if (!blockId) return;
    const store2 = await lectureStore("readwrite");
    const rows = await fetchLecturesForBlock(store2, blockId);
    for (const row of rows) {
      await prom(store2.delete(row.key));
    }
  }
  var clone3;
  var init_lectures = __esm({
    "js/storage/lectures.js"() {
      init_idb();
      init_lecture_schema();
      init_utils();
      init_lecture_schema();
      clone3 = deepClone;
    }
  });

  // js/search.js
  function stripHtml(value = "") {
    return value.replace(/<br\s*\/?>(\s*)/gi, " ").replace(/<[^>]+>/g, " ").replace(/&nbsp;/gi, " ").replace(/&[#a-z0-9]+;/gi, " ");
  }
  function tokenize(str) {
    return str.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, " ").split(/\s+/).filter(Boolean);
  }
  function buildTokens(item) {
    const fields = [];
    if (item.name) fields.push(item.name);
    if (item.concept) fields.push(item.concept);
    fields.push(...item.tags || []);
    if (Array.isArray(item.extras)) {
      item.extras.forEach((extra) => {
        if (!extra) return;
        if (extra.title) fields.push(extra.title);
        if (extra.body) fields.push(stripHtml(extra.body));
      });
    } else if (item.facts && item.facts.length) {
      fields.push(...item.facts);
    }
    if (item.lectures) fields.push(...item.lectures.map((l) => l.name));
    contentFields.forEach((field) => {
      if (typeof item[field] === "string" && item[field]) {
        fields.push(stripHtml(item[field]));
      }
    });
    return Array.from(new Set(tokenize(fields.join(" ")))).slice(0, 200).join(" ");
  }
  function buildSearchMeta(item) {
    const pieces = [];
    if (item.name) pieces.push(item.name);
    if (item.concept) pieces.push(item.concept);
    pieces.push(...item.tags || []);
    pieces.push(...item.blocks || []);
    if (Array.isArray(item.lectures)) {
      pieces.push(...item.lectures.map((l) => l?.name || ""));
    }
    return pieces.join(" ").toLowerCase();
  }
  var contentFields;
  var init_search = __esm({
    "js/search.js"() {
      contentFields = [
        "etiology",
        "pathophys",
        "clinical",
        "diagnosis",
        "treatment",
        "complications",
        "mnemonic",
        "class",
        "source",
        "moa",
        "uses",
        "sideEffects",
        "contraindications",
        "type",
        "definition",
        "mechanism",
        "clinicalRelevance",
        "example"
      ];
    }
  });

  // js/storage/export.js
  function prom2(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function coerceBlockId(value) {
    if (value == null) return null;
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (typeof value === "string" && value.trim()) {
      const trimmed = value.trim();
      const maybeNumber = Number(trimmed);
      if (Number.isFinite(maybeNumber) && String(maybeNumber) === trimmed) {
        return maybeNumber;
      }
      return trimmed;
    }
    return null;
  }
  function normalizeBlockRecord(record, fallback = {}) {
    if (!record || typeof record !== "object") return null;
    const copy = deepClone(record);
    const fallbackId = fallback.blockId ?? fallback.id ?? fallback.block ?? null;
    const normalizedId = coerceBlockId(copy.blockId ?? fallbackId);
    if (normalizedId == null) return null;
    copy.blockId = normalizedId;
    if (Array.isArray(copy.lectures)) delete copy.lectures;
    return copy;
  }
  function normalizeLectureReference(ref) {
    if (!ref || typeof ref !== "object") return null;
    const blockId = coerceBlockId(ref.blockId ?? ref.block ?? null);
    const lectureIdRaw = ref.id ?? ref.lectureId ?? ref.key ?? null;
    if (lectureIdRaw == null) return null;
    const lectureIdNumber = Number(lectureIdRaw);
    const lectureId = Number.isFinite(lectureIdNumber) && `${lectureIdNumber}` === `${lectureIdRaw}` ? lectureIdNumber : lectureIdRaw;
    return {
      blockId,
      id: lectureId,
      name: typeof ref.name === "string" ? ref.name : "",
      week: ref.week ?? ref.weekNumber ?? null
    };
  }
  function normalizeItemRecord(item) {
    if (!item || typeof item !== "object") return null;
    const copy = deepClone(item);
    if (copy.id == null || copy.id === "") {
      copy.id = copy.uid || uid();
    }
    copy.kind = typeof copy.kind === "string" && copy.kind ? copy.kind : "concept";
    copy.blocks = Array.isArray(copy.blocks) ? Array.from(new Set(
      copy.blocks.map(coerceBlockId).filter((id) => id != null)
    )) : [];
    copy.weeks = Array.isArray(copy.weeks) ? Array.from(new Set(
      copy.weeks.map((week) => {
        const num = Number(week);
        return Number.isFinite(num) ? num : null;
      }).filter((value) => value != null)
    )) : [];
    copy.lectures = Array.isArray(copy.lectures) ? copy.lectures.map(normalizeLectureReference).filter(Boolean) : [];
    return copy;
  }
  function normalizeExamRecord(record) {
    if (!record || typeof record !== "object") return null;
    const id = record.id ?? record.examId ?? null;
    if (id == null || id === "") return null;
    return deepClone({ ...record, id });
  }
  function coerceExamId(value) {
    if (value == null) return null;
    if (typeof value === "string" && value.trim()) {
      return value.trim();
    }
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    return null;
  }
  function normalizeExamSessionRecord(record) {
    if (!record || typeof record !== "object") return null;
    const examId = coerceExamId(record.examId ?? record.id ?? null);
    if (examId == null) return null;
    const copy = deepClone(record);
    copy.examId = examId;
    if (!Number.isFinite(copy.updatedAt)) {
      copy.updatedAt = Date.now();
    }
    return copy;
  }
  function normalizeStudySessionRecord(record) {
    if (!record || typeof record !== "object") return null;
    const mode2 = typeof record.mode === "string" && record.mode.trim() ? record.mode.trim() : null;
    if (!mode2) return null;
    const session = record.session && typeof record.session === "object" && !Array.isArray(record.session) ? deepClone(record.session) : {};
    if (mode2 === "review") {
      session.mode = "review";
    } else if (typeof session.mode !== "string" || session.mode !== "review") {
      session.mode = "study";
    }
    const cohort = Array.isArray(record.cohort) ? record.cohort.map((entry) => entry === null || entry === void 0 ? null : deepClone(entry)).filter((entry) => entry !== null) : [];
    const metadata = record.metadata && typeof record.metadata === "object" && !Array.isArray(record.metadata) ? deepClone(record.metadata) : {};
    const normalized2 = {
      mode: mode2,
      updatedAt: Number.isFinite(record.updatedAt) ? record.updatedAt : Date.now(),
      session,
      cohort,
      metadata
    };
    return normalized2;
  }
  async function exportJSON() {
    const db = await openDB();
    const tx = db.transaction(TRANSACTION_STORES);
    const itemsStore = tx.objectStore("items");
    const blocksStore = tx.objectStore("blocks");
    const examsStore = tx.objectStore("exams");
    const settingsStore = tx.objectStore("settings");
    const examSessionsStore = tx.objectStore("exam_sessions");
    const studySessionsStore = tx.objectStore("study_sessions");
    const lecturesStore = tx.objectStore("lectures");
    const [
      items = [],
      blocks = [],
      exams = [],
      settingsArr = [],
      examSessions = [],
      studySessions = [],
      lectures = []
    ] = await Promise.all([
      prom2(itemsStore.getAll()),
      prom2(blocksStore.getAll()),
      prom2(examsStore.getAll()),
      prom2(settingsStore.getAll()),
      prom2(examSessionsStore.getAll()),
      prom2(studySessionsStore.getAll()),
      prom2(lecturesStore.getAll())
    ]);
    const settings = settingsArr.find((s) => s?.id === "app") || { id: "app", dailyCount: 20, theme: "dark" };
    const additionalSettings = settingsArr.filter((entry) => {
      if (!entry || typeof entry !== "object") return false;
      if (!entry.id || entry.id === "app") return false;
      return true;
    });
    return {
      items,
      blocks,
      exams,
      lectures,
      examSessions,
      studySessions,
      settings,
      settingsEntries: additionalSettings
    };
  }
  async function importJSON(dbDump) {
    try {
      if (!dbDump || typeof dbDump !== "object") {
        throw new Error("File is not a valid Arc export.");
      }
      const db = await openDB();
      const tx = db.transaction(TRANSACTION_STORES, "readwrite");
      const items = tx.objectStore("items");
      const blocks = tx.objectStore("blocks");
      const exams = tx.objectStore("exams");
      const settings = tx.objectStore("settings");
      const examSessions = tx.objectStore("exam_sessions");
      const studySessions = tx.objectStore("study_sessions");
      const lectures = tx.objectStore("lectures");
      await Promise.all([
        prom2(items.clear()),
        prom2(blocks.clear()),
        prom2(exams.clear()),
        prom2(settings.clear()),
        prom2(examSessions.clear()),
        prom2(studySessions.clear()),
        prom2(lectures.clear())
      ]);
      const additionalSettings = Array.isArray(dbDump?.settingsEntries) ? dbDump.settingsEntries.filter((entry) => entry && typeof entry === "object" && entry.id && entry.id !== "app") : [];
      const skipped = {
        settings: 0,
        blocks: 0,
        lectures: 0,
        items: 0,
        exams: 0,
        examSessions: 0,
        studySessions: 0
      };
      if (dbDump?.settings && typeof dbDump.settings === "object") {
        try {
          await prom2(settings.put({ ...dbDump.settings, id: "app" }));
        } catch (err) {
          skipped.settings += 1;
          console.warn("Failed to import primary settings entry", err);
        }
      } else {
        try {
          await prom2(settings.put({ id: "app", dailyCount: 20, theme: "dark" }));
        } catch (err) {
          skipped.settings += 1;
          console.warn("Failed to persist default settings during import", err);
        }
      }
      for (const entry of additionalSettings) {
        try {
          await prom2(settings.put(entry));
        } catch (err) {
          skipped.settings += 1;
          console.warn("Failed to import secondary settings entry", err, entry);
        }
      }
      const lectureRecords = /* @__PURE__ */ new Map();
      const addLectureRecord = (record, { preferExisting = false } = {}) => {
        try {
          if (!record || typeof record !== "object") return;
          const blockId = coerceBlockId(record.blockId ?? record.block ?? null);
          const lectureIdRaw = record.id ?? record.lectureId ?? null;
          if (lectureIdRaw == null) return;
          const lectureIdNumber = Number(lectureIdRaw);
          const lectureId = Number.isFinite(lectureIdNumber) && `${lectureIdNumber}` === `${lectureIdRaw}` ? lectureIdNumber : lectureIdRaw;
          if (blockId == null || lectureId == null) return;
          const key = record.key || lectureKey(blockId, lectureId);
          if (!key) return;
          if (preferExisting && lectureRecords.has(key)) return;
          const payload = deepClone({ ...record, key, blockId, id: lectureId });
          lectureRecords.set(key, payload);
        } catch (err) {
          skipped.lectures += 1;
          console.warn("Skipping lecture during import due to serialization error", err, record);
        }
      };
      if (Array.isArray(dbDump?.lectures)) {
        for (const lecture of dbDump.lectures) {
          addLectureRecord(lecture);
        }
      }
      const migrationTimestamp = Date.now();
      if (Array.isArray(dbDump?.blocks)) {
        for (const b of dbDump.blocks) {
          try {
            if (!b || typeof b !== "object") continue;
            const { lectures: legacyLectures, ...rest } = b;
            const blockRecord = normalizeBlockRecord(rest, b);
            if (!blockRecord) continue;
            await prom2(blocks.put(blockRecord));
            if (!Array.isArray(legacyLectures) || legacyLectures.length === 0) continue;
            const blockId = blockRecord?.blockId;
            if (blockId == null) continue;
            for (const legacy of legacyLectures) {
              try {
                const normalized2 = normalizeLectureRecord(blockId, legacy, migrationTimestamp);
                if (!normalized2) continue;
                if (typeof legacy?.createdAt === "number" && Number.isFinite(legacy.createdAt)) {
                  normalized2.createdAt = legacy.createdAt;
                }
                if (typeof legacy?.updatedAt === "number" && Number.isFinite(legacy.updatedAt)) {
                  normalized2.updatedAt = legacy.updatedAt;
                }
                addLectureRecord(normalized2, { preferExisting: true });
              } catch (err) {
                skipped.lectures += 1;
                console.warn("Skipping legacy lecture while importing block", err, legacy);
              }
            }
          } catch (err) {
            skipped.blocks += 1;
            console.warn("Skipping block during import", err, b);
          }
        }
      }
      if (lectureRecords.size) {
        for (const lecture of lectureRecords.values()) {
          try {
            await prom2(lectures.put(lecture));
          } catch (err) {
            skipped.lectures += 1;
            console.warn("Failed to persist lecture during import", err, lecture);
          }
        }
      }
      if (Array.isArray(dbDump?.items)) {
        for (const it of dbDump.items) {
          try {
            const normalizedItem = normalizeItemRecord(it);
            if (!normalizedItem) continue;
            normalizedItem.tokens = buildTokens(normalizedItem);
            normalizedItem.searchMeta = buildSearchMeta(normalizedItem);
            await prom2(items.put(normalizedItem));
          } catch (err) {
            skipped.items += 1;
            console.warn("Skipping item during import", err, it);
          }
        }
      }
      if (Array.isArray(dbDump?.exams)) {
        for (const ex of dbDump.exams) {
          try {
            const normalizedExam = normalizeExamRecord(ex);
            if (!normalizedExam) continue;
            await prom2(exams.put(normalizedExam));
          } catch (err) {
            skipped.exams += 1;
            console.warn("Skipping exam during import", err, ex);
          }
        }
      }
      if (Array.isArray(dbDump?.examSessions)) {
        for (const session of dbDump.examSessions) {
          try {
            const normalizedSession = normalizeExamSessionRecord(session);
            if (!normalizedSession) continue;
            await prom2(examSessions.put(normalizedSession));
          } catch (err) {
            skipped.examSessions += 1;
            console.warn("Skipping exam session during import", err, session);
          }
        }
      }
      if (Array.isArray(dbDump?.studySessions)) {
        for (const session of dbDump.studySessions) {
          try {
            const normalizedStudySession = normalizeStudySessionRecord(session);
            if (!normalizedStudySession) continue;
            await prom2(studySessions.put(normalizedStudySession));
          } catch (err) {
            skipped.studySessions += 1;
            console.warn("Skipping study session during import", err, session);
          }
        }
      }
      await new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
      if (db && typeof db.close === "function") {
        try {
          db.close();
        } catch (_) {
        }
      }
      const skippedMessages = [];
      const labelMap = {
        settings: ["settings entry", "settings entries"],
        blocks: ["block", "blocks"],
        lectures: ["lecture", "lectures"],
        items: ["item", "items"],
        exams: ["exam", "exams"],
        examSessions: ["exam session", "exam sessions"],
        studySessions: ["study session", "study sessions"]
      };
      for (const [key, [singular, plural]] of Object.entries(labelMap)) {
        const count = skipped[key];
        if (count > 0) {
          skippedMessages.push(`${count} ${count === 1 ? singular : plural}`);
        }
      }
      const message = skippedMessages.length ? `Import complete (skipped ${skippedMessages.join(", ")})` : "Import complete";
      return { ok: true, message };
    } catch (e) {
      console.error("Import failed", e);
      const detail = e?.message ? `Import failed: ${e.message}` : "Import failed";
      return { ok: false, message: detail };
    }
  }
  function escapeCSV(value) {
    return '"' + String(value).replace(/"/g, '""') + '"';
  }
  async function exportAnkiCSV(profile, cohort) {
    const rows = [];
    if (profile === "cloze") {
      const regex = /\{\{c\d+::(.*?)\}\}/g;
      for (const item of cohort) {
        const title = item.name || item.concept || "";
        for (const [key, val] of Object.entries(item)) {
          if (typeof val !== "string") continue;
          let m;
          while (m = regex.exec(val)) {
            const answer = m[1];
            const question = val.replace(regex, "_____");
            rows.push([question, answer, title]);
          }
        }
      }
    } else {
      const qaMap = {
        disease: [
          ["etiology", "Etiology of NAME?"],
          ["pathophys", "Pathophysiology of NAME?"],
          ["clinical", "Clinical features of NAME?"],
          ["diagnosis", "Diagnosis of NAME?"],
          ["treatment", "Treatment of NAME?"],
          ["complications", "Complications of NAME?"]
        ],
        drug: [
          ["class", "Class of NAME?"],
          ["moa", "Mechanism of action of NAME?"],
          ["uses", "Uses of NAME?"],
          ["sideEffects", "Side effects of NAME?"],
          ["contraindications", "Contraindications of NAME?"]
        ],
        concept: [
          ["definition", "Definition of NAME?"],
          ["mechanism", "Mechanism of NAME?"],
          ["clinicalRelevance", "Clinical relevance of NAME?"],
          ["example", "Example of NAME?"]
        ]
      };
      for (const item of cohort) {
        const title = item.name || item.concept || "";
        const mappings = qaMap[item.kind] || [];
        for (const [field, tmpl] of mappings) {
          const val = item[field];
          if (!val) continue;
          const question = tmpl.replace("NAME", title);
          rows.push([question, val, title]);
        }
      }
    }
    const csv = rows.map((r) => r.map(escapeCSV).join(",")).join("\n");
    return new Blob([csv], { type: "text/csv" });
  }
  var TRANSACTION_STORES;
  var init_export = __esm({
    "js/storage/export.js"() {
      init_idb();
      init_search();
      init_lecture_schema();
      init_utils();
      TRANSACTION_STORES = [
        "items",
        "blocks",
        "exams",
        "settings",
        "exam_sessions",
        "study_sessions",
        "lectures"
      ];
    }
  });

  // js/review/constants.js
  var REVIEW_RATINGS, RETIRE_RATING, DEFAULT_REVIEW_STEPS;
  var init_constants = __esm({
    "js/review/constants.js"() {
      REVIEW_RATINGS = ["again", "hard", "good", "easy"];
      RETIRE_RATING = "retire";
      DEFAULT_REVIEW_STEPS = {
        again: 10,
        hard: 60,
        good: 720,
        easy: 2160,
        learningSteps: [10, 60],
        relearningSteps: [10],
        graduatingGood: 1440,
        graduatingEasy: 2880,
        startingEase: 2.5,
        minimumEase: 1.3,
        easeBonus: 0.15,
        easePenalty: 0.2,
        hardEasePenalty: 0.05,
        hardIntervalMultiplier: 1.2,
        easyIntervalBonus: 1.5,
        intervalModifier: 1,
        lapseIntervalMultiplier: 0.5
      };
    }
  });

  // js/review/settings.js
  function toNumber2(value, { min = 0, fallback = 0, allowZero = false } = {}) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    if (num < min) return allowZero && num === 0 ? 0 : fallback;
    return num;
  }
  function parseDurationValue(raw, fallback = null, { allowZero = false } = {}) {
    if (raw == null || raw === "") return fallback;
    if (typeof raw === "number") {
      if (!Number.isFinite(raw)) return fallback;
      if (raw < 0 || !allowZero && raw === 0) return fallback;
      const clamped = allowZero ? Math.max(0, raw) : Math.max(1, raw);
      return Math.round(clamped);
    }
    if (typeof raw === "string") {
      const trimmed = raw.trim();
      if (!trimmed) return fallback;
      const numeric = Number(trimmed);
      if (Number.isFinite(numeric)) {
        if (numeric < 0 || !allowZero && numeric === 0) return fallback;
        const clamped2 = allowZero ? Math.max(0, numeric) : Math.max(1, numeric);
        return Math.round(clamped2);
      }
      const match = trimmed.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z]+)?$/);
      if (!match) return fallback;
      const value = Number(match[1]);
      if (!Number.isFinite(value)) return fallback;
      const unitToken = (match[2] || "minutes").toLowerCase();
      const factor = DURATION_UNIT_FACTORS[unitToken];
      if (!factor) return fallback;
      const minutes = value * factor;
      if (!Number.isFinite(minutes)) return fallback;
      if (minutes < 0 || !allowZero && minutes === 0) return fallback;
      const clamped = allowZero ? Math.max(0, minutes) : Math.max(1, minutes);
      return Math.round(clamped);
    }
    return fallback;
  }
  function parseStepList(raw, fallback = []) {
    const ensurePositive = (value) => {
      const minutes = parseDurationValue(value, null);
      return Number.isFinite(minutes) && minutes > 0 ? minutes : null;
    };
    if (Array.isArray(raw)) {
      const parsed = raw.map(ensurePositive).filter((v) => v != null);
      return parsed.length ? parsed : fallback;
    }
    if (typeof raw === "string") {
      const parsed = raw.split(/[;,\n]+/).map((entry) => ensurePositive(entry)).filter((v) => v != null);
      return parsed.length ? parsed : fallback;
    }
    return fallback;
  }
  function normalizeReviewSteps(raw) {
    const normalized2 = { ...DEFAULT_REVIEW_STEPS };
    if (!raw || typeof raw !== "object") return normalized2;
    for (const key of REVIEW_RATINGS) {
      const value = raw[key];
      const minutes = parseDurationValue(value, null);
      if (Number.isFinite(minutes) && minutes > 0) {
        normalized2[key] = minutes;
      }
    }
    for (const key of STEP_ARRAY_KEYS) {
      const list = parseStepList(raw[key], normalized2[key]);
      normalized2[key] = list.length ? list : normalized2[key];
    }
    for (const key of NUMERIC_KEYS) {
      const defaults = DEFAULT_REVIEW_STEPS[key];
      const fallback = typeof defaults === "number" ? defaults : 0;
      if (DURATION_NUMERIC_KEYS.has(key)) {
        const minutes = parseDurationValue(raw[key], fallback);
        normalized2[key] = Number.isFinite(minutes) && minutes > 0 ? minutes : fallback;
        continue;
      }
      const min = key.endsWith("Ease") ? 0 : 1e-4;
      const allowZero = key === "intervalModifier";
      const value = toNumber2(raw[key], { min, fallback, allowZero });
      if (key === "minimumEase") {
        normalized2[key] = Math.max(0.5, value);
      } else if (key === "startingEase") {
        normalized2[key] = Math.max(normalized2.minimumEase || 1.3, value);
      } else if (key === "intervalModifier" && value <= 0) {
        normalized2[key] = fallback || 1;
      } else {
        normalized2[key] = value;
      }
    }
    if (normalized2.startingEase < normalized2.minimumEase) {
      normalized2.startingEase = normalized2.minimumEase;
    }
    return normalized2;
  }
  var NUMERIC_KEYS, DURATION_NUMERIC_KEYS, STEP_ARRAY_KEYS, DURATION_UNIT_FACTORS;
  var init_settings = __esm({
    "js/review/settings.js"() {
      init_constants();
      NUMERIC_KEYS = [
        "graduatingGood",
        "graduatingEasy",
        "startingEase",
        "minimumEase",
        "easeBonus",
        "easePenalty",
        "hardEasePenalty",
        "hardIntervalMultiplier",
        "easyIntervalBonus",
        "intervalModifier",
        "lapseIntervalMultiplier"
      ];
      DURATION_NUMERIC_KEYS = /* @__PURE__ */ new Set(["graduatingGood", "graduatingEasy"]);
      STEP_ARRAY_KEYS = ["learningSteps", "relearningSteps"];
      DURATION_UNIT_FACTORS = {
        m: 1,
        min: 1,
        mins: 1,
        minute: 1,
        minutes: 1,
        h: 60,
        hr: 60,
        hrs: 60,
        hour: 60,
        hours: 60,
        d: 1440,
        day: 1440,
        days: 1440,
        w: 10080,
        wk: 10080,
        wks: 10080,
        week: 10080,
        weeks: 10080
      };
    }
  });

  // js/review/sr-data.js
  function sanitizeNumber(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num) || num < 0) return fallback;
    return num;
  }
  function defaultSectionState() {
    return {
      streak: 0,
      lastRating: null,
      last: 0,
      due: 0,
      retired: false,
      suspended: false,
      contentDigest: null,
      lectureScope: [],
      interval: 0,
      ease: DEFAULT_REVIEW_STEPS.startingEase,
      lapses: 0,
      learningStepIndex: 0,
      phase: "new",
      pendingInterval: 0
    };
  }
  function normalizeSectionRecord(record) {
    const base = defaultSectionState();
    if (!record || typeof record !== "object") return base;
    if (typeof record.streak === "number" && Number.isFinite(record.streak) && record.streak > 0) {
      base.streak = Math.max(0, Math.round(record.streak));
    }
    if (typeof record.lastRating === "string") {
      const rating = record.lastRating;
      if (REVIEW_RATINGS.includes(rating) || rating === RETIRE_RATING) {
        base.lastRating = rating;
      }
    }
    base.last = sanitizeNumber(record.last, 0);
    base.due = sanitizeNumber(record.due, 0);
    base.retired = Boolean(record.retired);
    if (typeof record.suspended === "boolean") {
      base.suspended = record.suspended;
    }
    if (typeof record.contentDigest === "string" && record.contentDigest) {
      base.contentDigest = record.contentDigest;
    }
    if (Array.isArray(record.lectureScope) && record.lectureScope.length) {
      const normalizedScope = record.lectureScope.map((entry) => typeof entry === "string" ? entry.trim() : "").filter(Boolean);
      base.lectureScope = Array.from(new Set(normalizedScope)).sort();
    }
    if (typeof record.interval === "number" && Number.isFinite(record.interval) && record.interval >= 0) {
      base.interval = Math.max(0, record.interval);
    }
    if (typeof record.ease === "number" && Number.isFinite(record.ease) && record.ease > 0) {
      base.ease = record.ease;
    }
    if (typeof record.lapses === "number" && Number.isFinite(record.lapses) && record.lapses >= 0) {
      base.lapses = Math.max(0, Math.round(record.lapses));
    }
    if (typeof record.learningStepIndex === "number" && Number.isFinite(record.learningStepIndex) && record.learningStepIndex >= 0) {
      base.learningStepIndex = Math.max(0, Math.round(record.learningStepIndex));
    }
    if (typeof record.phase === "string") {
      const phase = record.phase.trim();
      const allowed = ["new", "learning", "review", "relearning", "suspended"];
      if (allowed.includes(phase)) {
        base.phase = phase;
      }
    }
    if (typeof record.pendingInterval === "number" && Number.isFinite(record.pendingInterval) && record.pendingInterval >= 0) {
      base.pendingInterval = Math.max(0, record.pendingInterval);
    }
    return base;
  }
  function normalizeSrRecord(sr) {
    const normalized2 = { version: SR_VERSION, sections: {} };
    if (!sr || typeof sr !== "object") return normalized2;
    const sections = sr.sections && typeof sr.sections === "object" ? sr.sections : {};
    for (const [key, value] of Object.entries(sections)) {
      if (!key) continue;
      normalized2.sections[key] = normalizeSectionRecord(value);
    }
    return normalized2;
  }
  var SR_VERSION;
  var init_sr_data = __esm({
    "js/review/sr-data.js"() {
      init_constants();
      SR_VERSION = 2;
    }
  });

  // js/validators.js
  function escapeHtml(str = "") {
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function legacyFactsToHtml(facts = []) {
    return facts.map((f) => `<p>${escapeHtml(f)}</p>`).join("");
  }
  function cleanItem(item) {
    const extras = Array.isArray(item.extras) ? item.extras : [];
    const normalizedExtras = extras.map((ex) => {
      if (!ex || typeof ex !== "object") return null;
      const id = typeof ex.id === "string" && ex.id ? ex.id : randomId();
      const title = typeof ex.title === "string" ? ex.title : "";
      const body = typeof ex.body === "string" ? ex.body : "";
      if (!title.trim() && !body.trim()) return null;
      return { id, title: title.trim(), body };
    }).filter(Boolean);
    if (!normalizedExtras.length && Array.isArray(item.facts) && item.facts.length) {
      normalizedExtras.push({
        id: randomId(),
        title: "Highlights",
        body: legacyFactsToHtml(item.facts)
      });
    }
    return {
      ...item,
      favorite: !!item.favorite,
      color: item.color || null,
      extras: normalizedExtras,
      facts: normalizedExtras.length ? [] : Array.isArray(item.facts) ? item.facts : [],
      tags: item.tags || [],
      links: item.links || [],
      blocks: item.blocks || [],
      weeks: item.weeks || [],
      lectures: item.lectures || [],
      sr: normalizeSrRecord(item.sr)
    };
  }
  var randomId;
  var init_validators = __esm({
    "js/validators.js"() {
      init_sr_data();
      randomId = () => globalThis.crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2);
    }
  });

  // js/storage/storage.js
  function prom3(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function markItemsUpdated() {
    itemsVersion += 1;
    queryCache.clear();
  }
  async function store(name, mode2 = "readonly") {
    const db = await dbPromise;
    return db.transaction(name, mode2).objectStore(name);
  }
  function canUseStorage2() {
    return typeof localStorage !== "undefined";
  }
  async function writeDataBackup() {
    if (!canUseStorage2()) return;
    try {
      const db = await dbPromise;
      if (!db || typeof db.transaction !== "function") return;
      const snapshot = {};
      for (const name of DATA_BACKUP_STORES) {
        try {
          const tx = db.transaction(name, "readonly");
          const s = tx.objectStore(name);
          const all = await prom3(s.getAll());
          snapshot[name] = Array.isArray(all) ? all : [];
        } catch (err) {
          console.warn(`Failed to snapshot store ${name}`, err);
          snapshot[name] = [];
        }
      }
      snapshot.__timestamp = Date.now();
      localStorage.setItem(DATA_BACKUP_KEY, JSON.stringify(snapshot));
    } catch (err) {
      console.warn("Failed to persist data backup", err);
    }
  }
  function scheduleBackup() {
    if (!canUseStorage2()) return;
    if (backupTimer) clearTimeout(backupTimer);
    backupTimer = setTimeout(() => {
      backupTimer = null;
      writeDataBackup().catch((err) => console.warn("Backup write failed", err));
    }, 1e3);
  }
  async function maybeRestoreFromBackup() {
    if (!canUseStorage2()) return;
    let parsed;
    try {
      const raw = localStorage.getItem(DATA_BACKUP_KEY);
      if (!raw) return;
      parsed = JSON.parse(raw);
    } catch (err) {
      console.warn("Failed to parse saved backup", err);
      return;
    }
    if (!parsed || typeof parsed !== "object") return;
    try {
      const db = await dbPromise;
      if (!db || typeof db.transaction !== "function") return;
      const emptyChecks = await Promise.all(DATA_BACKUP_STORES.map(async (name) => {
        try {
          const tx = db.transaction(name, "readonly");
          const s = tx.objectStore(name);
          const existing = await prom3(s.getAll());
          return !existing || existing.length === 0;
        } catch (err) {
          console.warn(`Failed to inspect store ${name}`, err);
          return false;
        }
      }));
      if (!emptyChecks.every(Boolean)) return;
      for (const name of DATA_BACKUP_STORES) {
        const list = Array.isArray(parsed[name]) ? parsed[name] : [];
        if (!list.length) continue;
        try {
          const tx = db.transaction(name, "readwrite");
          const s = tx.objectStore(name);
          for (const entry of list) {
            await prom3(s.put(entry));
          }
        } catch (err) {
          console.warn(`Failed to restore store ${name}`, err);
        }
      }
    } catch (err) {
      console.warn("Failed to restore data from backup", err);
    }
  }
  async function initDB() {
    if (!dbPromise) dbPromise = openDB();
    await maybeRestoreFromBackup();
    const s = await store("settings", "readwrite");
    const existing = await prom3(s.get("app"));
    if (!existing) {
      await prom3(s.put(DEFAULT_APP_SETTINGS));
    }
    scheduleBackup();
  }
  async function getSettings() {
    const s = await store("settings");
    const settings = await prom3(s.get("app"));
    if (!settings) return { ...DEFAULT_APP_SETTINGS };
    const merged = { ...DEFAULT_APP_SETTINGS, ...settings };
    merged.reviewSteps = normalizeReviewSteps(settings.reviewSteps || merged.reviewSteps);
    merged.plannerDefaults = normalizePlannerDefaults(settings.plannerDefaults || merged.plannerDefaults);
    return merged;
  }
  async function saveSettings(patch) {
    const s = await store("settings", "readwrite");
    const current = await prom3(s.get("app")) || { ...DEFAULT_APP_SETTINGS };
    const mergedSteps = normalizeReviewSteps({
      ...DEFAULT_APP_SETTINGS.reviewSteps,
      ...current.reviewSteps || {},
      ...patch.reviewSteps || {}
    });
    const basePlanner = current.plannerDefaults || DEFAULT_APP_SETTINGS.plannerDefaults;
    const patchPlanner = patch?.plannerDefaults || {};
    const mergedPlannerDefaults = normalizePlannerDefaults({
      anchorOffsets: {
        ...DEFAULT_APP_SETTINGS.plannerDefaults?.anchorOffsets || {},
        ...basePlanner?.anchorOffsets || {},
        ...patchPlanner.anchorOffsets || {}
      },
      passes: Array.isArray(patchPlanner.passes) && patchPlanner.passes.length ? patchPlanner.passes : basePlanner?.passes || DEFAULT_APP_SETTINGS.plannerDefaults?.passes,
      passColors: Array.isArray(patchPlanner.passColors) && patchPlanner.passColors.length ? patchPlanner.passColors : basePlanner?.passColors || DEFAULT_APP_SETTINGS.plannerDefaults?.passColors
    });
    const next = {
      ...current,
      ...patch,
      id: "app",
      reviewSteps: mergedSteps,
      plannerDefaults: mergedPlannerDefaults
    };
    await prom3(s.put(next));
    scheduleBackup();
  }
  async function listBlocks() {
    try {
      const lecturePromise = listAllLectures();
      const blockStore = await store("blocks");
      const all = await prom3(blockStore.getAll());
      const lectures = await lecturePromise;
      const blocks = (all || []).map((block) => {
        if (!block || typeof block !== "object") return block;
        const { lectures: _ignored, ...rest } = block;
        return { ...rest };
      }).sort((a, b) => {
        const ao = a.order ?? a.createdAt;
        const bo = b.order ?? b.createdAt;
        return bo - ao;
      });
      const lectureIndex = {};
      for (const lecture of lectures || []) {
        if (!lecture || lecture.blockId == null || lecture.id == null) continue;
        const blockId = lecture.blockId;
        if (!lectureIndex[blockId]) lectureIndex[blockId] = {};
        lectureIndex[blockId][lecture.id] = { ...lecture };
      }
      return { blocks, lectureIndex };
    } catch (err) {
      console.warn("listBlocks failed", err);
      return { blocks: [], lectureIndex: {} };
    }
  }
  function slugifyBlockTitle(title) {
    if (typeof title !== "string" || !title.trim()) return "block";
    const base = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").slice(0, 40);
    return base || "block";
  }
  async function generateBlockId(storeRef, title) {
    const base = slugifyBlockTitle(title);
    let candidate = base;
    let attempt = 1;
    while (true) {
      const existing = candidate ? await prom3(storeRef.get(candidate)) : null;
      if (!existing && candidate) {
        return candidate;
      }
      attempt += 1;
      candidate = `${base}-${attempt}`;
      if (attempt > 1e3) {
        return `block-${Date.now()}`;
      }
    }
  }
  function normalizeDateInput(value) {
    if (value == null) return null;
    if (value instanceof Date) {
      if (Number.isNaN(value.getTime())) return null;
      return value.toISOString().slice(0, 10);
    }
    if (typeof value === "number") {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return null;
      return date.toISOString().slice(0, 10);
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (!trimmed) return null;
      const date = new Date(trimmed);
      if (Number.isNaN(date.getTime())) return null;
      return date.toISOString().slice(0, 10);
    }
    return null;
  }
  async function upsertBlock(def) {
    const title = typeof def?.title === "string" ? def.title : "";
    let blockId = typeof def?.blockId === "string" && def.blockId.trim() ? def.blockId.trim() : "";
    const readStore = await store("blocks");
    if (!blockId) {
      blockId = await generateBlockId(readStore, title || "block");
    }
    const existing = await prom3(readStore.get(blockId));
    const existingLectures = await listLecturesByBlock(blockId);
    const now = Date.now();
    const incomingLectures = Array.isArray(def.lectures) ? def.lectures.map((lecture) => ({
      ...lecture,
      blockId
    })) : existingLectures.map((lecture) => ({
      blockId: lecture.blockId,
      id: lecture.id,
      name: lecture.name,
      week: lecture.week,
      tags: Array.isArray(lecture.tags) ? lecture.tags : []
    }));
    const removedLectureIds = [];
    let itemsTouched = false;
    let prunedLectures = incomingLectures;
    if (existing && typeof def.weeks === "number" && def.weeks < existing.weeks) {
      const maxWeek = def.weeks;
      prunedLectures = incomingLectures.filter((lecture) => {
        const week = lecture?.week;
        const keep = week == null || week <= maxWeek;
        if (!keep && lecture?.id != null) {
          removedLectureIds.push(lecture.id);
        }
        return keep;
      });
      const i = await store("items", "readwrite");
      const all = await prom3(i.getAll());
      for (const it of all) {
        let changed = false;
        if (it.lectures) {
          const before = it.lectures.length;
          it.lectures = it.lectures.filter((l) => !(l.blockId === blockId && l.week > maxWeek));
          if (it.lectures.length !== before) changed = true;
        }
        if (it.weeks) {
          const beforeW = it.weeks.length;
          it.weeks = it.weeks.filter((w) => w <= maxWeek);
          if (it.weeks.length !== beforeW) changed = true;
        }
        if (changed) {
          it.tokens = buildTokens(it);
          it.searchMeta = buildSearchMeta(it);
          await prom3(i.put(it));
          itemsTouched = true;
        }
      }
    }
    const next = {
      ...def,
      blockId,
      color: def.color || existing?.color || null,
      order: def.order || existing?.order || now,
      createdAt: existing?.createdAt || now,
      updatedAt: now,
      weeks: typeof def.weeks === "number" ? def.weeks : existing?.weeks,
      startDate: def.startDate !== void 0 ? normalizeDateInput(def.startDate) : existing?.startDate ? normalizeDateInput(existing.startDate) : null,
      endDate: def.endDate !== void 0 ? normalizeDateInput(def.endDate) : existing?.endDate ? normalizeDateInput(existing.endDate) : null
    };
    delete next.lectures;
    const writeStore = await store("blocks", "readwrite");
    await prom3(writeStore.put(next));
    const incomingKeySet = new Set(
      prunedLectures.filter((lecture) => lecture?.id != null).map((lecture) => lectureKey(blockId, lecture.id))
    );
    for (const lecture of existingLectures) {
      const key = lecture?.key || lectureKey(lecture.blockId, lecture.id);
      if (!incomingKeySet.has(key) && lecture?.id != null) {
        removedLectureIds.push(lecture.id);
      }
    }
    for (const lecture of prunedLectures) {
      if (lecture?.id == null) continue;
      await saveLecture({
        blockId,
        id: lecture.id,
        name: lecture.name,
        week: lecture.week,
        tags: Array.isArray(lecture.tags) ? lecture.tags : void 0,
        passes: Array.isArray(lecture.passes) ? lecture.passes : void 0,
        passPlan: lecture.passPlan,
        status: lecture.status,
        nextDueAt: lecture.nextDueAt
      });
    }
    const uniqueRemoved = Array.from(new Set(removedLectureIds.filter((id) => id != null)));
    for (const lectureId of uniqueRemoved) {
      await deleteLectureRecord(blockId, lectureId);
    }
    if (uniqueRemoved.length) {
      const removed = await removeLectureReferencesFromItems(blockId, uniqueRemoved);
      itemsTouched = itemsTouched || removed;
    }
    if (itemsTouched) {
      markItemsUpdated();
    }
    scheduleBackup();
  }
  async function removeLectureReferencesFromItems(blockId, lectureIds) {
    if (!lectureIds.length) return false;
    const i = await store("items", "readwrite");
    const all = await prom3(i.getAll());
    let touched = false;
    for (const it of all) {
      const before = it.lectures?.length || 0;
      if (!before) continue;
      it.lectures = it.lectures.filter((l) => !(l.blockId === blockId && lectureIds.includes(l.id)));
      if (it.lectures.length !== before) {
        it.blocks = it.blocks?.filter((bid) => bid !== blockId || it.lectures.some((l) => l.blockId === bid));
        const validWeeks = new Set((it.lectures || []).map((l) => l.week));
        it.weeks = Array.from(validWeeks);
        it.tokens = buildTokens(it);
        it.searchMeta = buildSearchMeta(it);
        await prom3(i.put(it));
        touched = true;
      }
    }
    return touched;
  }
  async function deleteBlock(blockId) {
    const b = await store("blocks", "readwrite");
    await prom3(b.delete(blockId));
    await removeLecturesForBlock(blockId);
    const i = await store("items", "readwrite");
    const all = await prom3(i.getAll());
    let itemsTouched = false;
    for (const it of all) {
      const beforeBlocks = it.blocks?.length || 0;
      const beforeLects = it.lectures?.length || 0;
      if (beforeBlocks || beforeLects) {
        if (it.blocks) it.blocks = it.blocks.filter((bId) => bId !== blockId);
        if (it.lectures) it.lectures = it.lectures.filter((l) => l.blockId !== blockId);
        if (it.weeks) {
          const validWeeks = new Set((it.lectures || []).map((l) => l.week));
          it.weeks = Array.from(validWeeks);
        }
        if ((it.blocks?.length || 0) !== beforeBlocks || (it.lectures?.length || 0) !== beforeLects) {
          it.tokens = buildTokens(it);
          it.searchMeta = buildSearchMeta(it);
          await prom3(i.put(it));
          itemsTouched = true;
        }
      }
    }
    if (itemsTouched) {
      markItemsUpdated();
    }
    scheduleBackup();
  }
  async function deleteLecture(blockId, lectureId) {
    await deleteLectureRecord(blockId, lectureId);
    const touched = await removeLectureReferencesFromItems(blockId, [lectureId]);
    if (touched) {
      markItemsUpdated();
    }
    scheduleBackup();
  }
  async function listItemsByKind(kind) {
    const i = await store("items");
    const idx = i.index("by_kind");
    return await prom3(idx.getAll(kind));
  }
  function titleOf(item) {
    return item.name || item.concept || "";
  }
  function normalizeSort(sort) {
    const raw = typeof sort === "string" ? sort.toLowerCase() : "";
    switch (raw) {
      case "updated-asc":
        return { mode: "updated", direction: "asc" };
      case "updated-desc":
      case "updated":
        return { mode: "updated", direction: "desc" };
      case "created-asc":
        return { mode: "created", direction: "asc" };
      case "created-desc":
      case "created":
        return { mode: "created", direction: "desc" };
      case "lecture-asc":
        return { mode: "lecture", direction: "asc" };
      case "lecture-desc":
      case "lecture":
        return { mode: "lecture", direction: "desc" };
      case "name-desc":
        return { mode: "name", direction: "desc" };
      case "name":
      case "name-asc":
        return { mode: "name", direction: "asc" };
      default:
        return { ...DEFAULT_SORT };
    }
  }
  function normalizeFilter(filter = {}) {
    const rawTypes = Array.isArray(filter.types) ? filter.types.filter((t) => typeof t === "string" && t) : [];
    const types = rawTypes.length ? Array.from(new Set(rawTypes)) : DEFAULT_KINDS;
    const block = typeof filter.block === "string" ? filter.block : "";
    const weekRaw = filter.week;
    let week = null;
    if (typeof weekRaw === "number" && !Number.isNaN(weekRaw)) {
      week = weekRaw;
    } else if (typeof weekRaw === "string" && weekRaw.trim()) {
      const parsed = Number(weekRaw);
      if (!Number.isNaN(parsed)) week = parsed;
    }
    const onlyFav = Boolean(filter.onlyFav);
    const query = typeof filter.query === "string" ? filter.query.trim() : "";
    const normalizedQuery = query.toLowerCase();
    const tokens = query ? tokenize(query) : [];
    return {
      types,
      block,
      week,
      onlyFav,
      tokens: tokens.length ? tokens : null,
      query: normalizedQuery,
      sort: normalizeSort(filter.sort)
    };
  }
  async function getKeySet(storeRef, indexName, value) {
    if (value === null || value === void 0 || value === "" || value !== value) return null;
    if (typeof storeRef.index !== "function") return null;
    const idx = storeRef.index(indexName);
    if (!idx || typeof idx.getAllKeys !== "function") return null;
    const keys = await prom3(idx.getAllKeys(value));
    return new Set(keys);
  }
  async function keysForKinds(storeRef, kinds) {
    const idx = typeof storeRef.index === "function" ? storeRef.index("by_kind") : null;
    const seen = /* @__PURE__ */ new Set();
    const allKeys = [];
    for (const kind of kinds) {
      if (!kind) continue;
      let keys = [];
      if (idx && typeof idx.getAllKeys === "function") {
        keys = await prom3(idx.getAllKeys(kind));
      } else if (idx && typeof idx.getAll === "function") {
        const values = await prom3(idx.getAll(kind));
        keys = values.map((v) => v?.id).filter(Boolean);
      }
      for (const key of keys) {
        if (!seen.has(key)) {
          seen.add(key);
          allKeys.push(key);
        }
      }
    }
    return allKeys;
  }
  async function executeItemQuery(filter, options = {}) {
    const normalized2 = options.normalized ? filter : normalizeFilter(filter);
    const itemsStore = await store("items");
    const blockSet = normalized2.block && normalized2.block !== "__unlabeled" ? await getKeySet(itemsStore, "by_blocks", normalized2.block) : null;
    const weekSet = normalized2.week != null ? await getKeySet(itemsStore, "by_weeks", normalized2.week) : null;
    const favoriteSet = normalized2.onlyFav ? await getKeySet(itemsStore, "by_favorite", true) : null;
    const baseKeys = await keysForKinds(itemsStore, normalized2.types);
    const filteredKeys = baseKeys.filter((id) => {
      if (!id) return false;
      if (blockSet && !blockSet.has(id)) return false;
      if (weekSet && !weekSet.has(id)) return false;
      if (favoriteSet && !favoriteSet.has(id)) return false;
      return true;
    });
    const results = [];
    for (let i = 0; i < filteredKeys.length; i += RESULT_BATCH_SIZE) {
      const chunk = filteredKeys.slice(i, i + RESULT_BATCH_SIZE);
      const fetched = await Promise.all(chunk.map((id) => prom3(itemsStore.get(id))));
      for (const item of fetched) {
        if (!item) continue;
        if (normalized2.block === "__unlabeled" && Array.isArray(item.blocks) && item.blocks.length) continue;
        if (normalized2.tokens) {
          const tokenField = item.tokens || "";
          const metaField = item.searchMeta || buildSearchMeta(item);
          const matches = normalized2.tokens.every((tok) => tokenField.includes(tok) || metaField.includes(tok));
          if (!matches) continue;
        }
        results.push(item);
      }
    }
    let lectureDateIndex = null;
    if (normalized2.sort.mode === "lecture") {
      const lectures = await listAllLectures();
      lectureDateIndex = /* @__PURE__ */ new Map();
      (lectures || []).forEach((lecture) => {
        if (!lecture || lecture.blockId == null || lecture.id == null) return;
        const key = lectureKey(lecture.blockId, lecture.id);
        const created = typeof lecture.createdAt === "number" ? lecture.createdAt : 0;
        lectureDateIndex.set(key, created);
      });
    }
    const lectureSortCache = /* @__PURE__ */ new Map();
    function lectureTimestamp(item) {
      if (!lectureDateIndex) return 0;
      const cacheKey = item?.id ?? null;
      if (cacheKey != null && lectureSortCache.has(cacheKey)) {
        return lectureSortCache.get(cacheKey);
      }
      const links = Array.isArray(item?.lectures) ? item.lectures : [];
      let latest = 0;
      for (const link of links) {
        if (!link || link.blockId == null || link.id == null) continue;
        const key = lectureKey(link.blockId, link.id);
        const created = lectureDateIndex.get(key);
        if (typeof created === "number" && created > latest) {
          latest = created;
        }
      }
      if (cacheKey != null) lectureSortCache.set(cacheKey, latest);
      return latest;
    }
    const queryString = typeof normalized2.query === "string" ? normalized2.query : "";
    const hasQueryString = queryString.length > 0;
    function nameMatchScore(item) {
      if (!hasQueryString) return 0;
      const title = titleOf(item).toLowerCase();
      if (!title) return 0;
      if (title.startsWith(queryString)) return 2;
      if (title.includes(queryString)) return 1;
      return 0;
    }
    results.sort((a, b) => {
      if (hasQueryString) {
        const aScore = nameMatchScore(a);
        const bScore = nameMatchScore(b);
        if (aScore !== bScore) {
          return bScore - aScore;
        }
      }
      let cmp = 0;
      switch (normalized2.sort.mode) {
        case "name":
          cmp = titleOf(a).localeCompare(titleOf(b));
          break;
        case "created": {
          const av = typeof a.createdAt === "number" ? a.createdAt : 0;
          const bv = typeof b.createdAt === "number" ? b.createdAt : 0;
          cmp = av - bv;
          break;
        }
        case "lecture":
          cmp = lectureTimestamp(a) - lectureTimestamp(b);
          break;
        case "updated":
        default: {
          const av = typeof a.updatedAt === "number" ? a.updatedAt : 0;
          const bv = typeof b.updatedAt === "number" ? b.updatedAt : 0;
          cmp = av - bv;
          break;
        }
      }
      if (cmp === 0 && normalized2.sort.mode !== "name") {
        cmp = titleOf(a).localeCompare(titleOf(b));
      }
      return normalized2.sort.direction === "asc" ? cmp : -cmp;
    });
    return results;
  }
  function findItemsByFilter(filter) {
    let memo;
    const run = () => {
      if (!memo) {
        const normalized2 = normalizeFilter(filter);
        const cacheKey = JSON.stringify(normalized2);
        const cached = queryCache.get(cacheKey);
        if (cached && cached.version === itemsVersion) {
          memo = cached.promise;
        } else {
          memo = executeItemQuery(normalized2, { normalized: true });
          queryCache.set(cacheKey, { version: itemsVersion, promise: memo });
          if (queryCache.size > MAX_QUERY_CACHE) {
            const oldestKey = queryCache.keys().next().value;
            if (oldestKey) queryCache.delete(oldestKey);
          }
        }
      }
      return memo;
    };
    return {
      async toArray() {
        const items = await run();
        return items.slice();
      },
      async *[Symbol.asyncIterator]() {
        const items = await run();
        for (let i = 0; i < items.length; i += RESULT_BATCH_SIZE) {
          yield items.slice(i, i + RESULT_BATCH_SIZE);
        }
      }
    };
  }
  async function upsertItem(item) {
    const i = await store("items", "readwrite");
    const existing = await prom3(i.get(item.id));
    const now = Date.now();
    const next = cleanItem({
      ...item,
      createdAt: existing?.createdAt || now,
      updatedAt: now
    });
    next.tokens = buildTokens(next);
    next.searchMeta = buildSearchMeta(next);
    for (const link of next.links) {
      const other = await prom3(i.get(link.id));
      if (other) {
        other.links = other.links || [];
        if (!other.links.find((l) => l.id === next.id)) {
          other.links.push({ id: next.id, type: link.type });
          other.tokens = buildTokens(other);
          other.searchMeta = buildSearchMeta(other);
          await prom3(i.put(other));
        }
      }
    }
    await prom3(i.put(next));
    markItemsUpdated();
    scheduleBackup();
  }
  async function deleteItem(id) {
    const i = await store("items", "readwrite");
    const all = await prom3(i.getAll());
    for (const it of all) {
      if (it.links?.some((l) => l.id === id)) {
        it.links = it.links.filter((l) => l.id !== id);
        it.tokens = buildTokens(it);
        it.searchMeta = buildSearchMeta(it);
        await prom3(i.put(it));
      }
    }
    await prom3(i.delete(id));
    markItemsUpdated();
    scheduleBackup();
  }
  async function listExams() {
    const e = await store("exams");
    return await prom3(e.getAll());
  }
  async function upsertExam(exam) {
    const e = await store("exams", "readwrite");
    const existing = await prom3(e.get(exam.id));
    const now = Date.now();
    const next = {
      ...exam,
      createdAt: existing?.createdAt || now,
      updatedAt: now,
      results: exam.results || existing?.results || []
    };
    await prom3(e.put(next));
    scheduleBackup();
  }
  async function deleteExam(id) {
    const e = await store("exams", "readwrite");
    await prom3(e.delete(id));
    scheduleBackup();
  }
  async function listExamSessions() {
    const s = await store("exam_sessions");
    return await prom3(s.getAll());
  }
  async function loadExamSession(examId) {
    const s = await store("exam_sessions");
    return await prom3(s.get(examId));
  }
  async function saveExamSessionProgress(progress) {
    const s = await store("exam_sessions", "readwrite");
    const now = Date.now();
    await prom3(s.put({ ...progress, updatedAt: now }));
    scheduleBackup();
  }
  async function deleteExamSessionProgress(examId) {
    const s = await store("exam_sessions", "readwrite");
    await prom3(s.delete(examId));
    scheduleBackup();
  }
  async function listStudySessions() {
    try {
      const s = await store("study_sessions");
      const list = await prom3(s.getAll());
      return Array.isArray(list) ? list : [];
    } catch (err) {
      console.warn("Failed to list study sessions", err);
      return [];
    }
  }
  async function saveStudySessionRecord(record) {
    if (!record || !record.mode) throw new Error("Study session record requires a mode");
    const s = await store("study_sessions", "readwrite");
    const now = Date.now();
    await prom3(s.put({ ...record, updatedAt: now }));
    scheduleBackup();
  }
  async function deleteStudySessionRecord(mode2) {
    if (!mode2) return;
    const s = await store("study_sessions", "readwrite");
    await prom3(s.delete(mode2));
    scheduleBackup();
  }
  async function clearAllStudySessionRecords() {
    const s = await store("study_sessions", "readwrite");
    await prom3(s.clear());
    scheduleBackup();
  }
  async function importJSON2(...args) {
    const result = await importJSON(...args);
    markItemsUpdated();
    return result;
  }
  var dbPromise, itemsVersion, queryCache, MAX_QUERY_CACHE, DEFAULT_KINDS, RESULT_BATCH_SIZE, DATA_BACKUP_KEY, DATA_BACKUP_STORES, DEFAULT_APP_SETTINGS, backupTimer, DEFAULT_SORT;
  var init_storage = __esm({
    "js/storage/storage.js"() {
      init_idb();
      init_lectures();
      init_lectures();
      init_export();
      init_constants();
      init_settings();
      init_scheduler();
      init_search();
      init_validators();
      itemsVersion = 0;
      queryCache = /* @__PURE__ */ new Map();
      MAX_QUERY_CACHE = 20;
      DEFAULT_KINDS = ["disease", "drug", "concept"];
      RESULT_BATCH_SIZE = 50;
      DATA_BACKUP_KEY = "arc-backup-snapshot";
      DATA_BACKUP_STORES = ["items", "blocks", "exams", "settings", "exam_sessions", "study_sessions", "lectures"];
      DEFAULT_APP_SETTINGS = {
        id: "app",
        dailyCount: 20,
        theme: "dark",
        reviewSteps: { ...DEFAULT_REVIEW_STEPS },
        plannerDefaults: normalizePlannerDefaults(DEFAULT_PLANNER_DEFAULTS)
      };
      backupTimer = null;
      DEFAULT_SORT = { mode: "updated", direction: "desc" };
    }
  });

  // js/storage/block-catalog.js
  function cloneBlock(block) {
    if (!block || typeof block !== "object") return block;
    return { ...block };
  }
  function cloneLecture(lecture) {
    if (!lecture || typeof lecture !== "object") return lecture;
    return { ...lecture };
  }
  function cloneLectureIndex(index) {
    const copy = {};
    for (const [blockId, lectures] of Object.entries(index || {})) {
      const next = {};
      for (const [lectureId, lecture] of Object.entries(lectures || {})) {
        next[lectureId] = cloneLecture(lecture);
      }
      copy[blockId] = next;
    }
    return copy;
  }
  function sortLectures(a, b) {
    const aw = a?.week ?? 0;
    const bw = b?.week ?? 0;
    if (aw !== bw) return aw - bw;
    const an = (a?.name || "").toLowerCase();
    const bn = (b?.name || "").toLowerCase();
    if (an !== bn) return an.localeCompare(bn);
    const ai = a?.id ?? 0;
    const bi = b?.id ?? 0;
    return ai - bi;
  }
  function buildLectureLists(index) {
    const map = {};
    for (const [blockId, lectures] of Object.entries(index || {})) {
      const list = Object.values(lectures || {}).map(cloneLecture);
      list.sort(sortLectures);
      map[blockId] = list;
    }
    return map;
  }
  function snapshotCatalog(source) {
    return {
      blocks: (source?.blocks || []).map(cloneBlock),
      lectureIndex: cloneLectureIndex(source?.lectureIndex || {}),
      lectureLists: Object.fromEntries(
        Object.entries(source?.lectureLists || {}).map(([blockId, list]) => [
          blockId,
          list.map(cloneLecture)
        ])
      )
    };
  }
  async function loadBlockCatalog(options = {}) {
    if (!pending || options.force) {
      pending = (async () => {
        const { blocks, lectureIndex } = await listBlocks();
        const normalizedBlocks = (blocks || []).map(cloneBlock);
        const normalizedIndex = cloneLectureIndex(lectureIndex || {});
        const lectureLists = buildLectureLists(normalizedIndex);
        cache2 = { blocks: normalizedBlocks, lectureIndex: normalizedIndex, lectureLists };
        return snapshotCatalog(cache2);
      })();
    }
    return pending;
  }
  function invalidateBlockCatalog() {
    cache2 = null;
    pending = null;
  }
  var cache2, pending;
  var init_block_catalog = __esm({
    "js/storage/block-catalog.js"() {
      init_storage();
      cache2 = null;
      pending = null;
    }
  });

  // js/ui/components/confirm.js
  function confirmModal(message) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.className = "modal";
      const box = document.createElement("div");
      box.className = "card";
      const msg = document.createElement("p");
      msg.textContent = message;
      box.appendChild(msg);
      const actions = document.createElement("div");
      actions.className = "row";
      const yes = document.createElement("button");
      yes.className = "btn";
      yes.textContent = "Yes";
      yes.addEventListener("click", () => {
        document.body.removeChild(overlay);
        resolve(true);
      });
      const no = document.createElement("button");
      no.className = "btn";
      no.textContent = "No";
      no.addEventListener("click", () => {
        document.body.removeChild(overlay);
        resolve(false);
      });
      actions.appendChild(yes);
      actions.appendChild(no);
      box.appendChild(actions);
      overlay.appendChild(box);
      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) {
          document.body.removeChild(overlay);
          resolve(false);
        }
      });
      document.body.appendChild(overlay);
      yes.focus();
    });
  }
  var init_confirm = __esm({
    "js/ui/components/confirm.js"() {
    }
  });

  // js/lectures/actions.js
  var LECTURE_PASS_ACTIONS;
  var init_actions = __esm({
    "js/lectures/actions.js"() {
      LECTURE_PASS_ACTIONS = [
        "Notes",
        "Read",
        "Tape",
        "Quiz",
        "Flashcards",
        "Summarize",
        "Review",
        "Active Recall",
        "Anki",
        "Practice Questions",
        "Teach-Back",
        "Whiteboard",
        "Mind Map",
        "Case Review",
        "Group Study",
        "Audio Review",
        "Lecture Rewatch",
        "Cheat Sheet",
        "Sketch/Diagram",
        "Blocks"
      ];
    }
  });

  // js/ui/components/pass-colors.js
  function normalizePalette(colors = []) {
    if (!Array.isArray(colors) || !colors.length) {
      return DEFAULT_PASS_COLORS.slice();
    }
    return colors.map((color, index) => {
      if (typeof color === "string") {
        const trimmed = color.trim();
        if (trimmed) return trimmed;
      }
      return DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
    });
  }
  function setPassColorPalette(colors) {
    palette = normalizePalette(colors);
  }
  function passColorForOrder(order = 1) {
    const list = palette.length ? palette : DEFAULT_PASS_COLORS;
    if (!Number.isFinite(order)) {
      return list[0] || DEFAULT_PASS_COLORS[0];
    }
    const index = Math.max(0, Math.floor(order) - 1) % list.length;
    return list[index];
  }
  var palette;
  var init_pass_colors = __esm({
    "js/ui/components/pass-colors.js"() {
      init_scheduler();
      palette = DEFAULT_PASS_COLORS.slice();
    }
  });

  // js/ui/settings.js
  var settings_exports = {};
  __export(settings_exports, {
    renderSettings: () => renderSettings
  });
  function createEmptyState() {
    const empty = document.createElement("div");
    empty.className = "settings-empty-blocks";
    empty.textContent = "No blocks yet. Use \u201CAdd block\u201D to create one.";
    return empty;
  }
  function formatOffset(minutes) {
    if (!Number.isFinite(minutes)) return "0m";
    const abs = Math.abs(minutes);
    if (abs < 60) return `${Math.round(minutes)}m`;
    const hours = minutes / 60;
    if (Math.abs(hours) < 24) return `${Math.round(hours)}h`;
    const days = minutes / (60 * 24);
    if (Math.abs(days) < 7) return `${Math.round(days)}d`;
    const weeks = minutes / (60 * 24 * 7);
    if (Math.abs(weeks) < 4) return `${Math.round(weeks)}w`;
    const months = minutes / (60 * 24 * 30);
    return `${Math.round(months)}mo`;
  }
  function normalizeOffsetUnit(id) {
    const fallback = OFFSET_UNITS[2];
    if (typeof id !== "string") return fallback.id;
    const match = OFFSET_UNITS.find((option) => option.id === id);
    return match ? match.id : fallback.id;
  }
  function splitOffsetMinutes(minutes) {
    const value = Number.isFinite(minutes) ? Math.max(0, Math.round(minutes)) : 0;
    if (value === 0) {
      return { value: 0, unit: "days" };
    }
    const preferred = [...OFFSET_UNITS].reverse().find((option) => value % option.minutes === 0);
    if (preferred) {
      return { value: Math.round(value / preferred.minutes), unit: preferred.id };
    }
    if (value < 60) {
      return { value, unit: "minutes" };
    }
    if (value < 60 * 24) {
      return { value: Math.round(value / 60), unit: "hours" };
    }
    return { value: Math.round(value / (60 * 24)), unit: "days" };
  }
  function combineOffsetValueUnit(value, unitId) {
    const normalizedUnit = normalizeOffsetUnit(unitId);
    const option = OFFSET_UNITS.find((entry) => entry.id === normalizedUnit) || OFFSET_UNITS[2];
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) {
      return 0;
    }
    return Math.max(0, Math.round(numeric * option.minutes));
  }
  function defaultActionForIndex(index) {
    if (!Array.isArray(LECTURE_PASS_ACTIONS) || !LECTURE_PASS_ACTIONS.length) return "";
    const normalized2 = index % LECTURE_PASS_ACTIONS.length;
    return LECTURE_PASS_ACTIONS[Math.max(0, normalized2)];
  }
  function baseSchedule(plan) {
    if (plan && Array.isArray(plan.schedule)) {
      return plan.schedule;
    }
    return DEFAULT_PASS_PLAN.schedule;
  }
  function computeDefaultGap(schedule2) {
    if (!Array.isArray(schedule2) || schedule2.length < 2) return DAY_MINUTES2;
    const deltas = [];
    for (let i = 1; i < schedule2.length; i += 1) {
      const prev = Number(schedule2[i - 1]?.offsetMinutes);
      const current = Number(schedule2[i]?.offsetMinutes);
      if (Number.isFinite(prev) && Number.isFinite(current)) {
        const delta = current - prev;
        if (delta > 0) deltas.push(delta);
      }
    }
    return deltas.length ? deltas[deltas.length - 1] : DAY_MINUTES2;
  }
  function fallbackAnchor(index) {
    if (index === 0) return "today";
    if (index === 1) return "tomorrow";
    return "upcoming";
  }
  function buildScheduleTemplate(plan, count) {
    const template = baseSchedule(plan);
    const numericCount = Number(count);
    const safeCount = Math.max(0, Number.isFinite(numericCount) ? Math.round(numericCount) : 0);
    const defaultGap = computeDefaultGap(template);
    const schedule2 = [];
    for (let i = 0; i < safeCount; i += 1) {
      const source = template[i] || {};
      const previous = schedule2[i - 1] || null;
      const order = i + 1;
      const offset = Number.isFinite(source.offsetMinutes) ? source.offsetMinutes : previous ? previous.offsetMinutes + defaultGap : i === 0 ? 0 : defaultGap * i;
      const anchor = typeof source.anchor === "string" && source.anchor.trim() ? source.anchor.trim() : previous?.anchor || fallbackAnchor(i);
      const label = typeof source.label === "string" && source.label.trim() ? source.label.trim() : `Pass ${order}`;
      const action = typeof source.action === "string" && source.action.trim() ? source.action.trim() : defaultActionForIndex(i);
      schedule2.push({
        order,
        offsetMinutes: offset,
        anchor,
        label,
        action
      });
    }
    return schedule2;
  }
  function adjustPassConfigs(current, count, plan) {
    const template = buildScheduleTemplate(plan || { schedule: current }, count);
    const byOrder = /* @__PURE__ */ new Map();
    (Array.isArray(current) ? current : []).forEach((entry) => {
      const order = Number(entry?.order);
      if (Number.isFinite(order) && !byOrder.has(order)) {
        byOrder.set(order, entry);
      }
    });
    return template.map((step, index) => {
      const existing = byOrder.get(step.order) || current[index] || {};
      const action = typeof existing?.action === "string" && existing.action.trim() ? existing.action.trim() : step.action;
      const offsetMinutes = Number.isFinite(existing?.offsetMinutes) ? Math.max(0, Math.round(existing.offsetMinutes)) : step.offsetMinutes;
      const anchor = typeof existing?.anchor === "string" && existing.anchor.trim() ? existing.anchor.trim() : step.anchor;
      const label = typeof existing?.label === "string" && existing.label.trim() ? existing.label.trim() : step.label;
      return { ...step, action, offsetMinutes, anchor, label };
    });
  }
  function clampPassCount(value) {
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) return 0;
    return Math.min(MAX_PASS_COUNT, Math.max(0, Math.round(parsed)));
  }
  function buildPassPlanPayload(passConfigs, existingPlan) {
    const planId = existingPlan && typeof existingPlan.id === "string" && existingPlan.id.trim() ? existingPlan.id.trim() : "custom";
    return {
      id: planId,
      schedule: passConfigs.map((config, index) => {
        const order = index + 1;
        const label = typeof config.label === "string" && config.label.trim() ? config.label.trim() : `Pass ${order}`;
        const offset = Number.isFinite(config.offsetMinutes) ? Math.max(0, Math.round(config.offsetMinutes)) : index === 0 ? 0 : (passConfigs[index - 1]?.offsetMinutes ?? 0) + DAY_MINUTES2;
        const anchor = typeof config.anchor === "string" && config.anchor.trim() ? config.anchor.trim() : fallbackAnchor(index);
        const action = typeof config.action === "string" && config.action.trim() ? config.action.trim() : defaultActionForIndex(index);
        return {
          order,
          label,
          offsetMinutes: offset,
          anchor,
          action
        };
      })
    };
  }
  function formatPassPlan(plan) {
    if (!plan || !Array.isArray(plan.schedule) || !plan.schedule.length) {
      return "No passes scheduled";
    }
    const steps = plan.schedule.slice().sort((a, b) => (a?.order ?? 0) - (b?.order ?? 0)).map((step) => {
      const action = typeof step?.action === "string" && step.action.trim() ? step.action.trim() : `Pass ${step?.order ?? ""}`;
      const offset = formatOffset(step?.offsetMinutes ?? 0);
      return `${action} \u2022 ${offset}`;
    });
    return `Plan: ${steps.join(", ")}`;
  }
  function formatWeekCount(weeks) {
    if (!Number.isFinite(weeks) || weeks <= 0) return null;
    const rounded = Math.max(1, Math.round(weeks));
    return `${rounded} week${rounded === 1 ? "" : "s"}`;
  }
  function parseBlockDate(value) {
    if (!value) return null;
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return null;
    return date;
  }
  function formatBlockDate(value, options = { month: "short", day: "numeric", year: "numeric" }) {
    const date = parseBlockDate(value);
    if (!date) return null;
    const formatter = new Intl.DateTimeFormat(void 0, options);
    return formatter.format(date);
  }
  function formatDateRange(start, end) {
    const startDate = parseBlockDate(start);
    const endDate = parseBlockDate(end);
    if (!startDate && !endDate) return null;
    if (startDate && endDate) {
      const formatter = new Intl.DateTimeFormat(void 0, { month: "short", day: "numeric", year: "numeric" });
      return `${formatter.format(startDate)} \u2192 ${formatter.format(endDate)}`;
    }
    if (startDate) {
      const formatted2 = formatBlockDate(startDate);
      return formatted2 ? `Starts ${formatted2}` : null;
    }
    const formatted = formatBlockDate(endDate);
    return formatted ? `Ends ${formatted}` : null;
  }
  function computeSpanDays(start, end) {
    const startDate = parseBlockDate(start);
    const endDate = parseBlockDate(end);
    if (!startDate || !endDate) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Math.round(diff / DAY_MS) + 1;
  }
  function formatBlockMeta(block) {
    if (!block) return "No block data";
    const parts = [];
    const weeks = formatWeekCount(Number(block.weeks));
    if (weeks) parts.push(weeks);
    const range = formatDateRange(block.startDate, block.endDate);
    if (range) parts.push(range);
    const spanDays = computeSpanDays(block.startDate, block.endDate);
    if (spanDays) parts.push(`${spanDays} day${spanDays === 1 ? "" : "s"}`);
    return parts.join(" \u2022 ") || "Block details unavailable";
  }
  async function renderSettings(root2) {
    root2.innerHTML = "";
    const content = document.createElement("div");
    content.className = "tab-content settings-content";
    root2.appendChild(content);
    const layout = document.createElement("div");
    layout.className = "settings-layout";
    content.appendChild(layout);
    const [catalogResult, settingsResult] = await Promise.allSettled([
      loadBlockCatalog(),
      getSettings()
    ]);
    if (catalogResult.status === "rejected") {
      console.warn("Failed to load block catalog", catalogResult.reason);
    }
    if (settingsResult.status === "rejected") {
      console.warn("Failed to load app settings", settingsResult.reason);
    }
    const catalog = catalogResult.status === "fulfilled" && catalogResult.value ? catalogResult.value : { blocks: [] };
    const settings = settingsResult.status === "fulfilled" ? settingsResult.value : null;
    const blocks = Array.isArray(catalog.blocks) ? catalog.blocks : [];
    const reviewSteps = {
      ...DEFAULT_REVIEW_STEPS,
      ...settings?.reviewSteps || {}
    };
    const durationUnits = [
      { value: "minutes", label: "minutes", factor: 1 },
      { value: "hours", label: "hours", factor: 60 },
      { value: "days", label: "days", factor: 1440 },
      { value: "weeks", label: "weeks", factor: 10080 }
    ];
    const durationFactorMap = durationUnits.reduce((acc, unit) => {
      acc[unit.value] = unit.factor;
      return acc;
    }, {});
    const durationAliasFactors = {
      m: 1,
      min: 1,
      mins: 1,
      minute: 1,
      minutes: 1,
      h: 60,
      hr: 60,
      hrs: 60,
      hour: 60,
      hours: 60,
      d: 1440,
      day: 1440,
      days: 1440,
      w: 10080,
      wk: 10080,
      wks: 10080,
      week: 10080,
      weeks: 10080
    };
    const minutesToParts = (minutes) => {
      if (!Number.isFinite(minutes) || minutes <= 0) {
        return { value: "", unit: "minutes" };
      }
      const unitCandidates = [
        { unit: "weeks", factor: durationFactorMap.weeks },
        { unit: "days", factor: durationFactorMap.days },
        { unit: "hours", factor: durationFactorMap.hours },
        { unit: "minutes", factor: 1 }
      ];
      for (const { unit, factor } of unitCandidates) {
        if (!factor) continue;
        const value = minutes / factor;
        if (value >= 1 && Number.isInteger(value)) {
          return { value, unit };
        }
      }
      for (const { unit, factor } of unitCandidates) {
        if (!factor) continue;
        const value = minutes / factor;
        if (value >= 1) {
          return { value: Math.round(value * 100) / 100, unit };
        }
      }
      return { value: Math.round(minutes * 100) / 100, unit: "minutes" };
    };
    const convertToMinutes = (amount, unit) => {
      const factor = durationFactorMap[unit] || 1;
      const raw = Number(amount);
      if (!Number.isFinite(raw) || raw <= 0) return null;
      return Math.max(1, Math.round(raw * factor));
    };
    const parseDurationToken = (token) => {
      if (!token) return null;
      const trimmed = token.trim();
      if (!trimmed) return null;
      const numeric = Number(trimmed);
      if (Number.isFinite(numeric) && numeric > 0) {
        return Math.max(1, Math.round(numeric));
      }
      const match = trimmed.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z]+)?$/);
      if (!match) return null;
      const amount = Number(match[1]);
      if (!Number.isFinite(amount) || amount <= 0) return null;
      const unitToken = (match[2] || "minutes").toLowerCase();
      const factor = durationAliasFactors[unitToken];
      if (!factor) return null;
      return Math.max(1, Math.round(amount * factor));
    };
    const parseDurationListString = (value) => {
      const raw = (value || "").trim();
      if (!raw) return [];
      const entries = raw.split(/[;,\n]+/);
      const results = [];
      for (const entry of entries) {
        const minutes = parseDurationToken(entry);
        if (!Number.isFinite(minutes) || minutes <= 0) {
          return null;
        }
        results.push(minutes);
      }
      return results;
    };
    const formatDurationDisplay = (minutes) => {
      if (!Number.isFinite(minutes) || minutes <= 0) return "";
      if (minutes % durationFactorMap.weeks === 0) {
        const value = minutes / durationFactorMap.weeks;
        return `${value} ${value === 1 ? "week" : "weeks"}`;
      }
      if (minutes % durationFactorMap.days === 0) {
        const value = minutes / durationFactorMap.days;
        return `${value} ${value === 1 ? "day" : "days"}`;
      }
      if (minutes % durationFactorMap.hours === 0) {
        const value = minutes / durationFactorMap.hours;
        return `${value} ${value === 1 ? "hour" : "hours"}`;
      }
      const rounded = Math.round(minutes * 100) / 100;
      return `${rounded} ${rounded === 1 ? "minute" : "minutes"}`;
    };
    const createDurationControl = (minutes) => {
      const control = document.createElement("div");
      control.className = "settings-review-control";
      const amountInput = document.createElement("input");
      amountInput.type = "number";
      amountInput.min = "0.1";
      amountInput.step = "0.1";
      amountInput.className = "input settings-review-input";
      const unitSelect = document.createElement("select");
      unitSelect.className = "input settings-review-unit";
      durationUnits.forEach((unit) => {
        const option = document.createElement("option");
        option.value = unit.value;
        option.textContent = unit.label;
        unitSelect.appendChild(option);
      });
      const parts = minutesToParts(minutes);
      if (parts.value !== "") amountInput.value = String(parts.value);
      unitSelect.value = parts.unit;
      control.appendChild(amountInput);
      control.appendChild(unitSelect);
      return { wrapper: control, amountInput, unitSelect };
    };
    const plannerDefaults = settings?.plannerDefaults || DEFAULT_PLANNER_DEFAULTS;
    const blocksCard = document.createElement("section");
    blocksCard.className = "card";
    const bHeading = document.createElement("h2");
    bHeading.textContent = "Blocks";
    blocksCard.appendChild(bHeading);
    const list = document.createElement("div");
    list.className = "block-list";
    blocksCard.appendChild(list);
    if (!blocks.length) {
      list.appendChild(createEmptyState());
    }
    blocks.forEach((block, index) => {
      if (!block) return;
      const wrap = document.createElement("div");
      wrap.className = "settings-block-row";
      if (block.color) {
        wrap.style.setProperty("--block-accent", block.color);
        wrap.classList.add("has-accent");
      }
      const header = document.createElement("div");
      header.className = "settings-block-header";
      const title = document.createElement("h3");
      title.className = "settings-block-title";
      title.textContent = block.title || "Untitled block";
      if (block.color) {
        title.style.setProperty("--block-accent", block.color);
        title.classList.add("has-accent");
      }
      header.appendChild(title);
      const meta = document.createElement("div");
      meta.className = "settings-block-meta";
      meta.textContent = formatBlockMeta(block);
      header.appendChild(meta);
      const controls = document.createElement("div");
      controls.className = "settings-block-controls";
      const upBtn = document.createElement("button");
      upBtn.type = "button";
      upBtn.className = "btn tertiary";
      upBtn.textContent = "\u2191";
      upBtn.disabled = index === 0;
      upBtn.addEventListener("click", async () => {
        const other = blocks[index - 1];
        if (!other) return;
        const tmp = block.order;
        block.order = other.order;
        other.order = tmp;
        await upsertBlock(block);
        await upsertBlock(other);
        invalidateBlockCatalog();
        await renderSettings(root2);
      });
      controls.appendChild(upBtn);
      const downBtn = document.createElement("button");
      downBtn.type = "button";
      downBtn.className = "btn tertiary";
      downBtn.textContent = "\u2193";
      downBtn.disabled = index === blocks.length - 1;
      downBtn.addEventListener("click", async () => {
        const other = blocks[index + 1];
        if (!other) return;
        const tmp = block.order;
        block.order = other.order;
        other.order = tmp;
        await upsertBlock(block);
        await upsertBlock(other);
        invalidateBlockCatalog();
        await renderSettings(root2);
      });
      controls.appendChild(downBtn);
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "btn secondary";
      editBtn.textContent = "Edit";
      controls.appendChild(editBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "btn secondary";
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", async () => {
        if (!await confirmModal("Delete block?")) return;
        await deleteBlock(block.blockId);
        invalidateBlockCatalog();
        await renderSettings(root2);
      });
      controls.appendChild(deleteBtn);
      header.appendChild(controls);
      wrap.appendChild(header);
      const detailGrid = document.createElement("div");
      detailGrid.className = "settings-block-detail-grid";
      const startDetail = document.createElement("div");
      startDetail.className = "settings-block-detail";
      startDetail.innerHTML = `<span>Start</span><strong>${formatBlockDate(block.startDate) || "\u2014"}</strong>`;
      detailGrid.appendChild(startDetail);
      const endDetail = document.createElement("div");
      endDetail.className = "settings-block-detail";
      endDetail.innerHTML = `<span>End</span><strong>${formatBlockDate(block.endDate) || "\u2014"}</strong>`;
      detailGrid.appendChild(endDetail);
      const weeksDetail = document.createElement("div");
      weeksDetail.className = "settings-block-detail";
      weeksDetail.innerHTML = `<span>Weeks</span><strong>${formatWeekCount(Number(block.weeks)) || "\u2014"}</strong>`;
      detailGrid.appendChild(weeksDetail);
      const spanDays = computeSpanDays(block.startDate, block.endDate);
      const daysDetail = document.createElement("div");
      daysDetail.className = "settings-block-detail";
      daysDetail.innerHTML = `<span>Span</span><strong>${spanDays ? `${spanDays} day${spanDays === 1 ? "" : "s"}` : "\u2014"}</strong>`;
      detailGrid.appendChild(daysDetail);
      wrap.appendChild(detailGrid);
      const editForm = document.createElement("form");
      editForm.className = "settings-block-edit";
      editForm.hidden = true;
      const titleInput2 = document.createElement("input");
      titleInput2.type = "text";
      titleInput2.required = true;
      titleInput2.className = "input";
      titleInput2.value = block.title || "";
      const weeksInput2 = document.createElement("input");
      weeksInput2.type = "number";
      weeksInput2.min = "1";
      weeksInput2.required = true;
      weeksInput2.className = "input";
      weeksInput2.value = block.weeks != null ? String(block.weeks) : "1";
      const startInput2 = document.createElement("input");
      startInput2.type = "date";
      startInput2.className = "input";
      startInput2.value = block.startDate || "";
      const endInput2 = document.createElement("input");
      endInput2.type = "date";
      endInput2.className = "input";
      endInput2.value = block.endDate || "";
      const colorInput2 = document.createElement("input");
      colorInput2.type = "color";
      colorInput2.className = "input";
      colorInput2.value = block.color || "#ffffff";
      const saveBtn = document.createElement("button");
      saveBtn.type = "submit";
      saveBtn.className = "btn";
      saveBtn.textContent = "Save changes";
      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.className = "btn secondary";
      cancelBtn.textContent = "Cancel";
      cancelBtn.addEventListener("click", () => {
        editForm.hidden = true;
      });
      editForm.append(titleInput2, startInput2, endInput2, weeksInput2, colorInput2, saveBtn, cancelBtn);
      editForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const titleValue = titleInput2.value.trim();
        const weeksValue = Number(weeksInput2.value);
        if (!titleValue || !Number.isFinite(weeksValue) || weeksValue <= 0) {
          return;
        }
        let startValue = startInput2.value || null;
        let endValue = endInput2.value || null;
        if (startValue && endValue) {
          const startDate = new Date(startValue);
          const endDate = new Date(endValue);
          if (!Number.isNaN(startDate.getTime()) && !Number.isNaN(endDate.getTime()) && startDate > endDate) {
            const swap = startValue;
            startValue = endValue;
            endValue = swap;
          }
        }
        const payload = {
          ...block,
          title: titleValue,
          weeks: weeksValue,
          color: colorInput2.value || null,
          startDate: startValue,
          endDate: endValue
        };
        await upsertBlock(payload);
        invalidateBlockCatalog();
        await renderSettings(root2);
      });
      wrap.appendChild(editForm);
      editBtn.addEventListener("click", () => {
        editForm.hidden = !editForm.hidden;
      });
      list.appendChild(wrap);
    });
    const form = document.createElement("form");
    form.className = "settings-block-add";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.required = true;
    titleInput.placeholder = "Block title";
    titleInput.className = "input";
    const startInput = document.createElement("input");
    startInput.type = "date";
    startInput.className = "input";
    startInput.placeholder = "Start date";
    startInput.setAttribute("aria-label", "Block start date");
    const endInput = document.createElement("input");
    endInput.type = "date";
    endInput.className = "input";
    endInput.placeholder = "End date";
    endInput.setAttribute("aria-label", "Block end date");
    const weeksInput = document.createElement("input");
    weeksInput.type = "number";
    weeksInput.min = "1";
    weeksInput.required = true;
    weeksInput.value = "1";
    weeksInput.placeholder = "Weeks";
    weeksInput.className = "input";
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.className = "input";
    colorInput.value = "#ffffff";
    const submitBtn = document.createElement("button");
    submitBtn.type = "submit";
    submitBtn.className = "btn";
    submitBtn.textContent = "Add block (top)";
    form.append(titleInput, startInput, endInput, weeksInput, colorInput, submitBtn);
    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const titleValue = titleInput.value.trim();
      const weeksValue = Number(weeksInput.value);
      if (!titleValue || !Number.isFinite(weeksValue) || weeksValue <= 0) {
        return;
      }
      let startValue = startInput.value || null;
      let endValue = endInput.value || null;
      if (startValue && endValue) {
        const startDate = new Date(startValue);
        const endDate = new Date(endValue);
        if (!Number.isNaN(startDate.getTime()) && !Number.isNaN(endDate.getTime()) && startDate > endDate) {
          const swap = startValue;
          startValue = endValue;
          endValue = swap;
        }
      }
      await upsertBlock({
        title: titleValue,
        weeks: weeksValue,
        color: colorInput.value || null,
        startDate: startValue,
        endDate: endValue
      });
      titleInput.value = "";
      startInput.value = "";
      endInput.value = "";
      weeksInput.value = "1";
      colorInput.value = "#ffffff";
      invalidateBlockCatalog();
      await renderSettings(root2);
    });
    blocksCard.appendChild(form);
    layout.appendChild(blocksCard);
    const reviewCard = document.createElement("section");
    reviewCard.className = "card";
    const rHeading = document.createElement("h2");
    rHeading.textContent = "Review";
    reviewCard.appendChild(rHeading);
    const reviewForm = document.createElement("form");
    reviewForm.className = "settings-review-form";
    reviewForm.dataset.section = "review";
    const stepsHeading = document.createElement("h3");
    stepsHeading.className = "settings-subheading";
    stepsHeading.textContent = "Button delays (when each rating shows up again)";
    reviewForm.appendChild(stepsHeading);
    const stepsDescription = document.createElement("p");
    stepsDescription.className = "settings-review-help";
    stepsDescription.textContent = "Use these to control how soon you will see a card again after choosing Again, Hard, Good, or Easy.";
    reviewForm.appendChild(stepsDescription);
    const grid = document.createElement("div");
    grid.className = "settings-review-grid";
    reviewForm.appendChild(grid);
    const ratingLabels = {
      again: "Again",
      hard: "Hard",
      good: "Good",
      easy: "Easy"
    };
    const ratingDescriptions = {
      again: "Repeat almost immediately when you didn\u2019t remember.",
      hard: "Give yourself a short break after a difficult recall.",
      good: "Normal delay for a comfortable review.",
      easy: "A longer break when the card feels effortless."
    };
    const reviewInputs = /* @__PURE__ */ new Map();
    for (const rating of REVIEW_RATINGS) {
      const row = document.createElement("label");
      row.className = "settings-review-row";
      const title = document.createElement("span");
      title.className = "settings-review-title";
      title.textContent = ratingLabels[rating] || rating;
      row.appendChild(title);
      if (ratingDescriptions[rating]) {
        const desc = document.createElement("span");
        desc.className = "settings-review-help";
        desc.textContent = ratingDescriptions[rating];
        row.appendChild(desc);
      }
      const control = document.createElement("div");
      control.className = "settings-review-control";
      const amountInput = document.createElement("input");
      amountInput.type = "number";
      amountInput.min = "0.1";
      amountInput.step = "0.1";
      amountInput.required = true;
      amountInput.className = "input settings-review-input";
      amountInput.dataset.rating = rating;
      const unitSelect = document.createElement("select");
      unitSelect.className = "input settings-review-unit";
      durationUnits.forEach((unit) => {
        const option = document.createElement("option");
        option.value = unit.value;
        option.textContent = unit.label;
        unitSelect.appendChild(option);
      });
      const parts = minutesToParts(reviewSteps[rating] ?? DEFAULT_REVIEW_STEPS[rating]);
      if (parts.value !== "") {
        amountInput.value = String(parts.value);
      }
      unitSelect.value = parts.unit;
      control.appendChild(amountInput);
      control.appendChild(unitSelect);
      row.appendChild(control);
      reviewInputs.set(rating, { amount: amountInput, unit: unitSelect });
      grid.appendChild(row);
    }
    const advancedHeading = document.createElement("h3");
    advancedHeading.className = "settings-subheading";
    advancedHeading.textContent = "Fine-tune spaced repetition (optional)";
    reviewForm.appendChild(advancedHeading);
    const advancedIntro = document.createElement("p");
    advancedIntro.className = "settings-review-help";
    advancedIntro.textContent = "Tweak how cards graduate, how ease changes, and how lapses behave. Leave any field blank to keep the default.";
    reviewForm.appendChild(advancedIntro);
    const advancedGrid = document.createElement("div");
    advancedGrid.className = "settings-review-grid";
    reviewForm.appendChild(advancedGrid);
    const advancedInputs = /* @__PURE__ */ new Map();
    const advancedFields = [
      {
        key: "learningSteps",
        label: "Extra learning reviews",
        description: 'Short delays right after you learn a card. Separate times with commas (e.g., "10 min, 1 hour").',
        type: "list",
        placeholder: "10 min, 1 hour"
      },
      {
        key: "relearningSteps",
        label: "Relearning reviews after a lapse",
        description: "Used when you miss a mature card.",
        type: "list",
        placeholder: "10 min"
      },
      {
        key: "graduatingGood",
        label: "\u201CGood\u201D graduation delay",
        description: "How long until the next review when you finish learning with Good.",
        type: "duration"
      },
      {
        key: "graduatingEasy",
        label: "\u201CEasy\u201D graduation delay",
        description: "How long until the next review when you finish learning with Easy.",
        type: "duration"
      },
      {
        key: "startingEase",
        label: "Starting ease",
        description: "How quickly intervals grow after a card graduates.",
        type: "number",
        min: 0.5,
        step: 0.05
      },
      {
        key: "minimumEase",
        label: "Minimum ease",
        description: "Prevents ease from dropping too low after misses.",
        type: "number",
        min: 0.5,
        step: 0.05
      },
      {
        key: "easeBonus",
        label: "Easy bonus",
        description: "Extra boost applied when you choose Easy.",
        type: "number",
        min: 0,
        step: 0.05,
        allowZero: true
      },
      {
        key: "easePenalty",
        label: "\u201CAgain\u201D penalty",
        description: "Ease reduction when you miss a card.",
        type: "number",
        min: 0,
        step: 0.05,
        allowZero: true
      },
      {
        key: "hardEasePenalty",
        label: "\u201CHard\u201D penalty",
        description: "Small ease decrease applied after choosing Hard.",
        type: "number",
        min: 0,
        step: 0.05,
        allowZero: true
      },
      {
        key: "hardIntervalMultiplier",
        label: "\u201CHard\u201D interval multiplier",
        description: "Scales the next review interval when you choose Hard.",
        type: "number",
        min: 0.1,
        step: 0.05
      },
      {
        key: "easyIntervalBonus",
        label: "\u201CEasy\u201D interval bonus",
        description: "Multiplier for the next interval when you choose Easy.",
        type: "number",
        min: 0.1,
        step: 0.05
      },
      {
        key: "intervalModifier",
        label: "Overall pacing multiplier",
        description: "Adjust every interval globally. Values above 1 slow things down.",
        type: "number",
        min: 0.1,
        step: 0.05
      },
      {
        key: "lapseIntervalMultiplier",
        label: "Lapse interval restart",
        description: "How much of the previous interval you keep after a lapse.",
        type: "number",
        min: 0.1,
        step: 0.05
      }
    ];
    advancedFields.forEach((field) => {
      const row = document.createElement("label");
      row.className = "settings-review-row";
      const title = document.createElement("span");
      title.className = "settings-review-title";
      title.textContent = field.label;
      row.appendChild(title);
      if (field.description) {
        const desc = document.createElement("span");
        desc.className = "settings-review-help";
        desc.textContent = field.description;
        row.appendChild(desc);
      }
      if (field.type === "list") {
        const input = document.createElement("input");
        input.type = "text";
        input.className = "input settings-review-input";
        if (field.placeholder) input.placeholder = field.placeholder;
        const currentValue = reviewSteps[field.key];
        if (Array.isArray(currentValue)) {
          input.value = currentValue.map(formatDurationDisplay).filter(Boolean).join(", ");
        }
        row.appendChild(input);
        advancedInputs.set(field.key, { type: "list", input });
      } else if (field.type === "duration") {
        const currentMinutes = Number.isFinite(Number(reviewSteps[field.key])) ? Number(reviewSteps[field.key]) : Number(DEFAULT_REVIEW_STEPS[field.key]);
        const control = createDurationControl(currentMinutes);
        row.appendChild(control.wrapper);
        advancedInputs.set(field.key, { type: "duration", amount: control.amountInput, unit: control.unitSelect });
      } else {
        const input = document.createElement("input");
        input.type = "number";
        input.className = "input settings-review-input";
        if (field.min != null) input.min = String(field.min);
        if (field.step != null) input.step = String(field.step);
        const currentValue = reviewSteps[field.key];
        if (currentValue != null) {
          input.value = String(currentValue);
        }
        row.appendChild(input);
        advancedInputs.set(field.key, { type: "number", input, allowZero: field.allowZero || false, min: field.min ?? 0 });
      }
      advancedGrid.appendChild(row);
    });
    const saveReviewBtn = document.createElement("button");
    saveReviewBtn.type = "submit";
    saveReviewBtn.className = "btn";
    saveReviewBtn.textContent = "Save review settings";
    reviewForm.appendChild(saveReviewBtn);
    const reviewStatus = document.createElement("p");
    reviewStatus.className = "settings-review-status";
    reviewStatus.hidden = true;
    reviewForm.appendChild(reviewStatus);
    reviewForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      reviewStatus.textContent = "";
      reviewStatus.hidden = true;
      reviewStatus.classList.remove("is-error");
      const nextSteps = {};
      for (const [rating, control] of reviewInputs) {
        const minutes = convertToMinutes(control.amount.value, control.unit.value);
        if (!Number.isFinite(minutes) || minutes <= 0) {
          reviewStatus.textContent = "Enter a positive time for each rating button.";
          reviewStatus.classList.add("is-error");
          reviewStatus.hidden = false;
          control.amount.focus();
          return;
        }
        nextSteps[rating] = minutes;
      }
      const advancedPatch = {};
      const failField = (message, input) => {
        reviewStatus.textContent = message;
        reviewStatus.classList.add("is-error");
        reviewStatus.hidden = false;
        if (input) input.focus();
        return false;
      };
      const parseListField = (key, label) => {
        const entry = advancedInputs.get(key);
        if (!entry || entry.type !== "list") return true;
        const raw = (entry.input.value || "").trim();
        if (!raw) return true;
        const values = parseDurationListString(raw);
        if (!values || !values.length) {
          return failField(`Enter positive times for ${label}.`, entry.input);
        }
        advancedPatch[key] = values;
        return true;
      };
      const parseDurationField = (key, label) => {
        const entry = advancedInputs.get(key);
        if (!entry || entry.type !== "duration") return true;
        const minutes = convertToMinutes(entry.amount.value, entry.unit.value);
        if (!Number.isFinite(minutes) || minutes <= 0) {
          return failField(`Enter a positive time for ${label}.`, entry.amount);
        }
        advancedPatch[key] = minutes;
        return true;
      };
      const parseNumberField = (key, label, { min = 0, allowZero = false } = {}) => {
        const entry = advancedInputs.get(key);
        if (!entry || entry.type !== "number") return true;
        const raw = entry.input.value;
        if (raw == null || raw === "") return true;
        const value = Number(raw);
        if (!Number.isFinite(value)) {
          return failField(`Enter a number for ${label}.`, entry.input);
        }
        if (value < min && !(allowZero && value === 0)) {
          return failField(`Value for ${label} must be at least ${min}.`, entry.input);
        }
        if (!allowZero && value === 0) {
          return failField(`Value for ${label} must be greater than zero.`, entry.input);
        }
        advancedPatch[key] = value;
        return true;
      };
      if (!parseListField("learningSteps", "extra learning reviews")) return;
      if (!parseListField("relearningSteps", "relearning reviews")) return;
      if (!parseDurationField("graduatingGood", "the \u201CGood\u201D graduation delay")) return;
      if (!parseDurationField("graduatingEasy", "the \u201CEasy\u201D graduation delay")) return;
      if (!parseNumberField("startingEase", "starting ease", { min: 0.5, allowZero: false })) return;
      if (!parseNumberField("minimumEase", "minimum ease", { min: 0.5, allowZero: false })) return;
      if (!parseNumberField("easeBonus", "easy bonus", { min: 0, allowZero: true })) return;
      if (!parseNumberField("easePenalty", "\u201CAgain\u201D penalty", { min: 0, allowZero: true })) return;
      if (!parseNumberField("hardEasePenalty", "\u201CHard\u201D penalty", { min: 0, allowZero: true })) return;
      if (!parseNumberField("hardIntervalMultiplier", "\u201CHard\u201D interval multiplier", { min: 0.1, allowZero: false })) return;
      if (!parseNumberField("easyIntervalBonus", "\u201CEasy\u201D interval bonus", { min: 0.1, allowZero: false })) return;
      if (!parseNumberField("intervalModifier", "overall pacing multiplier", { min: 0.1, allowZero: false })) return;
      if (!parseNumberField("lapseIntervalMultiplier", "lapse interval restart", { min: 0.1, allowZero: false })) return;
      Object.assign(nextSteps, advancedPatch);
      const originalText = saveReviewBtn.textContent;
      saveReviewBtn.disabled = true;
      saveReviewBtn.textContent = "Saving\u2026";
      try {
        await saveSettings({ reviewSteps: nextSteps });
        const updated = await getSettings();
        const normalized2 = {
          ...DEFAULT_REVIEW_STEPS,
          ...updated?.reviewSteps || {}
        };
        for (const [rating, control] of reviewInputs) {
          const value = normalized2[rating];
          const parts = minutesToParts(value);
          control.amount.value = parts.value !== "" ? String(parts.value) : "";
          control.unit.value = parts.unit;
        }
        for (const [key, entry] of advancedInputs) {
          if (!entry) continue;
          const value = normalized2[key];
          if (entry.type === "list") {
            if (Array.isArray(value)) {
              entry.input.value = value.map(formatDurationDisplay).filter(Boolean).join(", ");
            } else {
              entry.input.value = "";
            }
          } else if (entry.type === "duration") {
            const parts = minutesToParts(value);
            entry.amount.value = parts.value !== "" ? String(parts.value) : "";
            entry.unit.value = parts.unit;
          } else if (entry.type === "number") {
            entry.input.value = value != null ? String(value) : "";
          }
        }
        reviewStatus.textContent = "Review settings saved.";
        reviewStatus.hidden = false;
      } catch (err) {
        console.warn("Failed to save review settings", err);
        reviewStatus.textContent = "Failed to save review settings.";
        reviewStatus.classList.add("is-error");
        reviewStatus.hidden = false;
      } finally {
        saveReviewBtn.disabled = false;
        saveReviewBtn.textContent = originalText;
      }
    });
    reviewCard.appendChild(reviewForm);
    layout.appendChild(reviewCard);
    const passDefaultsCard = document.createElement("section");
    passDefaultsCard.className = "card";
    const passHeading = document.createElement("h2");
    passHeading.textContent = "Lecture pass defaults";
    passDefaultsCard.appendChild(passHeading);
    const passDescription = document.createElement("p");
    passDescription.className = "settings-pass-description";
    passDescription.textContent = "Configure the default pass count, timing, and pass functions applied to new lectures.";
    passDefaultsCard.appendChild(passDescription);
    const passForm = document.createElement("form");
    passForm.className = "settings-pass-form";
    passDefaultsCard.appendChild(passForm);
    let currentPlannerDefaults = plannerDefaults;
    const defaultPlan = plannerDefaultsToPassPlan(currentPlannerDefaults);
    let planTemplate = defaultPlan;
    let passConfigs = Array.isArray(defaultPlan.schedule) ? defaultPlan.schedule.map((step) => ({ ...step })) : [];
    let passColors = Array.isArray(currentPlannerDefaults?.passColors) && currentPlannerDefaults.passColors.length ? currentPlannerDefaults.passColors.slice() : DEFAULT_PASS_COLORS.slice();
    function ensurePassColorCount(count) {
      const normalized2 = Math.max(0, Number.isFinite(count) ? Math.round(count) : 0);
      const next = [];
      for (let i = 0; i < normalized2; i += 1) {
        const existing = passColors[i];
        if (typeof existing === "string" && existing.trim()) {
          next.push(existing.trim());
        } else {
          next.push(DEFAULT_PASS_COLORS[i % DEFAULT_PASS_COLORS.length]);
        }
      }
      passColors = next;
    }
    function resolvedPassColor(index) {
      if (typeof passColors[index] === "string" && passColors[index].trim()) {
        return passColors[index].trim();
      }
      return DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
    }
    ensurePassColorCount(passConfigs.length);
    const passCountField = document.createElement("label");
    passCountField.className = "lecture-pass-count settings-pass-count";
    passCountField.textContent = "Default pass count";
    const passCountInput = document.createElement("input");
    passCountInput.type = "number";
    passCountInput.min = "0";
    passCountInput.max = String(MAX_PASS_COUNT);
    passCountInput.className = "input";
    passCountInput.value = String(passConfigs.length);
    passCountField.appendChild(passCountInput);
    const passCountHelp = document.createElement("span");
    passCountHelp.className = "lecture-pass-help";
    passCountHelp.textContent = "Set the default number of spaced passes for new lectures.";
    passCountField.appendChild(passCountHelp);
    passForm.appendChild(passCountField);
    const passColorSection = document.createElement("div");
    passColorSection.className = "settings-pass-colors";
    const passColorTitle = document.createElement("h3");
    passColorTitle.className = "settings-pass-colors-title";
    passColorTitle.textContent = "Pass colors";
    passColorSection.appendChild(passColorTitle);
    const passColorHint = document.createElement("p");
    passColorHint.className = "settings-pass-colors-hint";
    passColorHint.textContent = "Choose the accent color used for pass chips and timeline bars.";
    passColorSection.appendChild(passColorHint);
    const passColorList = document.createElement("div");
    passColorList.className = "settings-pass-color-list";
    passColorSection.appendChild(passColorList);
    const passColorActions = document.createElement("div");
    passColorActions.className = "settings-pass-color-actions";
    const passColorReset = document.createElement("button");
    passColorReset.type = "button";
    passColorReset.className = "settings-pass-colors-reset";
    passColorReset.textContent = "Reset to defaults";
    passColorActions.appendChild(passColorReset);
    passColorSection.appendChild(passColorActions);
    passForm.appendChild(passColorSection);
    const passSummary = document.createElement("div");
    passSummary.className = "lecture-pass-summary-line settings-pass-summary";
    passForm.appendChild(passSummary);
    const passAdvanced = document.createElement("details");
    passAdvanced.className = "lecture-pass-advanced settings-pass-advanced";
    passAdvanced.open = true;
    const passAdvancedSummary = document.createElement("summary");
    passAdvancedSummary.textContent = `Pass details (${passConfigs.length})`;
    passAdvanced.appendChild(passAdvancedSummary);
    const passAdvancedHint = document.createElement("p");
    passAdvancedHint.className = "lecture-pass-advanced-hint";
    passAdvancedHint.textContent = "Tune the pass function and spacing for each default pass.";
    passAdvanced.appendChild(passAdvancedHint);
    const passList = document.createElement("div");
    passList.className = "lecture-pass-editor settings-pass-editor";
    passAdvanced.appendChild(passList);
    passForm.appendChild(passAdvanced);
    const passStatus = document.createElement("p");
    passStatus.className = "settings-pass-status";
    passStatus.hidden = true;
    passForm.appendChild(passStatus);
    const passSaveBtn = document.createElement("button");
    passSaveBtn.type = "submit";
    passSaveBtn.className = "btn";
    passSaveBtn.textContent = "Save pass defaults";
    passForm.appendChild(passSaveBtn);
    function updatePassSummary() {
      if (!passConfigs.length) {
        passSummary.textContent = "No default passes scheduled.";
      } else {
        const previewPlan = buildPassPlanPayload(passConfigs, planTemplate);
        const previewText = formatPassPlan(previewPlan);
        const cleaned = previewText.startsWith("Plan: ") ? previewText.slice(6) : previewText;
        passSummary.textContent = `${passConfigs.length} pass${passConfigs.length === 1 ? "" : "es"} \u2022 ${cleaned}`;
      }
      passAdvancedSummary.textContent = `Pass details (${passConfigs.length})`;
    }
    function renderPassColorInputs() {
      passColorList.innerHTML = "";
      ensurePassColorCount(passConfigs.length);
      if (!passColors.length) {
        passColorReset.disabled = true;
        const empty = document.createElement("p");
        empty.className = "settings-pass-colors-empty";
        empty.textContent = "Increase the pass count above to configure colors.";
        passColorList.appendChild(empty);
        return;
      }
      passColorReset.disabled = false;
      passColors = passColors.map((_, index) => resolvedPassColor(index));
      passColors.forEach((color, index) => {
        const row = document.createElement("div");
        row.className = "settings-pass-color";
        const label = document.createElement("span");
        label.className = "settings-pass-color-label";
        label.textContent = `Pass ${index + 1}`;
        const swatch = document.createElement("span");
        swatch.className = "settings-pass-color-swatch";
        swatch.style.setProperty("--swatch-color", color);
        const input = document.createElement("input");
        input.className = "input settings-pass-color-input";
        input.type = "text";
        input.value = color;
        input.placeholder = DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
        input.addEventListener("input", (event) => {
          const next = event.target.value.trim();
          const value = next || DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
          passColors[index] = value;
          swatch.style.setProperty("--swatch-color", value);
        });
        row.append(label, swatch, input);
        passColorList.appendChild(row);
      });
    }
    function renderPassEditor() {
      passList.innerHTML = "";
      if (!passConfigs.length) {
        const empty = document.createElement("div");
        empty.className = "lecture-pass-empty";
        empty.textContent = "No passes planned. Increase the count above to build a default schedule.";
        passList.appendChild(empty);
        updatePassSummary();
        renderPassColorInputs();
        return;
      }
      passConfigs.forEach((config, index) => {
        const row = document.createElement("div");
        row.className = "lecture-pass-row";
        const label = document.createElement("div");
        label.className = "lecture-pass-label";
        label.textContent = `Pass ${index + 1}`;
        row.appendChild(label);
        const controls = document.createElement("div");
        controls.className = "lecture-pass-controls";
        const actionField = document.createElement("div");
        actionField.className = "lecture-pass-field";
        const actionLabel = document.createElement("span");
        actionLabel.className = "lecture-pass-field-label";
        actionLabel.textContent = "Pass function";
        actionField.appendChild(actionLabel);
        const select = document.createElement("select");
        select.className = "input lecture-pass-action";
        LECTURE_PASS_ACTIONS.forEach((action) => {
          const option = document.createElement("option");
          option.value = action;
          option.textContent = action;
          select.appendChild(option);
        });
        if (config.action && !LECTURE_PASS_ACTIONS.includes(config.action)) {
          const custom = document.createElement("option");
          custom.value = config.action;
          custom.textContent = config.action;
          select.appendChild(custom);
        }
        select.value = config.action || "";
        select.addEventListener("change", (event) => {
          const value = event.target.value;
          passConfigs[index] = { ...passConfigs[index], action: value };
          updatePassSummary();
        });
        actionField.appendChild(select);
        controls.appendChild(actionField);
        const offsetField = document.createElement("div");
        offsetField.className = "lecture-pass-field lecture-pass-offset-field";
        const offsetLabel = document.createElement("span");
        offsetLabel.className = "lecture-pass-field-label";
        offsetLabel.textContent = "Timing";
        offsetField.appendChild(offsetLabel);
        const offsetInputs = document.createElement("div");
        offsetInputs.className = "lecture-pass-offset-inputs";
        const split = splitOffsetMinutes(config.offsetMinutes ?? 0);
        const offsetInput = document.createElement("input");
        offsetInput.type = "number";
        offsetInput.min = "0";
        offsetInput.step = "1";
        offsetInput.className = "input lecture-pass-offset-value";
        offsetInput.value = String(split.value);
        const unitSelect = document.createElement("select");
        unitSelect.className = "input lecture-pass-offset-unit";
        OFFSET_UNITS.forEach((option) => {
          const opt = document.createElement("option");
          opt.value = option.id;
          opt.textContent = option.label;
          unitSelect.appendChild(opt);
        });
        unitSelect.value = split.unit;
        offsetInputs.appendChild(offsetInput);
        offsetInputs.appendChild(unitSelect);
        offsetField.appendChild(offsetInputs);
        const preview = document.createElement("span");
        preview.className = "lecture-pass-offset-preview";
        preview.textContent = formatOffset(config.offsetMinutes ?? 0);
        offsetField.appendChild(preview);
        function commitOffset() {
          const minutes = combineOffsetValueUnit(offsetInput.value, unitSelect.value);
          passConfigs[index] = {
            ...passConfigs[index],
            offsetMinutes: minutes
          };
          preview.textContent = formatOffset(passConfigs[index].offsetMinutes ?? 0);
          updatePassSummary();
        }
        offsetInput.addEventListener("change", () => {
          const numeric = Number(offsetInput.value);
          if (!Number.isFinite(numeric) || numeric < 0) {
            offsetInput.value = "0";
          }
          commitOffset();
        });
        offsetInput.addEventListener("blur", () => {
          const numeric = Math.max(0, Math.round(Number(offsetInput.value) || 0));
          offsetInput.value = String(numeric);
          commitOffset();
        });
        unitSelect.addEventListener("change", commitOffset);
        controls.appendChild(offsetField);
        row.appendChild(controls);
        passList.appendChild(row);
      });
      updatePassSummary();
      renderPassColorInputs();
    }
    renderPassEditor();
    passColorReset.addEventListener("click", () => {
      passColors = DEFAULT_PASS_COLORS.slice(0, passConfigs.length || DEFAULT_PASS_COLORS.length);
      ensurePassColorCount(passConfigs.length);
      renderPassColorInputs();
    });
    passCountInput.addEventListener("change", () => {
      const next = clampPassCount(passCountInput.value);
      passCountInput.value = String(next);
      const template = passConfigs.length ? { schedule: passConfigs.slice() } : planTemplate;
      passConfigs = adjustPassConfigs(passConfigs, next, template);
      ensurePassColorCount(next);
      renderPassEditor();
    });
    passForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      passStatus.textContent = "";
      passStatus.hidden = true;
      passStatus.classList.remove("is-error");
      const anchorOffsets = {
        ...DEFAULT_PLANNER_DEFAULTS.anchorOffsets || {},
        ...currentPlannerDefaults?.anchorOffsets || {}
      };
      const payloadPlan = buildPassPlanPayload(passConfigs, planTemplate);
      const payloadPasses = payloadPlan.schedule.map((step) => ({
        order: step.order,
        label: step.label,
        offsetMinutes: step.offsetMinutes,
        anchor: step.anchor,
        action: step.action
      }));
      const originalText = passSaveBtn.textContent;
      passSaveBtn.disabled = true;
      passSaveBtn.textContent = "Saving\u2026";
      const palette2 = passColors.map((color, index) => {
        if (typeof color === "string") {
          const trimmed = color.trim();
          if (trimmed) return trimmed;
        }
        return DEFAULT_PASS_COLORS[index % DEFAULT_PASS_COLORS.length];
      });
      try {
        await saveSettings({ plannerDefaults: { anchorOffsets, passes: payloadPasses, passColors: palette2 } });
        const updated = await getSettings();
        currentPlannerDefaults = updated?.plannerDefaults || DEFAULT_PLANNER_DEFAULTS;
        const refreshedPlan = plannerDefaultsToPassPlan(currentPlannerDefaults);
        planTemplate = refreshedPlan;
        passConfigs = Array.isArray(refreshedPlan.schedule) ? refreshedPlan.schedule.map((step) => ({ ...step })) : [];
        passColors = Array.isArray(currentPlannerDefaults?.passColors) && currentPlannerDefaults.passColors.length ? currentPlannerDefaults.passColors.slice() : DEFAULT_PASS_COLORS.slice();
        passCountInput.value = String(passConfigs.length);
        renderPassEditor();
        passStatus.textContent = "Pass defaults saved.";
        passStatus.hidden = false;
      } catch (err) {
        console.warn("Failed to save pass defaults", err);
        passStatus.textContent = "Failed to save pass defaults.";
        passStatus.classList.add("is-error");
        passStatus.hidden = false;
      } finally {
        passSaveBtn.disabled = false;
        passSaveBtn.textContent = originalText;
      }
    });
    layout.appendChild(passDefaultsCard);
    const dataCard = document.createElement("section");
    dataCard.className = "card";
    const dHeading = document.createElement("h2");
    dHeading.textContent = "Data";
    dataCard.appendChild(dHeading);
    async function triggerExportDownload(options = {}) {
      const { prefix = "arc-export", withTimestamp = false } = options;
      const dump = await exportJSON();
      const blob = new Blob([JSON.stringify(dump, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const suffix = withTimestamp ? `-${timestamp}` : "";
      const a = document.createElement("a");
      a.href = url;
      a.download = `${prefix}${suffix}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
    const exportBtn = document.createElement("button");
    exportBtn.className = "btn";
    exportBtn.textContent = "Export DB";
    exportBtn.addEventListener("click", async () => {
      try {
        await triggerExportDownload();
      } catch (err) {
        console.error("Failed to export database", err);
        alert("Export failed");
      }
    });
    dataCard.appendChild(exportBtn);
    const importInput = document.createElement("input");
    importInput.type = "file";
    importInput.accept = "application/json,.json,.arc";
    importInput.style.display = "none";
    importInput.addEventListener("change", async () => {
      const file = importInput.files[0];
      if (!file) return;
      try {
        const confirmBackup = window.confirm(
          "Importing will replace your current data. Would you like to download a backup first?"
        );
        if (confirmBackup) {
          try {
            await triggerExportDownload({ prefix: "arc-backup", withTimestamp: true });
          } catch (err) {
            console.error("Failed to create backup prior to import", err);
            alert("Backup failed. Import cancelled.");
            importInput.value = "";
            return;
          }
        }
        const text = await file.text();
        const json = JSON.parse(text);
        const res = await importJSON2(json);
        if (!res?.ok) {
          alert(res?.message || "Import failed");
          return;
        }
        alert(res.message || "Import complete");
        location.reload();
      } catch (e) {
        alert("Import failed");
      } finally {
        importInput.value = "";
      }
    });
    const importBtn = document.createElement("button");
    importBtn.className = "btn";
    importBtn.textContent = "Import DB";
    importBtn.addEventListener("click", () => importInput.click());
    dataCard.appendChild(importBtn);
    dataCard.appendChild(importInput);
    const ankiBtn = document.createElement("button");
    ankiBtn.className = "btn";
    ankiBtn.textContent = "Export Anki CSV";
    ankiBtn.addEventListener("click", async () => {
      const dump = await exportJSON();
      const blob = await exportAnkiCSV("qa", dump.items || []);
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "arc-anki.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    });
    dataCard.appendChild(ankiBtn);
    layout.appendChild(dataCard);
  }
  var DAY_MS, DAY_MINUTES2, MAX_PASS_COUNT, OFFSET_UNITS;
  var init_settings2 = __esm({
    "js/ui/settings.js"() {
      init_storage();
      init_block_catalog();
      init_confirm();
      init_constants();
      init_scheduler();
      init_actions();
      init_pass_colors();
      DAY_MS = 24 * 60 * 60 * 1e3;
      DAY_MINUTES2 = 24 * 60;
      MAX_PASS_COUNT = 20;
      OFFSET_UNITS = [
        { id: "minutes", label: "minutes", minutes: 1 },
        { id: "hours", label: "hours", minutes: 60 },
        { id: "days", label: "days", minutes: 60 * 24 },
        { id: "weeks", label: "weeks", minutes: 60 * 24 * 7 }
      ];
    }
  });

  // js/ui/performance.js
  var performance_exports = {};
  __export(performance_exports, {
    configureElectronPerformance: () => configureElectronPerformance,
    forcePerformanceMode: () => forcePerformanceMode,
    getElectronPerformanceSettings: () => getElectronPerformanceSettings,
    getPerformanceMode: () => getPerformanceMode,
    isPerformanceConstrained: () => isPerformanceConstrained,
    onPerformanceModeChange: () => onPerformanceModeChange,
    registerWindowPresence: () => registerWindowPresence,
    reportListComplexity: () => reportListComplexity
  });
  function detectBaseMode() {
    if (typeof window !== "undefined" && typeof window.matchMedia === "function") {
      try {
        if (window.matchMedia("(prefers-reduced-transparency: reduce)").matches) {
          return "conservative";
        }
      } catch (err) {
        console.warn("Failed to evaluate transparency preference", err);
      }
    }
    if (typeof navigator !== "undefined") {
      if (isElectronEnvironment) {
        return "conservative";
      }
      const memory = Number(navigator.deviceMemory);
      if (Number.isFinite(memory) && memory > 0) {
        if (memory <= 4) {
          return "conservative";
        }
        if (memory <= 8) {
          return "balanced";
        }
      }
    }
    return "standard";
  }
  function withDocumentBody(fn) {
    if (typeof document === "undefined") return;
    if (document.body) {
      fn(document.body);
      return;
    }
    const handler = () => {
      if (!document.body) return;
      fn(document.body);
      document.removeEventListener("DOMContentLoaded", handler);
    };
    document.addEventListener("DOMContentLoaded", handler);
  }
  function applyElectronSettings(settings) {
    if (!settings || typeof settings !== "object") return;
    electronState.settings = {
      disableHardwareAcceleration: Boolean(settings.disableHardwareAcceleration),
      backgroundThrottling: settings.backgroundThrottling !== false
    };
    withDocumentBody((body) => {
      body.dataset.electronHardwareAcceleration = electronState.settings.disableHardwareAcceleration ? "disabled" : "enabled";
      body.dataset.electronBackgroundThrottling = electronState.settings.backgroundThrottling ? "on" : "off";
    });
  }
  function applyMode(nextMode) {
    if (!nextMode) nextMode = "standard";
    if (mode === nextMode) return;
    mode = nextMode;
    withDocumentBody((body) => {
      body.dataset.performanceMode = nextMode;
      body.style.setProperty("--performance-mode", nextMode);
    });
    subscribers.forEach((listener) => {
      try {
        listener(nextMode);
      } catch (err) {
        console.error("Performance listener failed", err);
      }
    });
  }
  function computeComplexityScore(options) {
    if (options == null) return 0;
    if (typeof options === "number") {
      return Number.isFinite(options) ? Math.max(0, Math.round(options)) : 0;
    }
    const items = Number.isFinite(options.items) ? Math.max(0, options.items) : 0;
    const columns = Number.isFinite(options.columns) ? Math.max(1, options.columns) : 1;
    const extras = Number.isFinite(options.extras) ? Math.max(0, options.extras) : 0;
    const weight = Number.isFinite(options.weight) ? Math.max(0.1, options.weight) : 1;
    return Math.round(items * columns * weight + extras);
  }
  function recomputeModeImmediate() {
    const heaviestList = listComplexity.size ? Math.max(...listComplexity.values()) : 0;
    let nextMode = baseMode;
    if (baseMode === "conservative") {
      nextMode = "conservative";
    } else if (windowCount >= 3 || heaviestList >= 240) {
      nextMode = "conservative";
    } else if (windowCount >= 2 || heaviestList >= 140) {
      nextMode = baseMode === "standard" ? "balanced" : baseMode;
    }
    applyMode(nextMode);
  }
  function scheduleRecompute() {
    if (!isElectronEnvironment) {
      recomputeModeImmediate();
      return;
    }
    const now = Date.now();
    if (now - lastRecomputeAt >= ELECTRON_RECOMPUTE_INTERVAL) {
      lastRecomputeAt = now;
      recomputeModeImmediate();
      return;
    }
    if (recomputeTimer) return;
    const delay = Math.max(16, ELECTRON_RECOMPUTE_INTERVAL - (now - lastRecomputeAt));
    recomputeTimer = setTimeout(() => {
      recomputeTimer = null;
      lastRecomputeAt = Date.now();
      recomputeModeImmediate();
    }, delay);
  }
  function getPerformanceMode() {
    return mode || "standard";
  }
  function isPerformanceConstrained() {
    const current = getPerformanceMode();
    return current === "balanced" || current === "conservative";
  }
  function onPerformanceModeChange(listener) {
    if (typeof listener !== "function") return () => {
    };
    subscribers.add(listener);
    return () => subscribers.delete(listener);
  }
  function reportListComplexity(key, options) {
    if (!key) return getPerformanceMode();
    const score = computeComplexityScore(options);
    if (score > 0) {
      listComplexity.set(key, score);
    } else {
      listComplexity.delete(key);
    }
    scheduleRecompute();
    return getPerformanceMode();
  }
  function registerWindowPresence() {
    windowCount += 1;
    scheduleRecompute();
    let released = false;
    return () => {
      if (released) return;
      released = true;
      windowCount = Math.max(0, windowCount - 1);
      scheduleRecompute();
    };
  }
  function getElectronPerformanceSettings() {
    return {
      available: electronState.available,
      ...electronState.settings
    };
  }
  async function configureElectronPerformance(options = {}) {
    if (!electronBridge || typeof electronBridge.updateSettings !== "function") {
      return { success: false, reason: "unavailable" };
    }
    try {
      const result = await electronBridge.updateSettings(options);
      if (result && result.settings) {
        applyElectronSettings(result.settings);
      }
      return { success: true, ...result };
    } catch (err) {
      console.error("Failed to configure electron performance settings", err);
      return { success: false, error: err };
    }
  }
  function forcePerformanceMode(nextMode) {
    if (!nextMode) return;
    if (!["standard", "balanced", "conservative"].includes(nextMode)) return;
    applyMode(nextMode);
  }
  var subscribers, listComplexity, windowCount, mode, isElectronEnvironment, globalScope2, electronBridge, electronState, lastRecomputeAt, recomputeTimer, ELECTRON_RECOMPUTE_INTERVAL, baseMode;
  var init_performance = __esm({
    "js/ui/performance.js"() {
      subscribers = /* @__PURE__ */ new Set();
      listComplexity = /* @__PURE__ */ new Map();
      windowCount = 0;
      mode = "";
      isElectronEnvironment = typeof navigator !== "undefined" && /Electron/i.test(navigator.userAgent || "");
      globalScope2 = typeof window !== "undefined" ? window : void 0;
      electronBridge = globalScope2 && globalScope2.arc && globalScope2.arc.performance ? globalScope2.arc.performance : null;
      electronState = {
        available: Boolean(electronBridge),
        settings: {
          disableHardwareAcceleration: false,
          backgroundThrottling: true
        }
      };
      lastRecomputeAt = 0;
      recomputeTimer = null;
      ELECTRON_RECOMPUTE_INTERVAL = 150;
      baseMode = detectBaseMode();
      if (electronBridge) {
        if (typeof electronBridge.getSettings === "function") {
          electronBridge.getSettings().then((settings) => {
            if (settings) applyElectronSettings(settings);
          }).catch((err) => {
            console.warn("Failed to load electron performance settings", err);
          });
        }
        if (typeof electronBridge.onSettingsChanged === "function") {
          electronBridge.onSettingsChanged((nextSettings) => {
            applyElectronSettings(nextSettings);
          });
        }
      }
      applyMode(baseMode);
    }
  });

  // js/ui/components/window-manager.js
  function ensureDock() {
    if (dock) return;
    dock = document.createElement("div");
    dock.className = "window-dock";
    dockHandle = document.createElement("button");
    dockHandle.type = "button";
    dockHandle.className = "window-dock-handle";
    dockHandle.textContent = "\u{1F5C2}";
    dockHandle.addEventListener("click", () => {
      dock.classList.toggle("open");
    });
    dock.appendChild(dockHandle);
    dockList = document.createElement("div");
    dockList.className = "window-dock-list";
    dock.appendChild(dockList);
    document.body.appendChild(dock);
  }
  function bringToFront(win) {
    if (!win) return;
    zIndexCounter += 1;
    win.style.zIndex = zIndexCounter;
  }
  function setupDragging(win, header) {
    let active = null;
    header.addEventListener("mousedown", (e) => {
      if (e.target.closest("button")) return;
      active = {
        offsetX: e.clientX - win.offsetLeft,
        offsetY: e.clientY - win.offsetTop
      };
      bringToFront(win);
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", stopDrag);
      e.preventDefault();
    });
    function handleMove(e) {
      if (!active) return;
      const left = e.clientX - active.offsetX;
      const top = e.clientY - active.offsetY;
      win.style.left = `${left}px`;
      win.style.top = `${top}px`;
    }
    function stopDrag() {
      active = null;
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", stopDrag);
    }
  }
  function createFloatingWindow({ title, width = 520, onClose, onBeforeClose } = {}) {
    ensureDock();
    const releaseWindow = registerWindowPresence();
    let releasedWindow = false;
    function finalizeRelease() {
      if (releasedWindow) return;
      releasedWindow = true;
      releaseWindow();
    }
    const win = document.createElement("div");
    win.className = "floating-window";
    win.style.width = typeof width === "number" ? `${width}px` : width;
    win.style.left = `${120 + windows.size * 32}px`;
    win.style.top = `${100 + windows.size * 24}px`;
    bringToFront(win);
    const header = document.createElement("div");
    header.className = "floating-header";
    const titleEl = document.createElement("div");
    titleEl.className = "floating-title";
    titleEl.textContent = title || "Window";
    header.appendChild(titleEl);
    const actions = document.createElement("div");
    actions.className = "floating-actions";
    const minimizeBtn = document.createElement("button");
    minimizeBtn.type = "button";
    minimizeBtn.className = "floating-action";
    minimizeBtn.title = "Minimize";
    minimizeBtn.textContent = "\u2014";
    actions.appendChild(minimizeBtn);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "floating-action";
    closeBtn.title = "Close";
    closeBtn.textContent = "\xD7";
    actions.appendChild(closeBtn);
    function appendActionButton({
      text = "",
      icon,
      title: actionTitle = "",
      ariaLabel = "",
      className = "",
      onClick,
      position = "before-close"
    } = {}) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = ["floating-action", className].filter(Boolean).join(" ");
      if (icon) {
        btn.innerHTML = icon;
      } else {
        btn.textContent = text;
      }
      if (actionTitle) btn.title = actionTitle;
      if (ariaLabel || actionTitle) {
        btn.setAttribute("aria-label", ariaLabel || actionTitle);
      }
      if (typeof onClick === "function") {
        btn.addEventListener("click", onClick);
      }
      if (position === "start") {
        actions.insertBefore(btn, actions.firstChild || null);
      } else if (position === "end") {
        actions.appendChild(btn);
      } else if (position === "after-minimize") {
        if (minimizeBtn.nextSibling) {
          actions.insertBefore(btn, minimizeBtn.nextSibling);
        } else {
          actions.appendChild(btn);
        }
      } else if (position === "before-close" && closeBtn.parentElement === actions) {
        actions.insertBefore(btn, closeBtn);
      } else {
        actions.appendChild(btn);
      }
      return btn;
    }
    header.appendChild(actions);
    win.appendChild(header);
    const body = document.createElement("div");
    body.className = "floating-body";
    win.appendChild(body);
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "floating-resize-handle";
    win.appendChild(resizeHandle);
    const MIN_WIDTH = 320;
    const MIN_HEIGHT = 260;
    let resizeState = null;
    resizeHandle.addEventListener("pointerdown", (event) => {
      if (event.button !== 0) return;
      bringToFront(win);
      resizeState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        startWidth: win.offsetWidth,
        startHeight: win.offsetHeight,
        useGlobalEvents: typeof resizeHandle.setPointerCapture !== "function"
      };
      if (!resizeState.useGlobalEvents && typeof resizeHandle.setPointerCapture === "function") {
        resizeHandle.setPointerCapture(event.pointerId);
      }
      if (resizeState.useGlobalEvents) {
        window.addEventListener("pointermove", handlePointerMove);
        window.addEventListener("pointerup", stopResize);
        window.addEventListener("pointercancel", stopResize);
      }
      event.preventDefault();
    });
    const handlePointerMove = (event) => {
      if (!resizeState || event.pointerId !== resizeState.pointerId) return;
      const deltaX = event.clientX - resizeState.startX;
      const deltaY = event.clientY - resizeState.startY;
      const nextWidth = Math.max(MIN_WIDTH, resizeState.startWidth + deltaX);
      const nextHeight = Math.max(MIN_HEIGHT, resizeState.startHeight + deltaY);
      win.style.width = `${nextWidth}px`;
      win.style.height = `${nextHeight}px`;
    };
    const stopResize = (event) => {
      if (!resizeState || event.pointerId !== resizeState.pointerId) return;
      const state2 = resizeState;
      resizeState = null;
      if (!state2.useGlobalEvents && typeof resizeHandle.releasePointerCapture === "function") {
        resizeHandle.releasePointerCapture(event.pointerId);
      }
      if (state2.useGlobalEvents) {
        window.removeEventListener("pointermove", handlePointerMove);
        window.removeEventListener("pointerup", stopResize);
        window.removeEventListener("pointercancel", stopResize);
      }
    };
    resizeHandle.addEventListener("pointermove", handlePointerMove);
    resizeHandle.addEventListener("pointerup", stopResize);
    resizeHandle.addEventListener("pointercancel", stopResize);
    let minimized = false;
    let dockButton = null;
    function handleMinimize() {
      if (minimized) {
        restore();
        return;
      }
      minimized = true;
      win.classList.add("minimized");
      win.style.display = "none";
      dock.classList.add("open");
      dockButton = document.createElement("button");
      dockButton.type = "button";
      dockButton.className = "dock-entry";
      dockButton.textContent = titleEl.textContent;
      dockButton.addEventListener("click", () => restore());
      dockList.appendChild(dockButton);
    }
    function destroyDockButton() {
      if (dockButton && dockButton.parentElement) {
        dockButton.parentElement.removeChild(dockButton);
      }
      dockButton = null;
      if (!dockList.childElementCount) {
        dock.classList.remove("open");
      }
    }
    function restore() {
      if (!minimized) return;
      minimized = false;
      win.classList.remove("minimized");
      win.style.display = "";
      bringToFront(win);
      destroyDockButton();
    }
    minimizeBtn.addEventListener("click", handleMinimize);
    async function close(reason) {
      if (typeof onBeforeClose === "function") {
        try {
          const shouldClose = await onBeforeClose(reason);
          if (shouldClose === false) return false;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      destroyDockButton();
      windows.delete(win);
      if (win.parentElement) win.parentElement.removeChild(win);
      finalizeRelease();
      if (typeof onClose === "function") onClose(reason);
      return true;
    }
    closeBtn.addEventListener("click", () => {
      void close("close");
    });
    function isInteractiveTarget(target) {
      if (!(target instanceof HTMLElement)) return false;
      if (target.closest('input, textarea, select, [contenteditable="true"], button, label, .rich-editor-area')) {
        return true;
      }
      return false;
    }
    win.addEventListener("mousedown", (event) => {
      if (isInteractiveTarget(event.target)) {
        requestAnimationFrame(() => bringToFront(win));
        return;
      }
      bringToFront(win);
    });
    win.addEventListener("focusin", () => bringToFront(win));
    setupDragging(win, header);
    document.body.appendChild(win);
    windows.add(win);
    return {
      element: win,
      body,
      header,
      actions,
      setContent(node) {
        body.innerHTML = "";
        if (node) body.appendChild(node);
      },
      close,
      minimize: handleMinimize,
      restore,
      setTitle(text) {
        titleEl.textContent = text;
        if (dockButton) dockButton.textContent = text;
      },
      isMinimized() {
        return minimized;
      },
      focus() {
        bringToFront(win);
      },
      addAction: appendActionButton
    };
  }
  var windows, zIndexCounter, dock, dockList, dockHandle;
  var init_window_manager = __esm({
    "js/ui/components/window-manager.js"() {
      init_performance();
      windows = /* @__PURE__ */ new Set();
      zIndexCounter = 2e3;
    }
  });

  // js/ui/components/media-upload.js
  function clamp(value, min, max) {
    if (Number.isNaN(value)) return min;
    if (value < min) return min;
    if (value > max) return max;
    return value;
  }
  function sanitizeAspectRatio(ratio) {
    if (!Number.isFinite(ratio) || ratio <= 0) return 1;
    return clamp(ratio, 0.25, 4);
  }
  function toDataUrl(canvas, mimeType, quality) {
    try {
      return canvas.toDataURL(mimeType, quality);
    } catch (err) {
      console.error("Failed to export canvas", err);
      return canvas.toDataURL();
    }
  }
  function inferMimeFromDataUrl(src) {
    if (typeof src !== "string") return "";
    const match = src.match(/^data:([^;,]+)[;,]/i);
    return match ? match[1] : "";
  }
  function editImageSource(src, { altText = "", width, height, mimeType } = {}) {
    if (!src) {
      return Promise.reject(new Error("Image source is required."));
    }
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => {
        const options = {
          initialAlt: altText,
          initialWidth: typeof width === "number" && width > 0 ? width : void 0,
          initialHeight: typeof height === "number" && height > 0 ? height : void 0,
          mimeType: mimeType || inferMimeFromDataUrl(src) || "image/png"
        };
        try {
          openCropDialog({ image, file: null }, options).then(resolve).catch(reject);
        } catch (err) {
          reject(err);
        }
      };
      image.onerror = () => {
        reject(new Error("Failed to load image."));
      };
      try {
        if (!/^data:/i.test(src) && !/^blob:/i.test(src)) {
          image.crossOrigin = "anonymous";
        }
        image.src = src;
      } catch (err) {
        reject(err);
      }
    });
  }
  function openCropDialog({ image, file }, options = {}) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.className = "media-cropper-overlay";
      overlay.setAttribute("role", "dialog");
      overlay.setAttribute("aria-modal", "true");
      const dialog = document.createElement("div");
      dialog.className = "media-cropper-dialog";
      overlay.appendChild(dialog);
      const header = document.createElement("header");
      header.className = "media-cropper-header";
      const title = document.createElement("h3");
      title.textContent = "Upload image";
      header.appendChild(title);
      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.className = "icon-btn ghost media-cropper-close";
      closeBtn.title = "Cancel";
      closeBtn.textContent = "\u2715";
      header.appendChild(closeBtn);
      dialog.appendChild(header);
      const body = document.createElement("div");
      body.className = "media-cropper-body";
      dialog.appendChild(body);
      const preview = document.createElement("div");
      preview.className = "media-cropper-preview";
      const canvas = document.createElement("canvas");
      canvas.width = DEFAULT_FRAME_WIDTH;
      canvas.height = Math.round(DEFAULT_FRAME_WIDTH * 0.75);
      preview.appendChild(canvas);
      body.appendChild(preview);
      const controls = document.createElement("div");
      controls.className = "media-cropper-controls";
      body.appendChild(controls);
      const ratioRow = document.createElement("div");
      ratioRow.className = "media-cropper-row";
      const ratioLabel = document.createElement("label");
      ratioLabel.textContent = "Aspect ratio";
      const ratioSelect = document.createElement("select");
      ratioSelect.className = "media-cropper-select";
      const naturalRatio = sanitizeAspectRatio(image.naturalWidth / image.naturalHeight || 1);
      const ratioOptions = [
        { value: "original", label: "Original", ratio: naturalRatio },
        { value: "1:1", label: "Square", ratio: 1 },
        { value: "4:3", label: "4 : 3", ratio: 4 / 3 },
        { value: "3:4", label: "3 : 4", ratio: 3 / 4 },
        { value: "16:9", label: "16 : 9", ratio: 16 / 9 }
      ];
      ratioOptions.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        ratioSelect.appendChild(option);
      });
      ratioSelect.value = "original";
      ratioLabel.appendChild(ratioSelect);
      ratioRow.appendChild(ratioLabel);
      controls.appendChild(ratioRow);
      const zoomRow = document.createElement("div");
      zoomRow.className = "media-cropper-row media-cropper-zoom";
      const zoomLabel = document.createElement("span");
      zoomLabel.textContent = "Zoom";
      zoomRow.appendChild(zoomLabel);
      const zoomRange = document.createElement("input");
      zoomRange.type = "range";
      zoomRange.min = "1";
      zoomRange.max = "3";
      zoomRange.step = "0.01";
      zoomRange.value = "1";
      zoomRange.className = "media-cropper-zoom-range";
      zoomRow.appendChild(zoomRange);
      const zoomValue = document.createElement("span");
      zoomValue.className = "media-cropper-zoom-value";
      zoomValue.textContent = "100%";
      zoomRow.appendChild(zoomValue);
      controls.appendChild(zoomRow);
      const sizeRow = document.createElement("div");
      sizeRow.className = "media-cropper-row";
      const widthLabel = document.createElement("label");
      widthLabel.textContent = "Output width";
      const widthInput = document.createElement("input");
      widthInput.type = "number";
      widthInput.min = "64";
      const naturalWidth = Math.round(image.naturalWidth) || Math.round(image.width) || 1024;
      widthInput.max = String(Math.max(64, naturalWidth));
      const presetWidth = Math.round(options.initialWidth || 0);
      const defaultWidth = Math.min(960, naturalWidth || 960);
      widthInput.value = String(presetWidth > 0 ? Math.min(Math.max(64, presetWidth), Math.max(64, naturalWidth)) : defaultWidth);
      widthInput.className = "media-cropper-size-input";
      widthLabel.appendChild(widthInput);
      sizeRow.appendChild(widthLabel);
      const dimensions = document.createElement("span");
      dimensions.className = "media-cropper-dimensions";
      dimensions.textContent = "\xD7";
      sizeRow.appendChild(dimensions);
      controls.appendChild(sizeRow);
      const altRow = document.createElement("div");
      altRow.className = "media-cropper-row";
      const altLabel = document.createElement("label");
      altLabel.textContent = "Alt text";
      const altInput = document.createElement("input");
      altInput.type = "text";
      altInput.placeholder = "Describe the image";
      const defaultAlt = options.initialAlt != null && options.initialAlt !== "" ? options.initialAlt : (file?.name || "").replace(/\.[^.]+$/, "").replace(/[_-]+/g, " ").trim();
      altInput.value = defaultAlt;
      altInput.className = "media-cropper-alt-input";
      altLabel.appendChild(altInput);
      altRow.appendChild(altLabel);
      controls.appendChild(altRow);
      const actions = document.createElement("div");
      actions.className = "media-cropper-actions";
      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.className = "btn subtle";
      cancelBtn.textContent = "Cancel";
      const confirmBtn = document.createElement("button");
      confirmBtn.type = "button";
      confirmBtn.className = "btn";
      confirmBtn.textContent = "Insert image";
      actions.appendChild(cancelBtn);
      actions.appendChild(confirmBtn);
      dialog.appendChild(actions);
      document.body.appendChild(overlay);
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingQuality = "high";
      let aspectRatio = naturalRatio;
      let frameWidth = Math.min(DEFAULT_FRAME_WIDTH, presetWidth > 0 ? presetWidth : naturalWidth || DEFAULT_FRAME_WIDTH);
      if (!Number.isFinite(frameWidth) || frameWidth <= 0) frameWidth = DEFAULT_FRAME_WIDTH;
      let frameHeight = Math.max(120, Math.round(frameWidth / aspectRatio));
      let minZoom = 1;
      let zoom = 1;
      let offsetX = 0;
      let offsetY = 0;
      let dragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      function focusDefault() {
        requestAnimationFrame(() => {
          altInput.focus({ preventScroll: true });
        });
      }
      function updateCanvasSize() {
        frameHeight = Math.max(120, Math.round(frameWidth / aspectRatio));
        canvas.width = frameWidth;
        canvas.height = frameHeight;
        updateZoomBounds();
      }
      function updateZoomBounds() {
        const widthRatio = frameWidth / (image.naturalWidth || image.width || 1);
        const heightRatio = frameHeight / (image.naturalHeight || image.height || 1);
        const nextMin = sanitizeAspectRatio(Math.max(widthRatio, heightRatio));
        minZoom = nextMin;
        if (!Number.isFinite(zoom) || zoom < minZoom) {
          zoom = minZoom;
        }
        zoomRange.min = String(Math.max(0.1, minZoom));
        zoomRange.max = String(Math.max(minZoom * 4, minZoom + 0.5));
        if (Number(zoomRange.value) < minZoom) {
          zoomRange.value = String(minZoom);
        }
        render();
      }
      function clampOffsets() {
        const scaledWidth = (image.naturalWidth || image.width || frameWidth) * zoom;
        const scaledHeight = (image.naturalHeight || image.height || frameHeight) * zoom;
        const maxOffsetX = Math.max(0, (scaledWidth - frameWidth) / 2);
        const maxOffsetY = Math.max(0, (scaledHeight - frameHeight) / 2);
        offsetX = clamp(offsetX, -maxOffsetX, maxOffsetX);
        offsetY = clamp(offsetY, -maxOffsetY, maxOffsetY);
      }
      function getOutputWidth() {
        const raw = Number(widthInput.value);
        const maxWidth = Math.max(64, naturalWidth);
        if (!Number.isFinite(raw)) return Math.min(maxWidth, 960);
        return clamp(Math.round(raw), 64, maxWidth);
      }
      function updateMeta() {
        const zoomPercent = Math.round(zoom / minZoom * 100);
        zoomValue.textContent = `${zoomPercent}%`;
        const outWidth = getOutputWidth();
        const outHeight = Math.max(1, Math.round(outWidth / aspectRatio));
        dimensions.textContent = `${outWidth} \xD7 ${outHeight}`;
      }
      function render() {
        clampOffsets();
        ctx.fillStyle = "rgba(15, 23, 42, 0.88)";
        ctx.fillRect(0, 0, frameWidth, frameHeight);
        const drawWidth = (image.naturalWidth || image.width || frameWidth) * zoom;
        const drawHeight = (image.naturalHeight || image.height || frameHeight) * zoom;
        const originX = (frameWidth - drawWidth) / 2 + offsetX;
        const originY = (frameHeight - drawHeight) / 2 + offsetY;
        ctx.save();
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(image, originX, originY, drawWidth, drawHeight);
        ctx.restore();
        ctx.strokeStyle = "rgba(148, 163, 184, 0.65)";
        ctx.lineWidth = 1;
        ctx.strokeRect(0.5, 0.5, frameWidth - 1, frameHeight - 1);
        updateMeta();
      }
      function closeDialog(result) {
        window.removeEventListener("keydown", onKeyDown, true);
        overlay.remove();
        resolve(result || null);
      }
      function onKeyDown(event) {
        if (event.key === "Escape") {
          event.preventDefault();
          closeDialog(null);
        }
      }
      ratioSelect.addEventListener("change", () => {
        const selected = ratioOptions.find((opt) => opt.value === ratioSelect.value);
        aspectRatio = sanitizeAspectRatio(selected ? selected.ratio : naturalRatio);
        updateCanvasSize();
        render();
      });
      zoomRange.addEventListener("input", () => {
        const next = Number(zoomRange.value);
        if (!Number.isFinite(next)) return;
        const previous = zoom;
        zoom = Math.max(minZoom, next);
        if (previous > 0) {
          const scale = zoom / previous;
          offsetX *= scale;
          offsetY *= scale;
        }
        render();
      });
      widthInput.addEventListener("input", () => updateMeta());
      let activePointerId = null;
      canvas.style.touchAction = "none";
      canvas.addEventListener("pointerdown", (event) => {
        activePointerId = event.pointerId;
        dragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
        dragOffsetX = offsetX;
        dragOffsetY = offsetY;
        canvas.classList.add("dragging");
        try {
          canvas.setPointerCapture(event.pointerId);
        } catch (err) {
        }
      });
      const handlePointerEnd = (event) => {
        if (activePointerId !== null && event.pointerId !== activePointerId) return;
        dragging = false;
        canvas.classList.remove("dragging");
        try {
          canvas.releasePointerCapture(event.pointerId);
        } catch (err) {
        }
        activePointerId = null;
      };
      canvas.addEventListener("pointerup", handlePointerEnd);
      canvas.addEventListener("pointerleave", handlePointerEnd);
      canvas.addEventListener("pointermove", (event) => {
        if (!dragging) return;
        const dx = event.clientX - dragStartX;
        const dy = event.clientY - dragStartY;
        offsetX = dragOffsetX + dx;
        offsetY = dragOffsetY + dy;
        render();
      });
      cancelBtn.addEventListener("click", () => closeDialog(null));
      closeBtn.addEventListener("click", () => closeDialog(null));
      confirmBtn.addEventListener("click", () => {
        const exportCanvas = document.createElement("canvas");
        const outWidth = getOutputWidth();
        const outHeight = Math.max(1, Math.round(outWidth / aspectRatio));
        exportCanvas.width = outWidth;
        exportCanvas.height = outHeight;
        const exportCtx = exportCanvas.getContext("2d");
        exportCtx.imageSmoothingEnabled = true;
        exportCtx.imageSmoothingQuality = "high";
        const drawWidth = (image.naturalWidth || image.width || outWidth) * zoom;
        const drawHeight = (image.naturalHeight || image.height || outHeight) * zoom;
        const originX = (frameWidth - drawWidth) / 2 + offsetX;
        const originY = (frameHeight - drawHeight) / 2 + offsetY;
        const cropX = clamp(-originX / zoom, 0, image.naturalWidth || image.width || outWidth);
        const cropY = clamp(-originY / zoom, 0, image.naturalHeight || image.height || outHeight);
        const cropWidth = Math.min(frameWidth / zoom, image.naturalWidth || image.width || outWidth);
        const cropHeight = Math.min(frameHeight / zoom, image.naturalHeight || image.height || outHeight);
        exportCtx.drawImage(
          image,
          cropX,
          cropY,
          cropWidth,
          cropHeight,
          0,
          0,
          exportCanvas.width,
          exportCanvas.height
        );
        const preferredMime = options.mimeType || file?.type || "";
        const mime = /^image\/jpe?g$/i.test(preferredMime) ? "image/jpeg" : /^image\/png$/i.test(preferredMime) ? "image/png" : "image/png";
        const quality = mime === "image/jpeg" ? 0.92 : void 0;
        const dataUrl = toDataUrl(exportCanvas, mime, quality);
        const altText = altInput.value.trim();
        closeDialog({
          dataUrl,
          width: exportCanvas.width,
          height: exportCanvas.height,
          mimeType: mime,
          altText
        });
      });
      window.addEventListener("keydown", onKeyDown, true);
      updateCanvasSize();
      render();
      focusDefault();
    });
  }
  function readFileAsDataUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error || new Error("Failed to read file."));
      try {
        reader.readAsDataURL(file);
      } catch (err) {
        reject(err);
      }
    });
  }
  var DEFAULT_FRAME_WIDTH;
  var init_media_upload = __esm({
    "js/ui/components/media-upload.js"() {
      DEFAULT_FRAME_WIDTH = 520;
    }
  });

  // js/ui/components/rich-text.js
  function escapeHtml2(str = "") {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function decodeHtmlEntities(str = "") {
    if (!str) return "";
    if (!htmlEntityDecoder) return String(str);
    htmlEntityDecoder.innerHTML = str;
    return htmlEntityDecoder.value;
  }
  function clamp2(value, min, max) {
    const number = Number(value);
    if (!Number.isFinite(number)) return min;
    return Math.min(max, Math.max(min, number));
  }
  function ensureOcclusionId(box) {
    if (box && typeof box.id === "string" && box.id) {
      return box.id;
    }
    const rand = Math.random().toString(36).slice(2, 8);
    const stamp = Date.now().toString(36);
    return `occ-${stamp}-${rand}`;
  }
  function ensureAnnotationId(prefix, annotation) {
    if (annotation && typeof annotation.id === "string" && annotation.id) {
      return annotation.id;
    }
    const rand = Math.random().toString(36).slice(2, 8);
    const stamp = Date.now().toString(36);
    return `${prefix}-${stamp}-${rand}`;
  }
  function normalizeOcclusionBox(box) {
    if (!box || typeof box !== "object") return null;
    const id = ensureOcclusionId(box);
    const x = clamp2(box.x, 0, 1);
    const y = clamp2(box.y, 0, 1);
    const width = clamp2(box.width, 0, 1);
    const height = clamp2(box.height, 0, 1);
    if (width <= 0 || height <= 0) return null;
    const maxWidth = Math.max(0, 1 - x);
    const maxHeight = Math.max(0, 1 - y);
    const normalizedWidth = Math.min(width, maxWidth);
    const normalizedHeight = Math.min(height, maxHeight);
    if (normalizedWidth <= 0 || normalizedHeight <= 0) return null;
    return {
      id,
      x,
      y,
      width: normalizedWidth,
      height: normalizedHeight
    };
  }
  function parseImageOcclusions(image) {
    if (!(image instanceof HTMLImageElement)) return [];
    const attr = image.getAttribute(IMAGE_OCCLUSION_ATTR);
    if (!attr) return [];
    try {
      const parsed = JSON.parse(attr);
      if (!Array.isArray(parsed)) return [];
      return parsed.map(normalizeOcclusionBox).filter(Boolean);
    } catch (err) {
      console.warn("Failed to parse image occlusions", err);
      return [];
    }
  }
  function writeImageOcclusions(image, boxes) {
    if (!(image instanceof HTMLImageElement)) return [];
    const normalized2 = Array.isArray(boxes) ? boxes.map(normalizeOcclusionBox).filter(Boolean) : [];
    if (!normalized2.length) {
      image.removeAttribute(IMAGE_OCCLUSION_ATTR);
      return [];
    }
    image.setAttribute(IMAGE_OCCLUSION_ATTR, JSON.stringify(normalized2));
    return normalized2;
  }
  function sanitizeHighlightColor(value) {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    if (!trimmed) return null;
    if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(trimmed)) {
      return trimmed.length === 4 ? `#${trimmed[1]}${trimmed[1]}${trimmed[2]}${trimmed[2]}${trimmed[3]}${trimmed[3]}` : trimmed.toLowerCase();
    }
    const lower = trimmed.toLowerCase();
    const allowed = new Set(WORKSPACE_HIGHLIGHT_COLORS.map((color) => color.toLowerCase()));
    if (allowed.has(lower)) return lower;
    return null;
  }
  function highlightColorToRgba(color, alpha) {
    if (typeof color !== "string") return `rgba(250, 204, 21, ${alpha})`;
    const normalized2 = sanitizeHighlightColor(color) || WORKSPACE_HIGHLIGHT_COLORS[0];
    const hex = normalized2.replace("#", "");
    const value = hex.length === 3 ? `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}` : hex;
    const r = parseInt(value.slice(0, 2), 16);
    const g = parseInt(value.slice(2, 4), 16);
    const b = parseInt(value.slice(4, 6), 16);
    const safeAlpha = clamp2(alpha, 0, 1);
    return `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
  }
  function normalizeHighlightBox(box) {
    if (!box || typeof box !== "object") return null;
    const id = ensureAnnotationId("hlt", box);
    const x = clamp2(box.x, 0, 1);
    const y = clamp2(box.y, 0, 1);
    const width = clamp2(box.width, 0, 1);
    const height = clamp2(box.height, 0, 1);
    if (width <= 0 || height <= 0) return null;
    const maxWidth = Math.max(0, 1 - x);
    const maxHeight = Math.max(0, 1 - y);
    const normalizedWidth = Math.min(width, maxWidth);
    const normalizedHeight = Math.min(height, maxHeight);
    if (normalizedWidth <= 0 || normalizedHeight <= 0) return null;
    const color = sanitizeHighlightColor(box.color) || WORKSPACE_HIGHLIGHT_COLORS[0];
    return {
      id,
      x,
      y,
      width: normalizedWidth,
      height: normalizedHeight,
      color
    };
  }
  function parseImageHighlights(image) {
    if (!(image instanceof HTMLImageElement)) return [];
    const attr = image.getAttribute(IMAGE_HIGHLIGHT_ATTR);
    if (!attr) return [];
    try {
      const parsed = JSON.parse(attr);
      if (!Array.isArray(parsed)) return [];
      return parsed.map(normalizeHighlightBox).filter(Boolean);
    } catch (err) {
      console.warn("Failed to parse image highlights", err);
      return [];
    }
  }
  function writeImageHighlights(image, boxes) {
    if (!(image instanceof HTMLImageElement)) return [];
    const normalized2 = Array.isArray(boxes) ? boxes.map(normalizeHighlightBox).filter(Boolean) : [];
    if (!normalized2.length) {
      image.removeAttribute(IMAGE_HIGHLIGHT_ATTR);
      return [];
    }
    image.setAttribute(IMAGE_HIGHLIGHT_ATTR, JSON.stringify(normalized2));
    return normalized2;
  }
  function sanitizeTextboxContent(value) {
    const plain = sanitizeToPlainText(String(value || ""));
    if (!plain) return "";
    return plain.slice(0, 1e3);
  }
  function normalizeTextbox(box) {
    if (!box || typeof box !== "object") return null;
    const id = ensureAnnotationId("txt", box);
    const x = clamp2(box.x, 0, 1);
    const y = clamp2(box.y, 0, 1);
    const width = clamp2(box.width, 0, 1);
    const height = clamp2(box.height, 0, 1);
    if (width <= 0 || height <= 0) return null;
    const maxWidth = Math.max(0, 1 - x);
    const maxHeight = Math.max(0, 1 - y);
    const normalizedWidth = Math.min(width, maxWidth);
    const normalizedHeight = Math.min(height, maxHeight);
    if (normalizedWidth <= 0 || normalizedHeight <= 0) return null;
    const text = sanitizeTextboxContent(box.text || "");
    return {
      id,
      x,
      y,
      width: normalizedWidth,
      height: normalizedHeight,
      text
    };
  }
  function parseImageTextboxes(image) {
    if (!(image instanceof HTMLImageElement)) return [];
    const attr = image.getAttribute(IMAGE_TEXTBOX_ATTR);
    if (!attr) return [];
    try {
      const parsed = JSON.parse(attr);
      if (!Array.isArray(parsed)) return [];
      return parsed.map(normalizeTextbox).filter(Boolean);
    } catch (err) {
      console.warn("Failed to parse image text boxes", err);
      return [];
    }
  }
  function writeImageTextboxes(image, boxes) {
    if (!(image instanceof HTMLImageElement)) return [];
    const normalized2 = Array.isArray(boxes) ? boxes.map(normalizeTextbox).filter(Boolean) : [];
    if (!normalized2.length) {
      image.removeAttribute(IMAGE_TEXTBOX_ATTR);
      return [];
    }
    image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(normalized2));
    return normalized2;
  }
  function notifyImageOcclusionChange(image) {
    if (!(image instanceof HTMLImageElement)) return;
    try {
      image.dispatchEvent(new CustomEvent(IMAGE_OCCLUSION_EVENT, { bubbles: false }));
    } catch (err) {
    }
  }
  function computeImageDisplayMetrics(image) {
    if (!(image instanceof HTMLImageElement)) return null;
    const rect = image.getBoundingClientRect();
    const containerWidth = rect.width || image.clientWidth || image.offsetWidth || 0;
    const containerHeight = rect.height || image.clientHeight || image.offsetHeight || 0;
    const naturalWidth = image.naturalWidth || containerWidth;
    const naturalHeight = image.naturalHeight || containerHeight;
    if (containerWidth <= 0 || containerHeight <= 0 || naturalWidth <= 0 || naturalHeight <= 0) {
      return {
        offsetX: 0,
        offsetY: 0,
        width: containerWidth,
        height: containerHeight
      };
    }
    const containerRatio = containerWidth / containerHeight;
    const imageRatio = naturalWidth / naturalHeight;
    let drawnWidth = containerWidth;
    let drawnHeight = containerHeight;
    let offsetX = 0;
    let offsetY = 0;
    if (Math.abs(containerRatio - imageRatio) > 1e-4) {
      if (containerRatio > imageRatio) {
        drawnHeight = containerHeight;
        drawnWidth = drawnHeight * imageRatio;
        offsetX = (containerWidth - drawnWidth) / 2;
      } else {
        drawnWidth = containerWidth;
        drawnHeight = drawnWidth / imageRatio;
        offsetY = (containerHeight - drawnHeight) / 2;
      }
    }
    return {
      offsetX,
      offsetY,
      width: drawnWidth,
      height: drawnHeight
    };
  }
  function resolveImageMetrics(target) {
    if (!target) return null;
    if (target instanceof HTMLImageElement) {
      return computeImageDisplayMetrics(target);
    }
    if (typeof target === "object" && target) {
      const width = Number(target.width);
      const height = Number(target.height);
      if (Number.isFinite(width) && width > 0 && Number.isFinite(height) && height > 0) {
        const offsetX = Number(target.offsetX) || 0;
        const offsetY = Number(target.offsetY) || 0;
        return { offsetX, offsetY, width, height };
      }
    }
    return null;
  }
  function applyOcclusionBoxGeometry(element, box, target) {
    if (!element || !box) return;
    const metrics = resolveImageMetrics(target);
    if (metrics && metrics.width > 0 && metrics.height > 0) {
      const left = metrics.offsetX + clamp2(box.x, 0, 1) * metrics.width;
      const top = metrics.offsetY + clamp2(box.y, 0, 1) * metrics.height;
      const width = clamp2(box.width, 0, 1) * metrics.width;
      const height = clamp2(box.height, 0, 1) * metrics.height;
      element.style.left = `${left}px`;
      element.style.top = `${top}px`;
      element.style.width = `${width}px`;
      element.style.height = `${height}px`;
      return;
    }
    element.style.left = `${box.x * 100}%`;
    element.style.top = `${box.y * 100}%`;
    element.style.width = `${box.width * 100}%`;
    element.style.height = `${box.height * 100}%`;
  }
  function getImageContentRect(image) {
    if (!(image instanceof HTMLImageElement)) return null;
    const rect = image.getBoundingClientRect();
    const metrics = computeImageDisplayMetrics(image);
    if (!metrics) return rect;
    const left = rect.left + metrics.offsetX;
    const top = rect.top + metrics.offsetY;
    return {
      left,
      top,
      width: metrics.width,
      height: metrics.height,
      right: left + metrics.width,
      bottom: top + metrics.height
    };
  }
  function setOcclusionRevealState(element, revealed) {
    if (!element) return;
    const isRevealed = revealed === true;
    element.classList.toggle("is-revealed", isRevealed);
    element.setAttribute("aria-pressed", isRevealed ? "true" : "false");
  }
  function isSafeUrl(value = "", { allowData = false, requireHttps = false } = {}) {
    const trimmed = value.trim();
    if (!trimmed) return false;
    if (/^javascript:/i.test(trimmed)) return false;
    if (!allowData && /^data:/i.test(trimmed)) return false;
    if (/^blob:/i.test(trimmed)) return true;
    if (requireHttps) {
      if (trimmed.startsWith("//")) return true;
      if (trimmed.startsWith("/") || trimmed.startsWith("./") || trimmed.startsWith("../")) return true;
      if (/^https:/i.test(trimmed)) return true;
      return false;
    }
    return true;
  }
  function cleanStyles(node) {
    const style = node.getAttribute("style");
    if (!style) return;
    const cleaned = style.split(";").map((part) => part.trim()).filter(Boolean).map((part) => {
      const [rawProp, ...valueParts] = part.split(":");
      if (!rawProp || !valueParts.length) return null;
      const prop = rawProp.trim().toLowerCase();
      if (!allowedStyles.has(prop)) return null;
      return `${prop}: ${valueParts.join(":").trim()}`;
    }).filter(Boolean).join("; ");
    if (cleaned) node.setAttribute("style", cleaned);
    else node.removeAttribute("style");
  }
  function sanitizeNode(node) {
    if (node.nodeType === Node.TEXT_NODE) return;
    if (node.nodeType === Node.COMMENT_NODE) {
      node.remove();
      return;
    }
    const tag = node.tagName?.toLowerCase();
    if (!tag) return;
    if (!allowedTags.has(tag)) {
      if (node.childNodes.length) {
        const parent = node.parentNode;
        while (node.firstChild) parent.insertBefore(node.firstChild, node);
        node.remove();
      } else {
        node.remove();
      }
      return;
    }
    const attrs = Array.from(node.attributes || []);
    const allowList = allowedAttributes[tag] || [];
    attrs.forEach((attr) => {
      const name = attr.name.toLowerCase();
      if (name === "style") {
        cleanStyles(node);
        return;
      }
      if (!allowList.includes(name)) {
        node.removeAttribute(attr.name);
        return;
      }
      if (tag === "a" && name === "href") {
        const value = attr.value.trim();
        if (!value || value.startsWith("javascript:")) {
          node.removeAttribute(attr.name);
        } else {
          node.setAttribute("target", "_blank");
          node.setAttribute("rel", "noopener noreferrer");
        }
      }
      if (name === "src" && ["img", "video", "audio", "source", "iframe"].includes(tag)) {
        const allowData = tag === "img" || tag === "video" || tag === "audio" || tag === "source";
        const requireHttps = tag === "iframe";
        if (!isSafeUrl(attr.value || "", { allowData, requireHttps })) {
          node.removeAttribute(attr.name);
        }
      }
    });
    Array.from(node.childNodes).forEach(sanitizeNode);
  }
  function createClozeSpan(content) {
    const span = document.createElement("span");
    span.setAttribute(CLOZE_ATTR, CLOZE_VALUE);
    span.textContent = content;
    return span;
  }
  function upgradeClozeSyntax(root2) {
    if (!root2) return;
    const braceRegex = /\{([^{}]+)\}/g;
    const walker = document.createTreeWalker(
      root2,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          if (!node?.nodeValue || node.nodeValue.indexOf("{") === -1) {
            return NodeFilter.FILTER_SKIP;
          }
          if (node.parentElement?.closest(CLOZE_SELECTOR)) {
            return NodeFilter.FILTER_SKIP;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    const targets = [];
    while (walker.nextNode()) targets.push(walker.currentNode);
    targets.forEach((node) => {
      const text = node.nodeValue || "";
      let match;
      braceRegex.lastIndex = 0;
      let lastIndex = 0;
      let replaced = false;
      const fragment = document.createDocumentFragment();
      while (match = braceRegex.exec(text)) {
        const before = text.slice(lastIndex, match.index);
        if (before) fragment.appendChild(document.createTextNode(before));
        const inner = match[1];
        const trimmed = inner.trim();
        if (trimmed) {
          fragment.appendChild(createClozeSpan(trimmed));
          replaced = true;
        } else {
          fragment.appendChild(document.createTextNode(match[0]));
        }
        lastIndex = match.index + match[0].length;
      }
      if (!replaced) return;
      const after = text.slice(lastIndex);
      if (after) fragment.appendChild(document.createTextNode(after));
      const parent = node.parentNode;
      if (!parent) return;
      parent.insertBefore(fragment, node);
      parent.removeChild(node);
    });
  }
  function sanitizeHtml(html = "") {
    const template = document.createElement("template");
    template.innerHTML = html;
    Array.from(template.content.childNodes).forEach(sanitizeNode);
    upgradeClozeSyntax(template.content);
    return template.innerHTML;
  }
  function sanitizeToPlainText(html = "") {
    if (!html) return "";
    const template = document.createElement("template");
    template.innerHTML = sanitizeHtml(html);
    const text = template.content.textContent || "";
    return text.replace(/\u00a0/g, " ");
  }
  function htmlToPlainText(html = "") {
    return sanitizeToPlainText(html);
  }
  function normalizeInput(value = "") {
    if (value == null) return "";
    const str = String(value);
    if (!str) return "";
    const looksHtml = /<([a-z][^>]*>)/i.test(str);
    if (looksHtml) return sanitizeHtml(str);
    const decoded = decodeHtmlEntities(str);
    return sanitizeHtml(escapeHtml2(decoded).replace(/\r?\n/g, "<br>"));
  }
  function isEmptyHtml(html = "") {
    if (!html) return true;
    const template = document.createElement("template");
    template.innerHTML = html;
    const hasMedia = template.content.querySelector("img,video,audio,iframe");
    const text = template.content.textContent?.replace(/\u00a0/g, " ").trim();
    return !hasMedia && !text;
  }
  function createToolbarButton(label, title, onClick) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "rich-editor-btn";
    btn.textContent = label;
    btn.title = title;
    btn.setAttribute("aria-label", title);
    btn.dataset.toggle = "true";
    btn.dataset.active = "false";
    btn.setAttribute("aria-pressed", "false");
    btn.addEventListener("mousedown", (e) => e.preventDefault());
    btn.addEventListener("click", onClick);
    return btn;
  }
  function createRichTextEditor({ value = "", onChange, ariaLabel, ariaLabelledBy } = {}) {
    const wrapper = document.createElement("div");
    wrapper.className = "rich-editor";
    const toolbar = document.createElement("div");
    toolbar.className = "rich-editor-toolbar";
    toolbar.setAttribute("role", "toolbar");
    toolbar.setAttribute("aria-label", "Text formatting toolbar");
    wrapper.appendChild(toolbar);
    const imageFileInput = document.createElement("input");
    imageFileInput.type = "file";
    imageFileInput.accept = "image/*";
    imageFileInput.style.display = "none";
    wrapper.appendChild(imageFileInput);
    const mediaFileInput = document.createElement("input");
    mediaFileInput.type = "file";
    mediaFileInput.accept = "video/*,audio/*";
    mediaFileInput.style.display = "none";
    wrapper.appendChild(mediaFileInput);
    let pendingImageTarget = null;
    let activeImageEditor = null;
    let occlusionDisplayManager = null;
    function loadImageDimensions(dataUrl) {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
          resolve({
            width: image.naturalWidth || image.width || 0,
            height: image.naturalHeight || image.height || 0
          });
        };
        image.onerror = () => reject(new Error("Failed to load image preview."));
        image.src = dataUrl;
      });
    }
    function sanitizeImageDimension(value2) {
      if (!Number.isFinite(value2)) return null;
      const MIN_SIZE = 32;
      const MAX_SIZE = 4096;
      const clamped = Math.max(MIN_SIZE, Math.min(MAX_SIZE, Math.round(value2)));
      return clamped > 0 ? clamped : null;
    }
    function dataUrlToBlob(dataUrl) {
      if (typeof dataUrl !== "string" || !dataUrl.startsWith("data:")) return null;
      const parts = dataUrl.split(",");
      if (parts.length < 2) return null;
      const meta = parts[0];
      const base64 = parts.slice(1).join(",");
      const mimeMatch = meta.match(/data:([^;]+)/);
      const mime = mimeMatch ? mimeMatch[1] : "image/png";
      try {
        const binary = atob(base64);
        const len = binary.length;
        const buffer = new Uint8Array(len);
        for (let i = 0; i < len; i += 1) {
          buffer[i] = binary.charCodeAt(i);
        }
        return new Blob([buffer], { type: mime });
      } catch (err) {
        console.warn("Failed to convert image for clipboard", err);
        return null;
      }
    }
    async function resolveImageBlob(image) {
      if (!(image instanceof HTMLImageElement)) return null;
      const src = image.getAttribute("src") || "";
      if (!src) return null;
      if (src.startsWith("data:")) {
        return dataUrlToBlob(src);
      }
      try {
        const response = await fetch(src);
        if (!response.ok) return null;
        return await response.blob();
      } catch (err) {
        console.warn("Failed to read image for clipboard", err);
        return null;
      }
    }
    async function insertImageFile(file, targetImage = null) {
      if (!(file instanceof File)) return;
      try {
        const dataUrl = await readFileAsDataUrl(file);
        if (!dataUrl) return;
        let dimensions = { width: null, height: null };
        try {
          dimensions = await loadImageDimensions(dataUrl);
        } catch (err) {
          dimensions = { width: null, height: null };
        }
        const width = sanitizeImageDimension(dimensions.width);
        const height = sanitizeImageDimension(dimensions.height);
        const defaultAlt = (file.name || "").replace(/\.[^.]+$/, "").replace(/[_-]+/g, " ").trim();
        if (targetImage && wrapper.contains(targetImage)) {
          const existingAlt = targetImage.getAttribute("alt") || "";
          const altText = existingAlt.trim() || defaultAlt;
          targetImage.src = dataUrl;
          if (altText) {
            targetImage.setAttribute("alt", altText);
          } else {
            targetImage.removeAttribute("alt");
          }
          setImageSize(targetImage, width, height);
          writeImageOcclusions(targetImage, []);
          notifyImageOcclusionChange(targetImage);
          if (occlusionDisplayManager) occlusionDisplayManager.notifyChange(targetImage);
          triggerEditorChange();
          if (activeImageEditor && activeImageEditor.image === targetImage && typeof activeImageEditor.update === "function") {
            requestAnimationFrame(() => activeImageEditor.update());
          }
        } else {
          const safeAlt = defaultAlt ? escapeHtml2(defaultAlt) : "";
          const altAttr = safeAlt ? ` alt="${safeAlt}"` : "";
          const widthAttr = width ? ` width="${width}"` : "";
          const heightAttr = height ? ` height="${height}"` : "";
          const html = `<img src="${dataUrl}"${widthAttr}${heightAttr}${altAttr}>`;
          insertHtml(html);
        }
      } catch (err) {
        console.error("Failed to upload image", err);
      }
    }
    async function insertMediaFile(file) {
      try {
        const dataUrl = await readFileAsDataUrl(file);
        if (!dataUrl) return;
        const isAudio = file.type?.startsWith("audio/");
        if (isAudio) {
          insertHtml(`<audio controls preload="metadata" src="${dataUrl}"></audio>`);
        } else {
          insertHtml(`<video controls preload="metadata" src="${dataUrl}" width="640"></video>`);
        }
      } catch (err) {
        console.error("Failed to add media file", err);
      }
    }
    imageFileInput.addEventListener("change", () => {
      const file = imageFileInput.files?.[0];
      const target = pendingImageTarget;
      pendingImageTarget = null;
      if (file) insertImageFile(file, target);
      imageFileInput.value = "";
    });
    mediaFileInput.addEventListener("change", () => {
      const file = mediaFileInput.files?.[0];
      if (file) insertMediaFile(file);
      mediaFileInput.value = "";
    });
    const editable = document.createElement("div");
    editable.className = "rich-editor-area input";
    editable.contentEditable = "true";
    editable.spellcheck = true;
    editable.innerHTML = normalizeInput(value);
    if (ariaLabel) editable.setAttribute("aria-label", ariaLabel);
    if (ariaLabelledBy) editable.setAttribute("aria-labelledby", ariaLabelledBy);
    wrapper.appendChild(editable);
    editable.addEventListener("paste", (event) => {
      if (!event.clipboardData) return;
      const files = Array.from(event.clipboardData.files || []);
      const imageFile = files.find((file) => file && file.type && file.type.startsWith("image/")) || null;
      if (imageFile) {
        event.preventDefault();
        void insertImageFile(imageFile);
        return;
      }
      const mediaFile = files.find((file) => file && file.type && (file.type.startsWith("video/") || file.type.startsWith("audio/")));
      if (mediaFile) {
        event.preventDefault();
        void insertMediaFile(mediaFile);
        return;
      }
      const html = event.clipboardData.getData("text/html");
      let text = event.clipboardData.getData("text/plain");
      if (!text && html) {
        text = sanitizeToPlainText(html);
      }
      event.preventDefault();
      insertPlainText(text || "");
    });
    editable.addEventListener("copy", async (event) => {
      try {
        if (!event.clipboardData) return;
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        if (!editable.contains(range.startContainer) || !editable.contains(range.endContainer)) {
          return;
        }
        const fragment = range.cloneContents();
        if (!fragment || fragment.childNodes.length === 0) return;
        const container = document.createElement("div");
        container.appendChild(fragment);
        const images = Array.from(container.querySelectorAll("img"));
        if (!images.length) return;
        event.preventDefault();
        const plain = selection.toString();
        event.clipboardData.setData("text/plain", plain || "");
        event.clipboardData.setData("text/html", container.innerHTML);
        if (navigator.clipboard?.write && typeof ClipboardItem === "function") {
          const blob = await resolveImageBlob(images[0]);
          if (blob) {
            try {
              await navigator.clipboard.write([
                new ClipboardItem({ [blob.type || "image/png"]: blob })
              ]);
            } catch (err) {
              console.warn("Failed to write image to clipboard", err);
            }
          }
        }
      } catch (err) {
        console.warn("Failed to process copy event", err);
      }
    });
    occlusionDisplayManager = createEditorOcclusionDisplayManager(wrapper, editable, beginImageEditing);
    function triggerEditorChange() {
      editable.dispatchEvent(new Event("input", { bubbles: true }));
    }
    function setImageSize(image, width, height) {
      if (!(image instanceof HTMLImageElement)) return;
      const MIN_SIZE = 32;
      const MAX_SIZE = 4096;
      const widthValue = Number.isFinite(width) ? Math.max(MIN_SIZE, Math.min(MAX_SIZE, Math.round(width))) : null;
      const heightValue = Number.isFinite(height) ? Math.max(MIN_SIZE, Math.min(MAX_SIZE, Math.round(height))) : null;
      if (widthValue) {
        image.style.width = `${widthValue}px`;
        image.setAttribute("width", String(widthValue));
      } else {
        image.style.removeProperty("width");
        image.removeAttribute("width");
      }
      if (heightValue) {
        image.style.height = `${heightValue}px`;
        image.setAttribute("height", String(heightValue));
      } else {
        image.style.removeProperty("height");
        image.removeAttribute("height");
      }
    }
    function destroyActiveImageEditor() {
      if (activeImageEditor && typeof activeImageEditor.destroy === "function") {
        activeImageEditor.destroy();
      }
      activeImageEditor = null;
    }
    function beginImageEditing(image) {
      if (!(image instanceof HTMLImageElement)) return;
      if (!wrapper.contains(image)) return;
      if (activeImageEditor && activeImageEditor.image === image) {
        if (typeof activeImageEditor.update === "function") {
          requestAnimationFrame(() => activeImageEditor.update());
        }
        return;
      }
      destroyActiveImageEditor();
      activeImageEditor = createImageEditor(image);
      if (activeImageEditor && typeof activeImageEditor.update === "function") {
        requestAnimationFrame(() => activeImageEditor.update());
      }
    }
    function createImageEditor(image) {
      const overlay = document.createElement("div");
      overlay.className = "rich-editor-image-overlay";
      overlay.setAttribute("aria-hidden", "true");
      const toolbar2 = document.createElement("div");
      toolbar2.className = "rich-editor-image-toolbar";
      const cropBtn = document.createElement("button");
      cropBtn.type = "button";
      cropBtn.className = "rich-editor-image-tool";
      cropBtn.textContent = "Crop";
      const replaceBtn = document.createElement("button");
      replaceBtn.type = "button";
      replaceBtn.className = "rich-editor-image-tool";
      replaceBtn.textContent = "Replace";
      const doneBtn = document.createElement("button");
      doneBtn.type = "button";
      doneBtn.className = "rich-editor-image-tool rich-editor-image-tool--primary";
      doneBtn.textContent = "Done";
      toolbar2.append(cropBtn, replaceBtn, doneBtn);
      overlay.appendChild(toolbar2);
      const occlusionToggle = document.createElement("button");
      occlusionToggle.type = "button";
      occlusionToggle.className = "rich-editor-image-occlude";
      occlusionToggle.setAttribute("aria-label", "Edit image occlusions");
      occlusionToggle.setAttribute("aria-pressed", "false");
      occlusionToggle.title = "Edit image occlusions";
      occlusionToggle.innerHTML = "\u{1F441}";
      occlusionToggle.dataset.active = "false";
      overlay.appendChild(occlusionToggle);
      let resizeState = null;
      const handleOcclusionGeometryChange = () => {
        occlusionDisplayManager?.notifyChange(image);
        requestAnimationFrame(() => update());
      };
      const occlusionEditor = createImageOcclusionEditor(handleOcclusionGeometryChange);
      occlusionToggle.addEventListener("click", (event) => {
        event.preventDefault();
        occlusionEditor.activate();
      });
      const handleDefs = [
        { name: "se", axis: "both", label: "Resize from corner" },
        { name: "e", axis: "x", label: "Resize width" },
        { name: "s", axis: "y", label: "Resize height" }
      ];
      const onPointerMove = (event) => {
        if (!resizeState) return;
        event.preventDefault();
        const dx = event.clientX - resizeState.startX;
        const dy = event.clientY - resizeState.startY;
        let nextWidth = resizeState.startWidth;
        let nextHeight = resizeState.startHeight;
        if (resizeState.axis === "both" || resizeState.axis === "x") {
          nextWidth = resizeState.startWidth + dx;
        }
        if (resizeState.axis === "both" || resizeState.axis === "y") {
          nextHeight = resizeState.startHeight + dy;
        }
        if (resizeState.keepRatio && resizeState.ratio > 0) {
          if (resizeState.axis === "x") {
            nextHeight = nextWidth / resizeState.ratio;
          } else if (resizeState.axis === "y") {
            nextWidth = nextHeight * resizeState.ratio;
          } else {
            if (Math.abs(dx) >= Math.abs(dy)) {
              nextHeight = nextWidth / resizeState.ratio;
            } else {
              nextWidth = nextHeight * resizeState.ratio;
            }
          }
        }
        setImageSize(image, nextWidth, nextHeight);
        requestAnimationFrame(() => update());
      };
      const stopResize = () => {
        if (!resizeState) return;
        window.removeEventListener("pointermove", onPointerMove);
        window.removeEventListener("pointerup", stopResize);
        window.removeEventListener("pointercancel", stopResize);
        if (resizeState.handle && resizeState.pointerId != null) {
          try {
            resizeState.handle.releasePointerCapture(resizeState.pointerId);
          } catch (err) {
          }
        }
        overlay.classList.remove("is-resizing");
        resizeState = null;
        triggerEditorChange();
        requestAnimationFrame(() => update());
      };
      handleDefs.forEach((def) => {
        const handle = document.createElement("button");
        handle.type = "button";
        handle.className = `rich-editor-image-handle rich-editor-image-handle--${def.name}`;
        handle.setAttribute("aria-label", def.label);
        handle.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          const rect = image.getBoundingClientRect();
          resizeState = {
            axis: def.axis,
            startX: event.clientX,
            startY: event.clientY,
            startWidth: rect.width,
            startHeight: rect.height,
            ratio: rect.height > 0 ? rect.width / rect.height : 1,
            keepRatio: event.shiftKey,
            pointerId: event.pointerId,
            handle
          };
          overlay.classList.add("is-resizing");
          try {
            handle.setPointerCapture(event.pointerId);
          } catch (err) {
          }
          window.addEventListener("pointermove", onPointerMove);
          window.addEventListener("pointerup", stopResize);
          window.addEventListener("pointercancel", stopResize);
        });
        overlay.appendChild(handle);
      });
      wrapper.appendChild(overlay);
      occlusionDisplayManager?.suppress(image, true);
      image.classList.add("rich-editor-image-active");
      const update = () => {
        if (!document.body.contains(image)) {
          destroy();
          return;
        }
        const rect = image.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();
        overlay.style.width = `${rect.width}px`;
        overlay.style.height = `${rect.height}px`;
        overlay.style.left = `${rect.left - wrapperRect.left}px`;
        overlay.style.top = `${rect.top - wrapperRect.top}px`;
        occlusionEditor.update();
      };
      const onScroll = () => update();
      const onKeyDown = (event) => {
        if (event.key === "Escape") {
          if (occlusionEditor.isActive()) {
            event.preventDefault();
            occlusionToggle.focus();
            return;
          }
          event.preventDefault();
          destroy();
        }
      };
      const handleOutside = (event) => {
        const target = event.target;
        if (target === image) return;
        if (target instanceof Node && overlay.contains(target)) return;
        if (target instanceof Element && target.closest(".image-occlusion-modal")) return;
        destroy();
      };
      const resizeObserver = typeof ResizeObserver === "function" ? new ResizeObserver(() => update()) : null;
      if (resizeObserver) {
        try {
          resizeObserver.observe(image);
        } catch (err) {
        }
      }
      function createImageOcclusionEditor(onGeometryChange) {
        const highlightLayer = document.createElement("div");
        highlightLayer.className = "image-annotation-layer image-highlight-layer";
        highlightLayer.setAttribute("aria-hidden", "true");
        overlay.appendChild(highlightLayer);
        const textLayer = document.createElement("div");
        textLayer.className = "image-annotation-layer image-text-layer";
        textLayer.setAttribute("aria-hidden", "true");
        overlay.appendChild(textLayer);
        const layer = document.createElement("div");
        layer.className = "rich-editor-image-occlusion-layer";
        layer.setAttribute("aria-hidden", "true");
        overlay.appendChild(layer);
        const boxElements = /* @__PURE__ */ new Map();
        const highlightElements = /* @__PURE__ */ new Map();
        const textboxElements = /* @__PURE__ */ new Map();
        const revealStates = /* @__PURE__ */ new Map();
        let active = false;
        let drawing = null;
        let highlightDrawing = null;
        let textboxDrawing = null;
        let textboxManipulation = null;
        let workspace = null;
        let activeWorkspaceTool = "occlusion";
        let highlightColorIndex = 0;
        const MIN_PIXEL_SIZE = 8;
        const getCurrentHighlightColor = () => {
          const index = highlightColorIndex % WORKSPACE_HIGHLIGHT_COLORS.length;
          return WORKSPACE_HIGHLIGHT_COLORS[index];
        };
        const cycleHighlightColor = () => {
          highlightColorIndex = (highlightColorIndex + 1) % WORKSPACE_HIGHLIGHT_COLORS.length;
          if (workspace && typeof workspace.updateHighlightSwatch === "function") {
            workspace.updateHighlightSwatch();
          }
        };
        const setWorkspaceTool = (tool) => {
          activeWorkspaceTool = tool;
          if (workspace && typeof workspace.setTool === "function") {
            workspace.setTool(tool);
          }
        };
        function createWorkspace() {
          const workspaceOverlay = document.createElement("div");
          workspaceOverlay.className = "image-occlusion-modal";
          workspaceOverlay.setAttribute("aria-hidden", "true");
          workspaceOverlay.setAttribute("role", "dialog");
          workspaceOverlay.setAttribute("aria-modal", "true");
          workspaceOverlay.setAttribute("aria-label", "Image occlusion editor");
          workspaceOverlay.tabIndex = -1;
          const backdrop = document.createElement("div");
          backdrop.className = "image-occlusion-modal-backdrop";
          workspaceOverlay.appendChild(backdrop);
          const surface = document.createElement("div");
          surface.className = "image-occlusion-modal-surface";
          workspaceOverlay.appendChild(surface);
          const toolbar3 = document.createElement("div");
          toolbar3.className = "image-occlusion-modal-toolbar";
          surface.appendChild(toolbar3);
          const toolButtons = document.createElement("div");
          toolButtons.className = "image-occlusion-toolbar-buttons";
          toolbar3.appendChild(toolButtons);
          const canvas = document.createElement("div");
          canvas.className = "image-occlusion-modal-canvas";
          surface.appendChild(canvas);
          const editingImage = image.cloneNode(true);
          editingImage.removeAttribute("width");
          editingImage.removeAttribute("height");
          editingImage.classList.add("image-occlusion-modal-img");
          canvas.appendChild(editingImage);
          const workspaceHighlightLayer = document.createElement("div");
          workspaceHighlightLayer.className = "image-annotation-layer image-highlight-layer";
          workspaceHighlightLayer.setAttribute("aria-hidden", "true");
          canvas.appendChild(workspaceHighlightLayer);
          const workspaceTextLayer = document.createElement("div");
          workspaceTextLayer.className = "image-annotation-layer image-text-layer";
          workspaceTextLayer.setAttribute("aria-hidden", "true");
          canvas.appendChild(workspaceTextLayer);
          const workspaceLayer = document.createElement("div");
          workspaceLayer.className = "image-occlusion-layer";
          workspaceLayer.setAttribute("aria-hidden", "true");
          canvas.appendChild(workspaceLayer);
          const occlusionToolBtn = document.createElement("button");
          occlusionToolBtn.type = "button";
          occlusionToolBtn.className = "image-workspace-tool";
          occlusionToolBtn.title = "Draw a new occlusion";
          occlusionToolBtn.setAttribute("aria-label", "Draw occlusion");
          occlusionToolBtn.setAttribute("aria-pressed", "false");
          const occlusionIcon = document.createElement("span");
          occlusionIcon.className = "image-workspace-tool-icon";
          occlusionIcon.textContent = "\u{1F441}";
          occlusionToolBtn.appendChild(occlusionIcon);
          const occlusionLabel = document.createElement("span");
          occlusionLabel.className = "image-workspace-tool-label";
          occlusionLabel.textContent = "Occlusion";
          occlusionToolBtn.appendChild(occlusionLabel);
          toolButtons.appendChild(occlusionToolBtn);
          const highlightToolBtn = document.createElement("button");
          highlightToolBtn.type = "button";
          highlightToolBtn.className = "image-workspace-tool image-workspace-tool--highlight";
          highlightToolBtn.title = "Highlight an area (double-click to cycle colors)";
          highlightToolBtn.setAttribute("aria-label", "Highlight area");
          highlightToolBtn.setAttribute("aria-pressed", "false");
          const highlightIcon = document.createElement("span");
          highlightIcon.className = "image-workspace-tool-icon";
          highlightIcon.textContent = "\u{1F58D}";
          highlightToolBtn.appendChild(highlightIcon);
          const highlightLabel = document.createElement("span");
          highlightLabel.className = "image-workspace-tool-label";
          highlightLabel.textContent = "Highlight";
          highlightToolBtn.appendChild(highlightLabel);
          const highlightSwatch = document.createElement("span");
          highlightSwatch.className = "image-workspace-tool-swatch";
          highlightToolBtn.appendChild(highlightSwatch);
          toolButtons.appendChild(highlightToolBtn);
          const textToolBtn = document.createElement("button");
          textToolBtn.type = "button";
          textToolBtn.className = "image-workspace-tool image-workspace-tool--text";
          textToolBtn.title = "Add a text note";
          textToolBtn.setAttribute("aria-label", "Text note tool");
          textToolBtn.setAttribute("aria-pressed", "false");
          const textIcon = document.createElement("span");
          textIcon.className = "image-workspace-tool-icon";
          textIcon.textContent = "\u{1F4DD}";
          textToolBtn.appendChild(textIcon);
          const textLabel = document.createElement("span");
          textLabel.className = "image-workspace-tool-label";
          textLabel.textContent = "Text";
          textToolBtn.appendChild(textLabel);
          toolButtons.appendChild(textToolBtn);
          const hint = document.createElement("p");
          hint.className = "image-occlusion-modal-hint";
          hint.textContent = "Use the tools to draw occlusions, highlights, or notes. Double-click the highlighter to cycle colors.";
          toolbar3.appendChild(hint);
          const closeBtn = document.createElement("button");
          closeBtn.type = "button";
          closeBtn.className = "image-occlusion-modal-close";
          closeBtn.setAttribute("aria-label", "Close image editor");
          closeBtn.innerHTML = "\u2715";
          canvas.appendChild(closeBtn);
          const workspaceBoxes = /* @__PURE__ */ new Map();
          const workspaceHighlights = /* @__PURE__ */ new Map();
          const workspaceTextboxes = /* @__PURE__ */ new Map();
          let previousFocus = null;
          function refreshHighlightSwatch() {
            const color = getCurrentHighlightColor();
            if (highlightSwatch) {
              highlightSwatch.style.setProperty("--swatch-color", color);
            }
          }
          function applyToolState(tool) {
            const mapping = /* @__PURE__ */ new Map([
              ["occlusion", occlusionToolBtn],
              ["highlight", highlightToolBtn],
              ["text", textToolBtn]
            ]);
            mapping.forEach((btn, key) => {
              if (!btn) return;
              const isActive = key === tool;
              btn.classList.toggle("is-active", isActive);
              btn.setAttribute("aria-pressed", isActive ? "true" : "false");
            });
            workspaceOverlay.dataset.tool = tool;
            const isOcclusion = tool === "occlusion";
            const isHighlight = tool === "highlight";
            const isText = tool === "text";
            workspaceLayer.classList.toggle("is-active", isOcclusion);
            workspaceLayer.setAttribute("aria-hidden", isOcclusion ? "false" : "true");
            workspaceHighlightLayer.classList.toggle("is-interactive", isHighlight);
            workspaceHighlightLayer.setAttribute("aria-hidden", isHighlight ? "false" : "true");
            workspaceHighlightLayer.dataset.active = isHighlight ? "true" : "false";
            workspaceTextLayer.classList.toggle("is-interactive", isText);
            workspaceTextLayer.setAttribute("aria-hidden", isText ? "false" : "true");
            workspaceTextLayer.dataset.active = isText ? "true" : "false";
          }
          function focusOverlay() {
            try {
              workspaceOverlay.focus({ preventScroll: true });
            } catch (err) {
              workspaceOverlay.focus();
            }
          }
          function syncCanvasDimensions() {
            const rect = editingImage.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              canvas.style.width = `${rect.width}px`;
              canvas.style.height = `${rect.height}px`;
            }
          }
          occlusionToolBtn.addEventListener("click", () => setWorkspaceTool("occlusion"));
          highlightToolBtn.addEventListener("click", () => setWorkspaceTool("highlight"));
          highlightToolBtn.addEventListener("dblclick", (event) => {
            event.preventDefault();
            cycleHighlightColor();
            setWorkspaceTool("highlight");
          });
          textToolBtn.addEventListener("click", () => setWorkspaceTool("text"));
          refreshHighlightSwatch();
          const handleResize = () => {
            syncCanvasDimensions();
            refreshBoxes();
          };
          const handleClose = (event) => {
            event.preventDefault();
            deactivate();
          };
          closeBtn.addEventListener("click", handleClose);
          workspaceLayer.addEventListener("pointerdown", handlePointerDown);
          workspaceHighlightLayer.addEventListener("pointerdown", handleHighlightPointerDown);
          workspaceTextLayer.addEventListener("pointerdown", handleTextboxPointerDown);
          editingImage.addEventListener("load", () => {
            requestAnimationFrame(() => {
              syncCanvasDimensions();
              refreshBoxes();
            });
          });
          return {
            overlay: workspaceOverlay,
            layer: workspaceLayer,
            highlightLayer: workspaceHighlightLayer,
            textLayer: workspaceTextLayer,
            image: editingImage,
            boxElements: workspaceBoxes,
            highlightElements: workspaceHighlights,
            textboxElements: workspaceTextboxes,
            attach() {
              if (!document.body.contains(workspaceOverlay)) {
                previousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
                document.body.appendChild(workspaceOverlay);
              }
              workspaceOverlay.setAttribute("aria-hidden", "false");
              workspaceOverlay.scrollTop = 0;
              document.body.classList.add("is-occlusion-workspace-open");
              syncCanvasDimensions();
              refreshBoxes();
              requestAnimationFrame(() => {
                workspaceOverlay.classList.add("is-visible");
                focusOverlay();
              });
              window.addEventListener("resize", handleResize);
            },
            detach() {
              workspaceOverlay.classList.remove("is-visible");
              workspaceOverlay.setAttribute("aria-hidden", "true");
              if (workspaceOverlay.parentNode) {
                workspaceOverlay.parentNode.removeChild(workspaceOverlay);
              }
              document.body.classList.remove("is-occlusion-workspace-open");
              window.removeEventListener("resize", handleResize);
              if (previousFocus && typeof previousFocus.focus === "function") {
                try {
                  previousFocus.focus({ preventScroll: true });
                } catch (err) {
                  previousFocus.focus();
                }
              }
              previousFocus = null;
            },
            destroy() {
              workspaceLayer.removeEventListener("pointerdown", handlePointerDown);
              workspaceHighlightLayer.removeEventListener("pointerdown", handleHighlightPointerDown);
              workspaceTextLayer.removeEventListener("pointerdown", handleTextboxPointerDown);
              closeBtn.removeEventListener("click", handleClose);
              workspaceBoxes.clear();
              workspaceHighlights.clear();
              workspaceTextboxes.clear();
              this.detach();
            },
            focus() {
              focusOverlay();
            },
            setTool(tool) {
              applyToolState(tool);
            },
            updateHighlightSwatch() {
              refreshHighlightSwatch();
            }
          };
        }
        function getWorkspace() {
          if (!workspace) workspace = createWorkspace();
          return workspace;
        }
        function syncOcclusionLayer(targetLayer, targetBoxes, targetImage, metrics = null) {
          if (!targetLayer) return;
          const occlusions = parseImageOcclusions(image);
          const seen = /* @__PURE__ */ new Set();
          occlusions.forEach((box) => {
            let element = targetBoxes.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "rich-editor-image-occlusion-box image-occlusion-box";
              element.dataset.id = box.id;
              element.tabIndex = 0;
              element.setAttribute("role", "button");
              element.setAttribute("aria-pressed", "false");
              element.setAttribute("aria-label", "Toggle occlusion");
              element.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                toggleReveal(element);
              });
              element.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.preventDefault();
                  toggleReveal(element);
                }
              });
              const removeBtn = document.createElement("button");
              removeBtn.type = "button";
              removeBtn.className = "rich-editor-image-occlusion-remove";
              removeBtn.setAttribute("aria-label", "Remove occlusion");
              removeBtn.innerHTML = "\u2715";
              removeBtn.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                removeOcclusion(element.dataset.id || "");
              });
              element.appendChild(removeBtn);
              targetLayer.appendChild(element);
              targetBoxes.set(box.id, element);
            }
            const geometry = metrics || resolveImageMetrics(targetImage || image);
            applyOcclusionBoxGeometry(element, box, geometry || targetImage || image);
            const revealed = revealStates.get(box.id) === true;
            setOcclusionRevealState(element, revealed);
            seen.add(box.id);
          });
          targetBoxes.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              targetBoxes.delete(id);
              revealStates.delete(id);
            }
          });
          targetLayer.classList.toggle("has-boxes", targetBoxes.size > 0);
        }
        function syncHighlightLayer(targetLayer, targetHighlights, targetImage, { interactive = false, metrics = null } = {}) {
          if (!targetLayer) return;
          const highlights = parseImageHighlights(image);
          const seen = /* @__PURE__ */ new Set();
          highlights.forEach((box) => {
            let element = targetHighlights.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "image-highlight-box";
              element.dataset.id = box.id;
              if (interactive) {
                element.tabIndex = 0;
                element.setAttribute("role", "button");
                element.setAttribute("aria-label", "Edit highlight");
                const removeBtn = document.createElement("button");
                removeBtn.type = "button";
                removeBtn.className = "image-annotation-remove";
                removeBtn.setAttribute("aria-label", "Remove highlight");
                removeBtn.textContent = "\u2715";
                removeBtn.addEventListener("click", (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  removeHighlight(element.dataset.id || box.id);
                });
                element.appendChild(removeBtn);
                element.addEventListener("dblclick", (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  const id = element.dataset.id || box.id;
                  const color = getCurrentHighlightColor();
                  updateHighlightColor(id, color);
                });
              }
              targetLayer.appendChild(element);
              targetHighlights.set(box.id, element);
            }
            element.dataset.id = box.id;
            element.style.borderColor = box.color;
            element.style.backgroundColor = highlightColorToRgba(box.color, interactive ? 0.5 : 0.35);
            const geometry = metrics || resolveImageMetrics(targetImage || image);
            applyOcclusionBoxGeometry(element, box, geometry || targetImage || image);
            seen.add(box.id);
          });
          targetHighlights.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              targetHighlights.delete(id);
            }
          });
          targetLayer.classList.toggle("has-annotations", targetHighlights.size > 0);
        }
        function syncTextboxLayer(targetLayer, targetTextboxes, targetImage, { interactive = false, metrics = null } = {}) {
          if (!targetLayer) return;
          const textboxes = parseImageTextboxes(image);
          const seen = /* @__PURE__ */ new Set();
          textboxes.forEach((box) => {
            let element = targetTextboxes.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "image-textbox";
              element.dataset.id = box.id;
              const content = document.createElement("div");
              content.className = "image-textbox-content";
              if (interactive) {
                content.contentEditable = "true";
                content.setAttribute("role", "textbox");
                content.setAttribute("aria-label", "Edit text");
                content.addEventListener("input", () => {
                  const id = element.dataset.id || box.id;
                  updateTextboxText(id, content.textContent || "");
                });
                content.addEventListener("blur", () => {
                  const id = element.dataset.id || box.id;
                  updateTextboxText(id, content.textContent || "");
                });
                content.addEventListener("keydown", (event) => {
                  if (event.key === "Escape") {
                    event.preventDefault();
                    content.blur();
                  }
                });
              } else {
                content.setAttribute("aria-hidden", "true");
              }
              element.appendChild(content);
              if (interactive) {
                let dragHandle = element.querySelector(".image-textbox-handle--move");
                if (!dragHandle) {
                  dragHandle = document.createElement("div");
                  dragHandle.className = "image-textbox-handle image-textbox-handle--move";
                  dragHandle.setAttribute("aria-hidden", "true");
                  element.appendChild(dragHandle);
                }
                let resizeHandle = element.querySelector(".image-textbox-handle--resize");
                if (!resizeHandle) {
                  resizeHandle = document.createElement("div");
                  resizeHandle.className = "image-textbox-handle image-textbox-handle--resize";
                  resizeHandle.setAttribute("aria-hidden", "true");
                  element.appendChild(resizeHandle);
                }
              }
              if (interactive) {
                const removeBtn = document.createElement("button");
                removeBtn.type = "button";
                removeBtn.className = "image-annotation-remove";
                removeBtn.setAttribute("aria-label", "Remove text");
                removeBtn.textContent = "\u2715";
                removeBtn.addEventListener("click", (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  removeTextbox(element.dataset.id || box.id);
                });
                element.appendChild(removeBtn);
              }
              targetLayer.appendChild(element);
              targetTextboxes.set(box.id, element);
            }
            if (interactive) ensureTextboxHandleBindings(element);
            element.dataset.id = box.id;
            const contentEl = element.querySelector(".image-textbox-content");
            if (contentEl && (contentEl.textContent || "") !== (box.text || "")) {
              contentEl.textContent = box.text || "";
            }
            const geometry = metrics || resolveImageMetrics(targetImage || image);
            applyOcclusionBoxGeometry(element, box, geometry || targetImage || image);
            seen.add(box.id);
          });
          targetTextboxes.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              targetTextboxes.delete(id);
            }
          });
          targetLayer.classList.toggle("has-annotations", targetTextboxes.size > 0);
        }
        function ensureTextboxHandleBindings(element) {
          if (!(element instanceof HTMLElement)) return;
          if (element.__textboxHandleListeners) return;
          const dragHandle = element.querySelector(".image-textbox-handle--move");
          const resizeHandle = element.querySelector(".image-textbox-handle--resize");
          if (!dragHandle || !resizeHandle) return;
          const moveListener = (event) => startTextboxManipulation(event, element, "move");
          const resizeListener = (event) => startTextboxManipulation(event, element, "resize");
          dragHandle.addEventListener("pointerdown", moveListener);
          resizeHandle.addEventListener("pointerdown", resizeListener);
          element.__textboxHandleListeners = { moveListener, resizeListener };
        }
        function refreshBoxes() {
          const occlusions = parseImageOcclusions(image);
          const highlights = parseImageHighlights(image);
          const textboxes = parseImageTextboxes(image);
          overlay.classList.toggle("has-occlusions", occlusions.length > 0);
          occlusionToggle.classList.toggle("has-occlusions", occlusions.length > 0);
          const inlineMetrics = resolveImageMetrics(image);
          syncOcclusionLayer(layer, boxElements, image, inlineMetrics);
          syncHighlightLayer(highlightLayer, highlightElements, image, { interactive: false, metrics: inlineMetrics });
          syncTextboxLayer(textLayer, textboxElements, image, { interactive: false, metrics: inlineMetrics });
          if (workspace) {
            const workspaceImage = workspace.image instanceof HTMLImageElement ? workspace.image : null;
            const workspaceMetrics = workspaceImage ? resolveImageMetrics(workspaceImage) : inlineMetrics;
            if (workspace.image) {
              if (occlusions.length) {
                workspace.image.setAttribute(IMAGE_OCCLUSION_ATTR, JSON.stringify(occlusions));
              } else {
                workspace.image.removeAttribute(IMAGE_OCCLUSION_ATTR);
              }
              if (highlights.length) {
                workspace.image.setAttribute(IMAGE_HIGHLIGHT_ATTR, JSON.stringify(highlights));
              } else {
                workspace.image.removeAttribute(IMAGE_HIGHLIGHT_ATTR);
              }
              if (textboxes.length) {
                workspace.image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(textboxes));
              } else {
                workspace.image.removeAttribute(IMAGE_TEXTBOX_ATTR);
              }
            }
            syncOcclusionLayer(workspace.layer, workspace.boxElements, workspaceImage || image, workspaceMetrics);
            syncHighlightLayer(workspace.highlightLayer, workspace.highlightElements, workspaceImage || image, { interactive: true, metrics: workspaceMetrics });
            syncTextboxLayer(workspace.textLayer, workspace.textboxElements, workspaceImage || image, { interactive: true, metrics: workspaceMetrics });
          }
        }
        function toggleReveal(element) {
          const id = element?.dataset?.id;
          if (!id) return;
          const next = !(revealStates.get(id) === true);
          revealStates.set(id, next);
          setOcclusionRevealState(element, next);
        }
        function removeOcclusion(id) {
          if (!id) return;
          const next = parseImageOcclusions(image).filter((box) => box.id !== id);
          const normalized2 = writeImageOcclusions(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_OCCLUSION_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_OCCLUSION_ATTR);
          }
          notifyImageOcclusionChange(image);
          revealStates.delete(id);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function removeHighlight(id) {
          if (!id) return;
          const next = parseImageHighlights(image).filter((box) => box.id !== id);
          const normalized2 = writeImageHighlights(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_HIGHLIGHT_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_HIGHLIGHT_ATTR);
          }
          notifyImageOcclusionChange(image);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function updateHighlightColor(id, color) {
          if (!id) return;
          const highlights = parseImageHighlights(image);
          const next = highlights.map((box) => {
            if (box.id !== id) return box;
            return normalizeHighlightBox({ ...box, color });
          }).filter(Boolean);
          const normalized2 = writeImageHighlights(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_HIGHLIGHT_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_HIGHLIGHT_ATTR);
          }
          notifyImageOcclusionChange(image);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function removeTextbox(id) {
          if (!id) return;
          const next = parseImageTextboxes(image).filter((box) => box.id !== id);
          const normalized2 = writeImageTextboxes(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_TEXTBOX_ATTR);
          }
          notifyImageOcclusionChange(image);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function updateTextboxText(id, text) {
          if (!id) return;
          const safeText = sanitizeTextboxContent(text);
          const textboxes = parseImageTextboxes(image);
          const next = textboxes.map((box) => {
            if (box.id !== id) return box;
            return normalizeTextbox({ ...box, text: safeText });
          }).filter(Boolean);
          const normalized2 = writeImageTextboxes(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_TEXTBOX_ATTR);
          }
          notifyImageOcclusionChange(image);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function handlePointerDown(event) {
          if (!active) return;
          if (activeWorkspaceTool !== "occlusion") return;
          if (event.button !== 0) return;
          const surface = event.currentTarget;
          if (!(surface instanceof HTMLElement)) return;
          if (event.target !== surface) return;
          event.preventDefault();
          const targetImage = workspace?.image instanceof HTMLImageElement ? workspace.image : image;
          const rect = getImageContentRect(targetImage) || surface.getBoundingClientRect();
          if (!rect || rect.width <= 0 || rect.height <= 0) return;
          const startX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const startY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const element = document.createElement("div");
          element.className = "rich-editor-image-occlusion-box image-occlusion-box is-drawing";
          surface.appendChild(element);
          drawing = {
            surface,
            rect,
            image: targetImage,
            metrics: resolveImageMetrics(targetImage),
            element,
            startX,
            startY,
            box: {
              id: ensureOcclusionId({}),
              x: startX,
              y: startY,
              width: 0,
              height: 0
            }
          };
          updateDrawing(event);
          window.addEventListener("pointermove", handlePointerMove);
          window.addEventListener("pointerup", handlePointerUp);
          window.addEventListener("pointercancel", handlePointerCancel);
        }
        function updateDrawing(event) {
          if (!drawing) return;
          const { rect, startX, startY, box, element, image: targetImage, metrics } = drawing;
          const currentX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const currentY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const minX = Math.min(startX, currentX);
          const minY = Math.min(startY, currentY);
          const width = Math.abs(currentX - startX);
          const height = Math.abs(currentY - startY);
          box.x = minX;
          box.y = minY;
          box.width = width;
          box.height = height;
          applyOcclusionBoxGeometry(element, box, metrics || targetImage);
        }
        function finishDrawing(cancelled) {
          if (!drawing) return;
          const { element, box, rect, image: targetImage } = drawing;
          window.removeEventListener("pointermove", handlePointerMove);
          window.removeEventListener("pointerup", handlePointerUp);
          window.removeEventListener("pointercancel", handlePointerCancel);
          element.remove();
          if (!cancelled) {
            const normalized2 = normalizeOcclusionBox(box);
            if (normalized2) {
              const widthPx = normalized2.width * rect.width;
              const heightPx = normalized2.height * rect.height;
              if (widthPx >= MIN_PIXEL_SIZE && heightPx >= MIN_PIXEL_SIZE) {
                const next = parseImageOcclusions(image).concat([normalized2]);
                const applied = writeImageOcclusions(image, next);
                if (workspace?.image) {
                  if (applied.length) workspace.image.setAttribute(IMAGE_OCCLUSION_ATTR, JSON.stringify(applied));
                  else workspace.image.removeAttribute(IMAGE_OCCLUSION_ATTR);
                }
                notifyImageOcclusionChange(image);
                refreshBoxes();
                triggerEditorChange();
                if (typeof onGeometryChange === "function") onGeometryChange();
              }
            }
          }
          drawing = null;
        }
        function handlePointerMove(event) {
          if (!drawing) return;
          event.preventDefault();
          updateDrawing(event);
        }
        function handlePointerUp(event) {
          if (!drawing) return;
          event.preventDefault();
          updateDrawing(event);
          finishDrawing(false);
        }
        function handlePointerCancel() {
          finishDrawing(true);
        }
        layer.addEventListener("pointerdown", handlePointerDown);
        function handleHighlightPointerDown(event) {
          if (!active || activeWorkspaceTool !== "highlight") return;
          if (event.button !== 0) return;
          const surface = event.currentTarget;
          if (!(surface instanceof HTMLElement)) return;
          if (event.target !== surface) return;
          event.preventDefault();
          const targetImage = workspace?.image instanceof HTMLImageElement ? workspace.image : image;
          const rect = getImageContentRect(targetImage) || surface.getBoundingClientRect();
          if (!rect || rect.width <= 0 || rect.height <= 0) return;
          const startX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const startY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const color = getCurrentHighlightColor();
          const element = document.createElement("div");
          element.className = "image-highlight-box is-drawing";
          element.style.borderColor = color;
          element.style.backgroundColor = highlightColorToRgba(color, 0.45);
          surface.appendChild(element);
          highlightDrawing = {
            surface,
            rect,
            image: targetImage,
            metrics: resolveImageMetrics(targetImage),
            element,
            color,
            startX,
            startY,
            box: {
              id: ensureAnnotationId("hlt", {}),
              x: startX,
              y: startY,
              width: 0,
              height: 0,
              color
            }
          };
          updateHighlightDrawing(event);
          window.addEventListener("pointermove", handleHighlightPointerMove);
          window.addEventListener("pointerup", handleHighlightPointerUp);
          window.addEventListener("pointercancel", handleHighlightPointerCancel);
        }
        function updateHighlightDrawing(event) {
          if (!highlightDrawing) return;
          const { rect, startX, startY, box, element, image: targetImage, metrics } = highlightDrawing;
          const currentX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const currentY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const minX = Math.min(startX, currentX);
          const minY = Math.min(startY, currentY);
          const width = Math.abs(currentX - startX);
          const height = Math.abs(currentY - startY);
          box.x = minX;
          box.y = minY;
          box.width = width;
          box.height = height;
          applyOcclusionBoxGeometry(element, box, metrics || targetImage);
        }
        function finishHighlightDrawing(cancelled) {
          if (!highlightDrawing) return;
          const { element, box, rect } = highlightDrawing;
          window.removeEventListener("pointermove", handleHighlightPointerMove);
          window.removeEventListener("pointerup", handleHighlightPointerUp);
          window.removeEventListener("pointercancel", handleHighlightPointerCancel);
          element.remove();
          if (!cancelled) {
            const normalized2 = normalizeHighlightBox(box);
            if (normalized2) {
              const widthPx = normalized2.width * rect.width;
              const heightPx = normalized2.height * rect.height;
              if (widthPx >= MIN_PIXEL_SIZE && heightPx >= MIN_PIXEL_SIZE) {
                const next = parseImageHighlights(image).concat([normalized2]);
                const applied = writeImageHighlights(image, next);
                if (workspace?.image) {
                  if (applied.length) workspace.image.setAttribute(IMAGE_HIGHLIGHT_ATTR, JSON.stringify(applied));
                  else workspace.image.removeAttribute(IMAGE_HIGHLIGHT_ATTR);
                }
                notifyImageOcclusionChange(image);
                refreshBoxes();
                triggerEditorChange();
                if (typeof onGeometryChange === "function") onGeometryChange();
              }
            }
          }
          highlightDrawing = null;
        }
        function handleHighlightPointerMove(event) {
          if (!highlightDrawing) return;
          event.preventDefault();
          updateHighlightDrawing(event);
        }
        function handleHighlightPointerUp(event) {
          if (!highlightDrawing) return;
          event.preventDefault();
          updateHighlightDrawing(event);
          finishHighlightDrawing(false);
        }
        function handleHighlightPointerCancel() {
          finishHighlightDrawing(true);
        }
        function handleTextboxPointerDown(event) {
          if (!active || activeWorkspaceTool !== "text") return;
          if (event.button !== 0) return;
          const surface = event.currentTarget;
          if (!(surface instanceof HTMLElement)) return;
          if (event.target !== surface) return;
          event.preventDefault();
          const targetImage = workspace?.image instanceof HTMLImageElement ? workspace.image : image;
          const rect = getImageContentRect(targetImage) || surface.getBoundingClientRect();
          if (!rect || rect.width <= 0 || rect.height <= 0) return;
          const startX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const startY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const element = document.createElement("div");
          element.className = "image-textbox is-drawing";
          surface.appendChild(element);
          textboxDrawing = {
            surface,
            rect,
            image: targetImage,
            metrics: resolveImageMetrics(targetImage),
            element,
            startX,
            startY,
            box: {
              id: ensureAnnotationId("txt", {}),
              x: startX,
              y: startY,
              width: 0,
              height: 0,
              text: ""
            }
          };
          updateTextboxDrawing(event);
          window.addEventListener("pointermove", handleTextboxPointerMove);
          window.addEventListener("pointerup", handleTextboxPointerUp);
          window.addEventListener("pointercancel", handleTextboxPointerCancel);
        }
        function updateTextboxDrawing(event) {
          if (!textboxDrawing) return;
          const { rect, startX, startY, box, element, image: targetImage, metrics } = textboxDrawing;
          const currentX = clamp2((event.clientX - rect.left) / rect.width, 0, 1);
          const currentY = clamp2((event.clientY - rect.top) / rect.height, 0, 1);
          const minX = Math.min(startX, currentX);
          const minY = Math.min(startY, currentY);
          const width = Math.abs(currentX - startX);
          const height = Math.abs(currentY - startY);
          box.x = minX;
          box.y = minY;
          box.width = width;
          box.height = height;
          applyOcclusionBoxGeometry(element, box, metrics || targetImage);
        }
        function finishTextboxDrawing(cancelled) {
          if (!textboxDrawing) return;
          const { element, box, rect } = textboxDrawing;
          window.removeEventListener("pointermove", handleTextboxPointerMove);
          window.removeEventListener("pointerup", handleTextboxPointerUp);
          window.removeEventListener("pointercancel", handleTextboxPointerCancel);
          element.remove();
          let createdId = null;
          if (!cancelled) {
            const normalized2 = normalizeTextbox(box);
            if (normalized2) {
              const widthPx = normalized2.width * rect.width;
              const heightPx = normalized2.height * rect.height;
              if (widthPx >= MIN_PIXEL_SIZE && heightPx >= MIN_PIXEL_SIZE) {
                const next = parseImageTextboxes(image).concat([normalized2]);
                const applied = writeImageTextboxes(image, next);
                createdId = normalized2.id;
                if (workspace?.image) {
                  if (applied.length) workspace.image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(applied));
                  else workspace.image.removeAttribute(IMAGE_TEXTBOX_ATTR);
                }
                notifyImageOcclusionChange(image);
                refreshBoxes();
                triggerEditorChange();
                if (typeof onGeometryChange === "function") onGeometryChange();
              }
            }
          }
          const focusId = createdId;
          if (focusId) {
            requestAnimationFrame(() => focusWorkspaceTextbox(focusId));
          }
          textboxDrawing = null;
        }
        function handleTextboxPointerMove(event) {
          if (!textboxDrawing) return;
          event.preventDefault();
          updateTextboxDrawing(event);
        }
        function handleTextboxPointerUp(event) {
          if (!textboxDrawing) return;
          event.preventDefault();
          updateTextboxDrawing(event);
          finishTextboxDrawing(false);
        }
        function handleTextboxPointerCancel() {
          finishTextboxDrawing(true);
        }
        function startTextboxManipulation(event, element, mode2) {
          if (!(element instanceof HTMLElement)) return;
          if (mode2 !== "move" && mode2 !== "resize") return;
          const id = element.dataset.id;
          if (!id) return;
          if (textboxManipulation) finishTextboxManipulation(true);
          const targetImage = workspace?.image instanceof HTMLImageElement ? workspace.image : image;
          const rect = getImageContentRect(targetImage) || targetImage?.getBoundingClientRect();
          if (!rect || rect.width <= 0 || rect.height <= 0) return;
          const textboxes = parseImageTextboxes(image);
          const source = textboxes.find((box) => box.id === id);
          if (!source) return;
          event.preventDefault();
          event.stopPropagation();
          const pointerTarget = event.currentTarget instanceof HTMLElement ? event.currentTarget : element;
          const metrics = resolveImageMetrics(targetImage);
          const minWidthNorm = rect.width > 0 ? Math.min(1, MIN_PIXEL_SIZE / rect.width) : 0;
          const minHeightNorm = rect.height > 0 ? Math.min(1, MIN_PIXEL_SIZE / rect.height) : 0;
          const state2 = {
            type: mode2,
            id,
            pointerId: event.pointerId,
            pointerTarget,
            element,
            rect,
            metrics,
            targetImage,
            original: { ...source },
            current: { ...source },
            minWidthNorm,
            minHeightNorm
          };
          if (mode2 === "move") {
            const leftPx = rect.left + clamp2(source.x, 0, 1) * rect.width;
            const topPx = rect.top + clamp2(source.y, 0, 1) * rect.height;
            state2.offsetX = event.clientX - leftPx;
            state2.offsetY = event.clientY - topPx;
          }
          textboxManipulation = state2;
          if (pointerTarget?.setPointerCapture && Number.isFinite(event.pointerId)) {
            try {
              pointerTarget.setPointerCapture(event.pointerId);
            } catch (err) {
            }
          }
          window.addEventListener("pointermove", handleTextboxManipulationMove);
          window.addEventListener("pointerup", handleTextboxManipulationUp);
          window.addEventListener("pointercancel", handleTextboxManipulationCancel);
        }
        function updateTextboxManipulation(event) {
          if (!textboxManipulation || event.pointerId !== textboxManipulation.pointerId) return;
          const state2 = textboxManipulation;
          if (!state2.rect || state2.rect.width <= 0 || state2.rect.height <= 0) return;
          const next = { ...state2.original };
          if (state2.type === "move") {
            const rawX = (event.clientX - state2.rect.left - (state2.offsetX || 0)) / state2.rect.width;
            const rawY = (event.clientY - state2.rect.top - (state2.offsetY || 0)) / state2.rect.height;
            const maxX = Math.max(0, 1 - state2.original.width);
            const maxY = Math.max(0, 1 - state2.original.height);
            next.x = clamp2(rawX, 0, maxX);
            next.y = clamp2(rawY, 0, maxY);
          } else {
            const cursorX = (event.clientX - state2.rect.left) / state2.rect.width;
            const cursorY = (event.clientY - state2.rect.top) / state2.rect.height;
            const width = clamp2(cursorX - state2.original.x, state2.minWidthNorm, 1 - state2.original.x);
            const height = clamp2(cursorY - state2.original.y, state2.minHeightNorm, 1 - state2.original.y);
            next.width = width;
            next.height = height;
          }
          textboxManipulation.current = next;
          applyOcclusionBoxGeometry(state2.element, next, state2.metrics || state2.targetImage);
        }
        function finishTextboxManipulation(cancelled) {
          if (!textboxManipulation) return;
          const state2 = textboxManipulation;
          textboxManipulation = null;
          window.removeEventListener("pointermove", handleTextboxManipulationMove);
          window.removeEventListener("pointerup", handleTextboxManipulationUp);
          window.removeEventListener("pointercancel", handleTextboxManipulationCancel);
          if (state2.pointerTarget?.releasePointerCapture && Number.isFinite(state2.pointerId)) {
            try {
              state2.pointerTarget.releasePointerCapture(state2.pointerId);
            } catch (err) {
            }
          }
          if (cancelled || !state2.current) {
            applyOcclusionBoxGeometry(state2.element, state2.original, state2.metrics || state2.targetImage);
            return;
          }
          const widthPx = state2.current.width * state2.rect.width;
          const heightPx = state2.current.height * state2.rect.height;
          if (widthPx < MIN_PIXEL_SIZE || heightPx < MIN_PIXEL_SIZE) {
            applyOcclusionBoxGeometry(state2.element, state2.original, state2.metrics || state2.targetImage);
            return;
          }
          const next = parseImageTextboxes(image).map((box) => {
            if (box.id !== state2.id) return box;
            const normalizedBox = normalizeTextbox({ ...box, ...state2.current });
            return normalizedBox || box;
          }).filter(Boolean);
          const normalized2 = writeImageTextboxes(image, next);
          if (workspace?.image) {
            if (normalized2.length) workspace.image.setAttribute(IMAGE_TEXTBOX_ATTR, JSON.stringify(normalized2));
            else workspace.image.removeAttribute(IMAGE_TEXTBOX_ATTR);
          }
          notifyImageOcclusionChange(image);
          refreshBoxes();
          triggerEditorChange();
          if (typeof onGeometryChange === "function") onGeometryChange();
        }
        function handleTextboxManipulationMove(event) {
          if (!textboxManipulation || event.pointerId !== textboxManipulation.pointerId) return;
          event.preventDefault();
          updateTextboxManipulation(event);
        }
        function handleTextboxManipulationUp(event) {
          if (!textboxManipulation || event.pointerId !== textboxManipulation.pointerId) return;
          event.preventDefault();
          updateTextboxManipulation(event);
          finishTextboxManipulation(false);
        }
        function handleTextboxManipulationCancel() {
          finishTextboxManipulation(true);
        }
        function focusWorkspaceTextbox(id) {
          if (!workspace) return;
          const element = workspace.textboxElements?.get(id);
          if (!element) return;
          const content = element.querySelector(".image-textbox-content");
          if (!(content instanceof HTMLElement)) return;
          content.focus();
          placeCaretAtEnd(content);
        }
        function placeCaretAtEnd(node) {
          if (!node) return;
          const selection = window.getSelection();
          if (!selection) return;
          const range = document.createRange();
          range.selectNodeContents(node);
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
        }
        function activate() {
          const workspaceInstance = getWorkspace();
          if (active) {
            if (workspaceInstance && typeof workspaceInstance.focus === "function") {
              workspaceInstance.focus();
            }
            if (workspaceInstance && typeof workspaceInstance.updateHighlightSwatch === "function") {
              workspaceInstance.updateHighlightSwatch();
            }
            if (workspaceInstance && typeof workspaceInstance.setTool === "function") {
              workspaceInstance.setTool(activeWorkspaceTool);
            }
            return;
          }
          active = true;
          revealStates.clear();
          overlay.classList.add("is-occluding");
          occlusionToggle.dataset.active = "true";
          occlusionToggle.setAttribute("aria-pressed", "true");
          if (workspaceInstance) {
            workspaceInstance.attach();
            if (typeof workspaceInstance.setTool === "function") {
              workspaceInstance.setTool(activeWorkspaceTool);
            }
            if (typeof workspaceInstance.updateHighlightSwatch === "function") {
              workspaceInstance.updateHighlightSwatch();
            }
          }
          refreshBoxes();
        }
        function deactivate() {
          if (!active) return;
          active = false;
          overlay.classList.remove("is-occluding");
          occlusionToggle.dataset.active = "false";
          occlusionToggle.setAttribute("aria-pressed", "false");
          layer.classList.remove("is-active");
          layer.setAttribute("aria-hidden", "true");
          if (workspace) {
            workspace.layer.classList.remove("is-active");
            workspace.layer.setAttribute("aria-hidden", "true");
            workspace.highlightLayer.classList.remove("is-interactive");
            workspace.highlightLayer.setAttribute("aria-hidden", "true");
            workspace.highlightLayer.dataset.active = "false";
            workspace.textLayer.classList.remove("is-interactive");
            workspace.textLayer.setAttribute("aria-hidden", "true");
            workspace.textLayer.dataset.active = "false";
            workspace.detach();
          }
          revealStates.clear();
          refreshBoxes();
          if (drawing) finishDrawing(true);
          if (highlightDrawing) finishHighlightDrawing(true);
          if (textboxDrawing) finishTextboxDrawing(true);
          if (textboxManipulation) finishTextboxManipulation(true);
        }
        function update2() {
          refreshBoxes();
        }
        function destroy2() {
          deactivate();
          layer.removeEventListener("pointerdown", handlePointerDown);
          if (drawing) finishDrawing(true);
          boxElements.clear();
          revealStates.clear();
          if (workspace) {
            workspace.destroy();
            workspace = null;
          }
          layer.remove();
        }
        refreshBoxes();
        return {
          activate,
          deactivate,
          isActive: () => active,
          update: update2,
          destroy: destroy2
        };
      }
      const destroy = () => {
        if (resizeObserver) resizeObserver.disconnect();
        document.removeEventListener("scroll", onScroll, true);
        editable.removeEventListener("scroll", onScroll);
        window.removeEventListener("resize", update);
        document.removeEventListener("mousedown", handleOutside, true);
        document.removeEventListener("keydown", onKeyDown, true);
        stopResize();
        occlusionEditor.destroy();
        overlay.remove();
        image.classList.remove("rich-editor-image-active");
        occlusionDisplayManager?.suppress(image, false);
        occlusionDisplayManager?.notifyChange(image);
        if (pendingImageTarget === image) pendingImageTarget = null;
      };
      cropBtn.addEventListener("click", async () => {
        occlusionEditor.deactivate();
        try {
          const currentWidth = Number(image.getAttribute("width")) || Math.round(image.getBoundingClientRect().width);
          const currentHeight = Number(image.getAttribute("height")) || Math.round(image.getBoundingClientRect().height);
          const alt = image.getAttribute("alt") || "";
          const result = await editImageSource(image.src, { altText: alt, width: currentWidth, height: currentHeight });
          if (!result) return;
          image.src = result.dataUrl;
          if (result.altText) {
            image.setAttribute("alt", result.altText);
          } else {
            image.removeAttribute("alt");
          }
          setImageSize(image, result.width, result.height);
          triggerEditorChange();
          requestAnimationFrame(() => update());
          occlusionDisplayManager?.notifyChange(image);
        } catch (err) {
          console.error("Failed to edit image", err);
        }
      });
      replaceBtn.addEventListener("click", () => {
        occlusionEditor.deactivate();
        pendingImageTarget = image;
        imageFileInput.click();
      });
      doneBtn.addEventListener("click", () => {
        destroyActiveImageEditor();
      });
      document.addEventListener("scroll", onScroll, true);
      editable.addEventListener("scroll", onScroll);
      window.addEventListener("resize", update);
      document.addEventListener("mousedown", handleOutside, true);
      document.addEventListener("keydown", onKeyDown, true);
      requestAnimationFrame(() => update());
      return {
        image,
        update,
        destroy,
        openWorkspace() {
          occlusionEditor.activate();
        }
      };
    }
    function createEditorOcclusionDisplayManager(wrapper2, editable2, beginImageEditing2) {
      const overlays = /* @__PURE__ */ new Map();
      const resizeObserver = typeof ResizeObserver === "function" ? new ResizeObserver((entries) => {
        for (const entry of entries) {
          const image = entry.target;
          const overlay = overlays.get(image);
          if (overlay) overlay.update();
        }
      }) : null;
      function createOverlay(image) {
        const overlayEl = document.createElement("div");
        overlayEl.className = "rich-editor-occlusion-display";
        overlayEl.setAttribute("aria-hidden", "true");
        const highlightLayer = document.createElement("div");
        highlightLayer.className = "image-annotation-layer image-highlight-layer";
        overlayEl.appendChild(highlightLayer);
        const textLayer = document.createElement("div");
        textLayer.className = "image-annotation-layer image-text-layer";
        overlayEl.appendChild(textLayer);
        const layer = document.createElement("div");
        layer.className = "image-occlusion-layer";
        overlayEl.appendChild(layer);
        wrapper2.appendChild(overlayEl);
        const boxElements = /* @__PURE__ */ new Map();
        const highlightElements = /* @__PURE__ */ new Map();
        const textboxElements = /* @__PURE__ */ new Map();
        const revealStates = /* @__PURE__ */ new Map();
        let suppressed = false;
        function updatePosition() {
          if (!wrapper2.contains(image)) {
            removeOverlay(image);
            return;
          }
          const rect = image.getBoundingClientRect();
          const wrapperRect = wrapper2.getBoundingClientRect();
          overlayEl.style.width = `${rect.width}px`;
          overlayEl.style.height = `${rect.height}px`;
          overlayEl.style.left = `${rect.left - wrapperRect.left}px`;
          overlayEl.style.top = `${rect.top - wrapperRect.top}px`;
        }
        function toggleReveal(element) {
          const id = element?.dataset?.id;
          if (!id) return;
          const next = !(revealStates.get(id) === true);
          revealStates.set(id, next);
          setOcclusionRevealState(element, next);
        }
        function updateOcclusions() {
          if (suppressed) return;
          const metrics = resolveImageMetrics(image);
          const occlusions = parseImageOcclusions(image);
          const seen = /* @__PURE__ */ new Set();
          occlusions.forEach((box) => {
            let element = boxElements.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "image-occlusion-box";
              element.dataset.id = box.id;
              element.tabIndex = 0;
              element.setAttribute("role", "button");
              element.setAttribute("aria-pressed", "false");
              element.setAttribute("aria-label", "Toggle occlusion");
              element.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                toggleReveal(element);
              });
              element.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.preventDefault();
                  toggleReveal(element);
                }
              });
              element.addEventListener("dblclick", (event) => {
                event.preventDefault();
                event.stopPropagation();
                beginImageEditing2(image);
              });
              layer.appendChild(element);
              boxElements.set(box.id, element);
            }
            applyOcclusionBoxGeometry(element, box, metrics || image);
            const revealed = revealStates.get(box.id) === true;
            setOcclusionRevealState(element, revealed);
            seen.add(box.id);
          });
          boxElements.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              boxElements.delete(id);
              revealStates.delete(id);
            }
          });
        }
        function updateHighlights() {
          if (suppressed) return;
          const metrics = resolveImageMetrics(image);
          const highlights = parseImageHighlights(image);
          const seen = /* @__PURE__ */ new Set();
          highlights.forEach((box) => {
            let element = highlightElements.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "image-highlight-box";
              element.dataset.id = box.id;
              highlightLayer.appendChild(element);
              highlightElements.set(box.id, element);
            }
            element.style.borderColor = box.color;
            element.style.backgroundColor = highlightColorToRgba(box.color, 0.35);
            applyOcclusionBoxGeometry(element, box, metrics || image);
            seen.add(box.id);
          });
          highlightElements.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              highlightElements.delete(id);
            }
          });
          highlightLayer.classList.toggle("is-hidden", highlightElements.size === 0);
        }
        function updateTextboxes() {
          if (suppressed) return;
          const metrics = resolveImageMetrics(image);
          const textboxes = parseImageTextboxes(image);
          const seen = /* @__PURE__ */ new Set();
          textboxes.forEach((box) => {
            let element = textboxElements.get(box.id);
            if (!element) {
              element = document.createElement("div");
              element.className = "image-textbox";
              element.dataset.id = box.id;
              const content2 = document.createElement("div");
              content2.className = "image-textbox-content";
              content2.setAttribute("aria-hidden", "true");
              element.appendChild(content2);
              textLayer.appendChild(element);
              textboxElements.set(box.id, element);
            }
            const content = element.querySelector(".image-textbox-content");
            if (content && (content.textContent || "") !== (box.text || "")) {
              content.textContent = box.text || "";
            }
            applyOcclusionBoxGeometry(element, box, metrics || image);
            seen.add(box.id);
          });
          textboxElements.forEach((element, id) => {
            if (!seen.has(id)) {
              element.remove();
              textboxElements.delete(id);
            }
          });
          textLayer.classList.toggle("is-hidden", textboxElements.size === 0);
        }
        function updateVisibility() {
          const hasOcclusions = boxElements.size > 0;
          const hasHighlights = highlightElements.size > 0;
          const hasTextboxes = textboxElements.size > 0;
          overlayEl.classList.toggle("is-hidden", !hasOcclusions && !hasHighlights && !hasTextboxes);
        }
        function update() {
          updatePosition();
          updateOcclusions();
          updateHighlights();
          updateTextboxes();
          updateVisibility();
        }
        function refresh() {
          revealStates.clear();
          updateOcclusions();
          updateHighlights();
          updateTextboxes();
          updateVisibility();
        }
        function setSuppressed(value2) {
          suppressed = Boolean(value2);
          overlayEl.classList.toggle("is-suppressed", suppressed);
          if (!suppressed) {
            refresh();
            updatePosition();
          }
        }
        function handleImageChange() {
          refresh();
          updatePosition();
        }
        overlayEl.addEventListener("dblclick", (event) => {
          event.preventDefault();
          beginImageEditing2(image);
        });
        image.addEventListener("load", handleImageChange);
        image.addEventListener(IMAGE_OCCLUSION_EVENT, handleImageChange);
        update();
        return {
          update,
          refresh,
          setSuppressed,
          destroy() {
            boxElements.clear();
            highlightElements.clear();
            textboxElements.clear();
            revealStates.clear();
            overlayEl.remove();
            image.removeEventListener("load", handleImageChange);
            image.removeEventListener(IMAGE_OCCLUSION_EVENT, handleImageChange);
          }
        };
      }
      function ensureOverlay(image) {
        if (!(image instanceof HTMLImageElement)) return null;
        const hasOcclusions = parseImageOcclusions(image).length > 0;
        const hasHighlights = parseImageHighlights(image).length > 0;
        const hasTextboxes = parseImageTextboxes(image).length > 0;
        if (!hasOcclusions && !hasHighlights && !hasTextboxes) {
          removeOverlay(image);
          return null;
        }
        let overlay = overlays.get(image);
        if (!overlay) {
          overlay = createOverlay(image);
          overlays.set(image, overlay);
          if (resizeObserver) {
            try {
              resizeObserver.observe(image);
            } catch (err) {
            }
          }
        } else {
          overlay.refresh();
          overlay.update();
        }
        return overlay;
      }
      function removeOverlay(image) {
        const existing = overlays.get(image);
        if (!existing) return;
        existing.destroy();
        overlays.delete(image);
        if (resizeObserver) {
          try {
            resizeObserver.unobserve(image);
          } catch (err) {
          }
        }
      }
      function sync() {
        const images = Array.from(editable2.querySelectorAll("img"));
        const valid = /* @__PURE__ */ new Set();
        images.forEach((image) => {
          const hasOcclusions = parseImageOcclusions(image).length > 0;
          const hasHighlights = parseImageHighlights(image).length > 0;
          const hasTextboxes = parseImageTextboxes(image).length > 0;
          if (hasOcclusions || hasHighlights || hasTextboxes) {
            valid.add(image);
            ensureOverlay(image);
          }
        });
        overlays.forEach((overlay, image) => {
          if (!valid.has(image)) removeOverlay(image);
        });
      }
      const mutationObserver = new MutationObserver((mutations) => {
        let needsSync = false;
        for (const mutation of mutations) {
          if (mutation.type === "attributes" && (mutation.attributeName === IMAGE_OCCLUSION_ATTR || mutation.attributeName === IMAGE_HIGHLIGHT_ATTR || mutation.attributeName === IMAGE_TEXTBOX_ATTR)) {
            const target = mutation.target;
            if (target instanceof HTMLImageElement) {
              const hasOcclusions = parseImageOcclusions(target).length > 0;
              const hasHighlights = parseImageHighlights(target).length > 0;
              const hasTextboxes = parseImageTextboxes(target).length > 0;
              if (hasOcclusions || hasHighlights || hasTextboxes) {
                ensureOverlay(target);
              } else {
                removeOverlay(target);
              }
            }
          } else {
            needsSync = true;
          }
        }
        if (needsSync) sync();
      });
      mutationObserver.observe(editable2, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: [IMAGE_OCCLUSION_ATTR, IMAGE_HIGHLIGHT_ATTR, IMAGE_TEXTBOX_ATTR]
      });
      const onScroll = () => {
        overlays.forEach((overlay) => overlay.update());
      };
      document.addEventListener("scroll", onScroll, true);
      editable2.addEventListener("scroll", onScroll);
      window.addEventListener("resize", onScroll);
      sync();
      return {
        sync,
        notifyChange(image) {
          const overlay = ensureOverlay(image);
          if (overlay) overlay.refresh();
        },
        suppress(image, suppressed) {
          const overlay = overlays.get(image);
          if (overlay) overlay.setSuppressed(suppressed);
        },
        destroy() {
          try {
            mutationObserver.disconnect();
          } catch (err) {
          }
          document.removeEventListener("scroll", onScroll, true);
          editable2.removeEventListener("scroll", onScroll);
          window.removeEventListener("resize", onScroll);
          overlays.forEach((overlay, image) => {
            try {
              overlay.destroy();
            } catch (err) {
              console.warn("Failed to destroy occlusion overlay", err);
            }
            if (resizeObserver) {
              try {
                resizeObserver.unobserve(image);
              } catch (err) {
              }
            }
          });
          overlays.clear();
          if (resizeObserver) {
            try {
              resizeObserver.disconnect();
            } catch (err) {
            }
          }
        }
      };
    }
    const commandButtons = [];
    let sizeSelect = null;
    let fontSelect = null;
    let fontNameLabel = null;
    let fontSizeLabel = null;
    let clozeButton = null;
    function focusEditor() {
      editable.focus({ preventScroll: false });
    }
    let savedRange = null;
    let suppressSelectionCapture = false;
    function rangeWithinEditor(range, { allowCollapsed = true } = {}) {
      if (!range) return false;
      if (!allowCollapsed && range.collapsed) return false;
      const { startContainer, endContainer } = range;
      if (!startContainer || !endContainer) return false;
      return editable.contains(startContainer) && editable.contains(endContainer);
    }
    function captureSelectionRange() {
      if (suppressSelectionCapture) return;
      const selection = window.getSelection();
      if (!selection?.rangeCount) return;
      const range = selection.getRangeAt(0);
      if (!rangeWithinEditor(range)) return;
      savedRange = range.cloneRange();
    }
    function getSavedRange({ requireSelection = false } = {}) {
      if (!savedRange) return null;
      return rangeWithinEditor(savedRange, { allowCollapsed: !requireSelection }) ? savedRange : null;
    }
    function restoreSavedRange({ requireSelection = false } = {}) {
      const range = getSavedRange({ requireSelection });
      if (!range) return false;
      const selection = window.getSelection();
      if (!selection) return false;
      selection.removeAllRanges();
      const clone6 = range.cloneRange();
      selection.addRange(clone6);
      savedRange = clone6.cloneRange();
      return true;
    }
    function runCommand(action, { requireSelection = false } = {}) {
      const existing = getSavedRange({ requireSelection });
      if (!existing) return false;
      const preservedRange = existing.cloneRange();
      let restored = false;
      suppressSelectionCapture = true;
      try {
        focusEditor();
        savedRange = preservedRange.cloneRange();
        restored = restoreSavedRange({ requireSelection });
      } finally {
        suppressSelectionCapture = false;
      }
      if (!restored) return false;
      let inputFired = false;
      const handleInput = () => {
        inputFired = true;
      };
      editable.addEventListener("input", handleInput, { once: true });
      const result = action();
      editable.removeEventListener("input", handleInput);
      captureSelectionRange();
      if (!inputFired) {
        editable.dispatchEvent(new Event("input", { bubbles: true }));
      }
      updateInlineState();
      return result;
    }
    function exec(command, arg = null, { requireSelection = false, styleWithCss = true } = {}) {
      return runCommand(() => {
        let previousStyleWithCss = null;
        try {
          previousStyleWithCss = document.queryCommandState("styleWithCSS");
        } catch (err) {
          previousStyleWithCss = null;
        }
        try {
          document.execCommand("styleWithCSS", false, styleWithCss);
          return document.execCommand(command, false, arg);
        } finally {
          if (previousStyleWithCss !== null) {
            document.execCommand("styleWithCSS", false, previousStyleWithCss);
          }
        }
      }, { requireSelection });
    }
    function insertPlainText(text) {
      if (text == null) return;
      const normalized2 = String(text).replace(/\r\n/g, "\n");
      runCommand(() => {
        const ok = document.execCommand("insertText", false, normalized2);
        if (ok === false) {
          const html = escapeHtml2(normalized2).replace(/\n/g, "<br>");
          document.execCommand("insertHTML", false, html);
        }
      });
    }
    function insertHtml(html) {
      if (!html) return;
      runCommand(() => document.execCommand("insertHTML", false, html));
    }
    function selectionWithinEditor({ allowCollapsed = true } = {}) {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return false;
      if (!allowCollapsed && selection.isCollapsed) return false;
      const anchor = selection.anchorNode;
      const focus = selection.focusNode;
      if (!anchor || !focus) return false;
      return editable.contains(anchor) && editable.contains(focus);
    }
    function hasActiveSelection() {
      return Boolean(getSavedRange({ requireSelection: true }));
    }
    function collapsedInlineState() {
      const selection = window.getSelection();
      if (!selection?.anchorNode) return null;
      let node = selection.anchorNode;
      const state2 = { bold: false, italic: false, underline: false, strike: false };
      const applyFromElement = (el) => {
        const tag = el.tagName?.toLowerCase();
        if (tag === "b" || tag === "strong") state2.bold = true;
        if (tag === "i" || tag === "em") state2.italic = true;
        if (tag === "u") state2.underline = true;
        if (tag === "s" || tag === "strike" || tag === "del") state2.strike = true;
        if (el instanceof Element) {
          const inlineStyle = el.style;
          if (inlineStyle) {
            if (!state2.bold) {
              const weightRaw = inlineStyle.fontWeight || "";
              const weightText = typeof weightRaw === "string" ? weightRaw.toLowerCase() : `${weightRaw}`.toLowerCase();
              const weightValue = Number.parseInt(weightText, 10);
              if (weightText === "bold" || weightText === "bolder" || Number.isFinite(weightValue) && weightValue >= 600) {
                state2.bold = true;
              }
            }
            if (!state2.italic && inlineStyle.fontStyle === "italic") state2.italic = true;
            const deco = `${inlineStyle.textDecorationLine || inlineStyle.textDecoration || ""}`.toLowerCase();
            if (!state2.underline && deco.includes("underline")) state2.underline = true;
            if (!state2.strike && (deco.includes("line-through") || deco.includes("strikethrough"))) state2.strike = true;
          }
        }
      };
      while (node && node !== editable) {
        if (node.nodeType === Node.TEXT_NODE) {
          node = node.parentNode;
          continue;
        }
        if (!(node instanceof Element)) {
          node = node.parentNode;
          continue;
        }
        applyFromElement(node);
        node = node.parentNode;
      }
      return state2;
    }
    function updateInlineState() {
      const inEditor = selectionWithinEditor();
      const selection = window.getSelection();
      const collapsed = Boolean(selection?.isCollapsed);
      const collapsedState = inEditor && collapsed ? collapsedInlineState() : null;
      commandButtons.forEach(({ btn, command, stateKey }) => {
        let active = false;
        if (inEditor) {
          if (collapsed && collapsedState && stateKey) {
            active = collapsedState[stateKey];
          } else {
            try {
              active = document.queryCommandState(command);
            } catch (err) {
              active = false;
            }
          }
        }
        const isActive = Boolean(active);
        btn.classList.toggle("is-active", isActive);
        btn.dataset.active = isActive ? "true" : "false";
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
      const style = inEditor ? computeSelectionStyle() : null;
      updateTypographyState(style);
      if (clozeButton) {
        const saved = getSavedRange({ requireSelection: false });
        const startNode = saved?.startContainer || null;
        const endNode = saved?.endContainer || null;
        const startCloze = startNode ? findClozeAncestor(startNode) : null;
        const endCloze = endNode ? findClozeAncestor(endNode) : null;
        const active = Boolean(startCloze && startCloze === endCloze);
        clozeButton.classList.toggle("is-active", active);
        clozeButton.dataset.active = active ? "true" : "false";
        clozeButton.setAttribute("aria-pressed", active ? "true" : "false");
      }
    }
    function styleForNode(node) {
      let current = node;
      while (current && current !== editable) {
        if (current instanceof Element) {
          return window.getComputedStyle(current);
        }
        current = current.parentNode;
      }
      if (editable instanceof Element) {
        return window.getComputedStyle(editable);
      }
      return null;
    }
    function computeSelectionStyle() {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return null;
      if (selection.isCollapsed) {
        return styleForNode(selection.anchorNode);
      }
      const range = selection.getRangeAt(0);
      const startStyle = styleForNode(range.startContainer);
      if (startStyle) return startStyle;
      const endStyle = styleForNode(range.endContainer);
      if (endStyle) return endStyle;
      return styleForNode(range.commonAncestorContainer);
    }
    function findClozeAncestor(node) {
      let current = node;
      while (current && current !== editable) {
        if (current instanceof HTMLElement && current.getAttribute?.(CLOZE_ATTR) === CLOZE_VALUE) {
          return current;
        }
        current = current.parentNode;
      }
      return null;
    }
    function unwrapClozeElement(element) {
      const parent = element.parentNode;
      if (!parent) return;
      const selection = window.getSelection();
      const range = document.createRange();
      let firstChild = null;
      let lastChild = null;
      while (element.firstChild) {
        const child = element.firstChild;
        parent.insertBefore(child, element);
        if (!firstChild) firstChild = child;
        lastChild = child;
      }
      const nextSibling = element.nextSibling;
      parent.removeChild(element);
      if (firstChild && lastChild) {
        range.setStartBefore(firstChild);
        range.setEndAfter(lastChild);
      } else {
        const index = Array.prototype.indexOf.call(parent.childNodes, nextSibling);
        range.setStart(parent, index >= 0 ? index : parent.childNodes.length);
        range.collapse(true);
      }
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
    function toggleClozeFormatting() {
      const range = getSavedRange({ requireSelection: false });
      if (!range) return;
      const startCloze = findClozeAncestor(range.startContainer);
      const endCloze = findClozeAncestor(range.endContainer);
      if (startCloze && startCloze === endCloze) {
        runCommand(() => {
          unwrapClozeElement(startCloze);
        });
        return;
      }
      if (range.collapsed) return;
      runCommand(() => {
        const selection = window.getSelection();
        if (!selection?.rangeCount) return;
        const activeRange = selection.getRangeAt(0);
        const fragment = activeRange.extractContents();
        const span = document.createElement("span");
        span.setAttribute(CLOZE_ATTR, CLOZE_VALUE);
        span.appendChild(fragment);
        activeRange.insertNode(span);
        selection.removeAllRanges();
        const newRange = document.createRange();
        newRange.selectNode(span);
        selection.addRange(newRange);
      }, { requireSelection: true });
    }
    function formatFontFamily(value2 = "") {
      if (!value2) return "Default";
      const primary = value2.split(",")[0] || value2;
      return primary.replace(/^['"]+|['"]+$/g, "").trim() || "Default";
    }
    function updateTypographyState(style) {
      if (!fontNameLabel || !fontSizeLabel || !sizeSelect) return;
      const editingSize = document.activeElement === sizeSelect;
      const editingFont = document.activeElement === fontSelect;
      if (!style) {
        fontNameLabel.textContent = "Font: Default";
        fontSizeLabel.textContent = "Size: \u2014";
        if (!editingFont && fontSelect) {
          fontSelect.value = "";
        }
        if (!editingSize) {
          sizeSelect.value = "";
          if (sizeSelect) delete sizeSelect.dataset.customValue;
        }
        return;
      }
      const family = formatFontFamily(style.fontFamily || "");
      const sizeText = style.fontSize || "";
      fontNameLabel.textContent = `Font: ${family}`;
      fontSizeLabel.textContent = `Size: ${sizeText || "\u2014"}`;
      if (!editingFont && fontSelect) {
        const normalized2 = (style.fontFamily || "").trim().toLowerCase();
        const match = FONT_OPTIONS.find((option) => option.value.trim().toLowerCase() === normalized2);
        if (match) {
          fontSelect.value = match.value;
        } else if (normalized2) {
          fontSelect.value = "custom";
          fontSelect.dataset.customValue = style.fontFamily || "";
        } else {
          fontSelect.value = "";
        }
      }
      if (!editingSize) {
        const numeric = Number.parseFloat(sizeText);
        if (Number.isFinite(numeric)) {
          const rounded = Math.round(numeric);
          const optionMatch = FONT_SIZE_VALUES.find((val) => val === rounded);
          if (optionMatch) {
            sizeSelect.value = String(optionMatch);
          } else {
            sizeSelect.value = "custom";
            sizeSelect.dataset.customValue = String(rounded);
          }
        } else {
          sizeSelect.value = "";
          delete sizeSelect.dataset.customValue;
        }
      }
    }
    function collectElementsInRange(range) {
      const elements = [];
      if (!range) return elements;
      const walker = document.createTreeWalker(
        editable,
        NodeFilter.SHOW_ELEMENT,
        {
          acceptNode: (node) => {
            try {
              return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            } catch (err) {
              return NodeFilter.FILTER_SKIP;
            }
          }
        }
      );
      while (walker.nextNode()) {
        elements.push(walker.currentNode);
      }
      return elements;
    }
    function removeFontSizeFromRange(range) {
      const elements = collectElementsInRange(range);
      elements.forEach((node) => {
        if (!(node instanceof HTMLElement)) return;
        if (node.style && node.style.fontSize) {
          node.style.removeProperty("font-size");
          if (!node.style.length) node.removeAttribute("style");
        }
        if (node.tagName?.toLowerCase() === "font") {
          const parent = node.parentNode;
          if (!parent) return;
          while (node.firstChild) parent.insertBefore(node.firstChild, node);
          parent.removeChild(node);
        }
      });
    }
    function removeFontFamilyFromRange(range) {
      const elements = collectElementsInRange(range);
      elements.forEach((node) => {
        if (!(node instanceof HTMLElement)) return;
        if (node.style && node.style.fontFamily) {
          node.style.removeProperty("font-family");
          if (!node.style.length) node.removeAttribute("style");
        }
        if (node.tagName?.toLowerCase() === "font") {
          const parent = node.parentNode;
          if (!parent) return;
          while (node.firstChild) parent.insertBefore(node.firstChild, node);
          parent.removeChild(node);
        }
      });
    }
    function applyFontSizeValue(value2) {
      runCommand(() => {
        const selection = window.getSelection();
        if (!selection?.rangeCount) return;
        const range = selection.getRangeAt(0);
        removeFontSizeFromRange(range);
        const numeric = Number.parseFloat(value2);
        const hasSize = Number.isFinite(numeric) && numeric > 0;
        if (!hasSize) {
          return;
        }
        document.execCommand("styleWithCSS", false, true);
        document.execCommand("fontSize", false, 4);
        const fonts = editable.querySelectorAll("font");
        fonts.forEach((node) => {
          const parent = node.parentNode;
          if (!parent) return;
          const span = document.createElement("span");
          span.style.fontSize = `${numeric}px`;
          while (node.firstChild) span.appendChild(node.firstChild);
          parent.replaceChild(span, node);
        });
      }, { requireSelection: true });
    }
    function applyFontFamilyValue(value2) {
      runCommand(() => {
        const selection = window.getSelection();
        if (!selection?.rangeCount) return;
        const range = selection.getRangeAt(0);
        removeFontFamilyFromRange(range);
        const trimmed = typeof value2 === "string" ? value2.trim() : "";
        if (!trimmed) {
          return;
        }
        document.execCommand("styleWithCSS", false, true);
        document.execCommand("fontName", false, trimmed);
        const fonts = editable.querySelectorAll("font");
        fonts.forEach((node) => {
          const parent = node.parentNode;
          if (!parent) return;
          const span = document.createElement("span");
          span.style.fontFamily = trimmed;
          while (node.firstChild) span.appendChild(node.firstChild);
          parent.replaceChild(span, node);
        });
      }, { requireSelection: true });
    }
    function createGroup(extraClass) {
      const group = document.createElement("div");
      group.className = "rich-editor-group";
      if (extraClass) group.classList.add(extraClass);
      toolbar.appendChild(group);
      return group;
    }
    const inlineGroup = createGroup();
    [
      ["B", "Bold", "bold", "bold"],
      ["I", "Italic", "italic", "italic"],
      ["U", "Underline", "underline", "underline"],
      ["S", "Strikethrough", "strikeThrough", "strike"]
    ].forEach(([label, title, command, stateKey]) => {
      const btn = createToolbarButton(label, title, () => exec(command));
      btn.dataset.command = command;
      commandButtons.push({ btn, command, stateKey });
      inlineGroup.appendChild(btn);
    });
    const colorWrap = document.createElement("label");
    colorWrap.className = "rich-editor-color";
    colorWrap.title = "Text color";
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = "#ffffff";
    colorInput.dataset.lastColor = "#ffffff";
    colorInput.addEventListener("input", () => {
      if (!getSavedRange({ requireSelection: true })) {
        const previous = colorInput.dataset.lastColor || "#ffffff";
        colorInput.value = previous;
        return;
      }
      exec("foreColor", colorInput.value, { requireSelection: true });
      colorInput.dataset.lastColor = colorInput.value;
    });
    colorWrap.appendChild(colorInput);
    const colorGroup = createGroup("rich-editor-color-group");
    colorGroup.appendChild(colorWrap);
    const highlightRow = document.createElement("div");
    highlightRow.className = "rich-editor-highlight-row";
    colorGroup.appendChild(highlightRow);
    const highlightColors = [
      ["#facc15", "Yellow"],
      ["#f472b6", "Pink"],
      ["#f87171", "Red"],
      ["#4ade80", "Green"],
      ["#38bdf8", "Blue"]
    ];
    function applyHighlight(color) {
      if (!getSavedRange({ requireSelection: true })) return;
      exec("hiliteColor", color, { requireSelection: true });
    }
    const clearSwatch = document.createElement("button");
    clearSwatch.type = "button";
    clearSwatch.className = "rich-editor-swatch rich-editor-swatch--clear";
    clearSwatch.title = "Remove highlight";
    clearSwatch.setAttribute("aria-label", "Remove highlight");
    clearSwatch.textContent = "\xD7";
    clearSwatch.addEventListener("mousedown", (e) => e.preventDefault());
    clearSwatch.addEventListener("click", () => {
      exec("hiliteColor", "transparent", { requireSelection: true });
    });
    highlightRow.appendChild(clearSwatch);
    highlightColors.forEach(([color, label]) => {
      const swatch = document.createElement("button");
      swatch.type = "button";
      swatch.className = "rich-editor-swatch";
      swatch.style.setProperty("--swatch-color", color);
      swatch.title = `${label} highlight`;
      swatch.setAttribute("aria-label", `${label} highlight`);
      swatch.addEventListener("mousedown", (e) => e.preventDefault());
      swatch.addEventListener("click", () => applyHighlight(color));
      highlightRow.appendChild(swatch);
    });
    const listGroup = createGroup("rich-editor-list-group");
    function applyOrderedStyle(style) {
      const selection = window.getSelection();
      if (!selection?.rangeCount) return;
      let node = selection.getRangeAt(0).startContainer;
      if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;
      while (node && node !== editable) {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName?.toLowerCase() === "ol") {
          if (style) node.style.listStyleType = style;
          else node.style.removeProperty("list-style-type");
          break;
        }
        node = node.parentNode;
      }
    }
    function insertOrdered(style) {
      runCommand(() => {
        document.execCommand("styleWithCSS", false, false);
        document.execCommand("insertOrderedList", false, null);
        if (style) applyOrderedStyle(style);
      });
    }
    const listButtons = [
      ["\u2022", "Bulleted list", () => exec("insertUnorderedList", null, { styleWithCss: false })],
      ["1.", "Numbered list", () => insertOrdered("")],
      ["a.", "Lettered list", () => insertOrdered("lower-alpha")],
      ["i.", "Roman numeral list", () => insertOrdered("lower-roman")]
    ];
    listButtons.forEach(([label, title, handler]) => {
      const btn = createToolbarButton(label, title, handler);
      listGroup.appendChild(btn);
    });
    const typographyGroup = createGroup("rich-editor-typography-group");
    const fontInfo = document.createElement("div");
    fontInfo.className = "rich-editor-font-info";
    fontNameLabel = document.createElement("span");
    fontNameLabel.className = "rich-editor-font-name";
    fontNameLabel.textContent = "Font: Default";
    fontInfo.appendChild(fontNameLabel);
    fontSizeLabel = document.createElement("span");
    fontSizeLabel.className = "rich-editor-font-size";
    fontSizeLabel.textContent = "Size: \u2014";
    fontInfo.appendChild(fontSizeLabel);
    typographyGroup.appendChild(fontInfo);
    fontSelect = document.createElement("select");
    fontSelect.className = "rich-editor-select rich-editor-font-select";
    fontSelect.setAttribute("aria-label", "Font family");
    FONT_OPTIONS.forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = option.label;
      fontSelect.appendChild(opt);
    });
    const customFontOption = document.createElement("option");
    customFontOption.value = "custom";
    customFontOption.textContent = "Custom\u2026";
    fontSelect.appendChild(customFontOption);
    ["mousedown", "focus", "keydown"].forEach((evt) => {
      fontSelect.addEventListener(evt, () => captureSelectionRange());
    });
    fontSelect.addEventListener("change", () => {
      if (!hasActiveSelection()) {
        updateInlineState();
        return;
      }
      let selected = fontSelect.value;
      if (selected === "custom") {
        const current = fontSelect.dataset.customValue || "";
        const custom = prompt("Enter font family (CSS value)", current || "");
        if (!custom) {
          updateInlineState();
          return;
        }
        fontSelect.dataset.customValue = custom;
        selected = custom;
      } else if (!selected) {
        delete fontSelect.dataset.customValue;
      }
      applyFontFamilyValue(selected);
      focusEditor();
    });
    typographyGroup.appendChild(fontSelect);
    sizeSelect = document.createElement("select");
    sizeSelect.className = "rich-editor-select rich-editor-size";
    sizeSelect.setAttribute("aria-label", "Font size");
    const defaultSizeOption = document.createElement("option");
    defaultSizeOption.value = "";
    defaultSizeOption.textContent = "Size";
    sizeSelect.appendChild(defaultSizeOption);
    FONT_SIZE_VALUES.forEach((val) => {
      const opt = document.createElement("option");
      opt.value = String(val);
      opt.textContent = `${val}px`;
      sizeSelect.appendChild(opt);
    });
    const customSizeOption = document.createElement("option");
    customSizeOption.value = "custom";
    customSizeOption.textContent = "Custom\u2026";
    sizeSelect.appendChild(customSizeOption);
    ["mousedown", "focus", "keydown"].forEach((evt) => {
      sizeSelect.addEventListener(evt, () => captureSelectionRange());
    });
    sizeSelect.addEventListener("change", () => {
      if (!hasActiveSelection()) {
        updateInlineState();
        return;
      }
      let selected = sizeSelect.value;
      if (selected === "custom") {
        const current = sizeSelect.dataset.customValue || "";
        const custom = prompt("Enter font size in pixels", current || "16");
        const numeric = Number.parseFloat(custom || "");
        if (!custom || !Number.isFinite(numeric) || numeric <= 0) {
          updateInlineState();
          return;
        }
        const rounded = Math.round(numeric);
        sizeSelect.dataset.customValue = String(rounded);
        selected = String(rounded);
      } else if (!selected) {
        delete sizeSelect.dataset.customValue;
      }
      applyFontSizeValue(selected || null);
      focusEditor();
    });
    typographyGroup.appendChild(sizeSelect);
    const resetSizeBtn = createToolbarButton("\u21BA", "Reset font size", () => {
      if (!hasActiveSelection()) return;
      sizeSelect.value = "";
      delete sizeSelect.dataset.customValue;
      applyFontSizeValue(null);
      focusEditor();
    });
    typographyGroup.appendChild(resetSizeBtn);
    const mediaGroup = createGroup("rich-editor-media-group");
    const linkBtn = createToolbarButton("\u{1F517}", "Insert link", () => {
      if (!hasActiveSelection()) return;
      const url = prompt("Enter URL");
      if (!url) return;
      exec("createLink", url, { requireSelection: true });
    });
    mediaGroup.appendChild(linkBtn);
    const imageBtn = createToolbarButton("\u{1F5BC}", "Upload image (Shift+Click for URL)", (event) => {
      if (event.shiftKey) {
        const url = prompt("Enter image URL");
        if (!url) return;
        exec("insertImage", url, { styleWithCss: false });
        return;
      }
      imageFileInput.click();
    });
    mediaGroup.appendChild(imageBtn);
    const mediaBtn = createToolbarButton("\u{1F3AC}", "Upload media (Shift+Click for URL)", (event) => {
      if (event.shiftKey) {
        const url = prompt("Enter media URL");
        if (!url) return;
        const typePrompt = prompt("Media type (video/audio/embed)", "video");
        const kind = (typePrompt || "video").toLowerCase();
        const safeUrl = escapeHtml2(url);
        let html = "";
        if (kind.startsWith("a")) {
          html = `<audio controls src="${safeUrl}"></audio>`;
        } else if (kind.startsWith("e") || kind.startsWith("i")) {
          html = `<iframe src="${safeUrl}" title="Embedded media" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`;
        } else {
          html = `<video controls src="${safeUrl}"></video>`;
        }
        insertHtml(html);
        return;
      }
      mediaFileInput.click();
    });
    mediaGroup.appendChild(mediaBtn);
    const clozeTool = createToolbarButton("\u29C9", "Toggle cloze (hide selected text until clicked)", () => {
      toggleClozeFormatting();
      focusEditor();
    });
    clozeButton = clozeTool;
    const clearBtn = createToolbarButton("\u232B", "Clear formatting", () => exec("removeFormat", null, { requireSelection: true, styleWithCss: false }));
    const utilityGroup = createGroup("rich-editor-utility-group");
    utilityGroup.appendChild(clozeTool);
    utilityGroup.appendChild(clearBtn);
    let settingValue = false;
    editable.addEventListener("input", () => {
      if (settingValue) return;
      if (typeof onChange === "function") onChange();
      updateInlineState();
    });
    editable.addEventListener("dblclick", (event) => {
      const path = typeof event.composedPath === "function" ? event.composedPath() : [];
      const target = path.find((node) => node instanceof HTMLImageElement) || event.target;
      if (target instanceof HTMLImageElement) {
        event.preventDefault();
        event.stopPropagation();
        beginImageEditing(target);
      }
    });
    ["keyup", "mouseup", "focus"].forEach((event) => {
      editable.addEventListener(event, () => updateInlineState());
    });
    editable.addEventListener("blur", () => {
      setTimeout(() => updateInlineState(), 0);
    });
    const selectionHandler = () => {
      if (!document.body.contains(wrapper)) {
        document.removeEventListener("selectionchange", selectionHandler);
        destroyActiveImageEditor();
        return;
      }
      captureSelectionRange();
      updateInlineState();
    };
    document.addEventListener("selectionchange", selectionHandler);
    updateInlineState();
    return {
      element: wrapper,
      getValue() {
        const sanitized = sanitizeHtml(editable.innerHTML);
        return isEmptyHtml(sanitized) ? "" : sanitized;
      },
      setValue(val) {
        settingValue = true;
        destroyActiveImageEditor();
        editable.innerHTML = normalizeInput(val);
        settingValue = false;
        if (occlusionDisplayManager) occlusionDisplayManager.sync();
        updateInlineState();
      },
      focus() {
        focusEditor();
      },
      destroy() {
        document.removeEventListener("selectionchange", selectionHandler);
        destroyActiveImageEditor();
        if (occlusionDisplayManager && typeof occlusionDisplayManager.destroy === "function") {
          occlusionDisplayManager.destroy();
        }
        occlusionDisplayManager = null;
      }
    };
  }
  function closeImageLightbox() {
    if (!activeImageLightbox) return;
    window.removeEventListener("keydown", activeImageLightbox.onKeyDown);
    window.removeEventListener("resize", activeImageLightbox.onResize);
    if (activeImageLightbox.element && activeImageLightbox.element.parentNode) {
      activeImageLightbox.element.parentNode.removeChild(activeImageLightbox.element);
    }
    activeImageLightbox = null;
  }
  function openImageLightbox(image) {
    if (!(image instanceof HTMLImageElement)) return;
    closeImageLightbox();
    const overlay = document.createElement("div");
    overlay.className = "image-lightbox";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    const backdrop = document.createElement("div");
    backdrop.className = "image-lightbox-backdrop";
    overlay.appendChild(backdrop);
    const frame = document.createElement("div");
    frame.className = "image-lightbox-frame";
    overlay.appendChild(frame);
    const dragHandle = document.createElement("div");
    dragHandle.className = "image-lightbox-drag-handle";
    dragHandle.setAttribute("aria-hidden", "true");
    frame.appendChild(dragHandle);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "image-lightbox-close";
    closeBtn.setAttribute("aria-label", "Close image");
    closeBtn.innerHTML = "\u2715";
    frame.appendChild(closeBtn);
    const surface = document.createElement("div");
    surface.className = "image-lightbox-surface";
    frame.appendChild(surface);
    const cloned = image.cloneNode(true);
    cloned.removeAttribute("width");
    cloned.removeAttribute("height");
    cloned.classList.add("image-lightbox-img");
    cloned.style.width = "100%";
    cloned.style.height = "100%";
    cloned.style.objectFit = "contain";
    surface.appendChild(cloned);
    cloned.addEventListener("dblclick", (event) => {
      event.preventDefault();
      event.stopPropagation();
      closeImageLightbox();
    });
    const highlightLayer = document.createElement("div");
    highlightLayer.className = "image-annotation-layer image-highlight-layer";
    highlightLayer.hidden = true;
    surface.appendChild(highlightLayer);
    const textLayer = document.createElement("div");
    textLayer.className = "image-annotation-layer image-text-layer";
    textLayer.hidden = true;
    surface.appendChild(textLayer);
    const layer = document.createElement("div");
    layer.className = "image-lightbox-occlusions image-occlusion-layer";
    layer.hidden = true;
    surface.appendChild(layer);
    const boxElements = /* @__PURE__ */ new Map();
    const highlightElements = /* @__PURE__ */ new Map();
    const textboxElements = /* @__PURE__ */ new Map();
    const revealStates = /* @__PURE__ */ new Map();
    let framePosition = { left: null, top: null };
    let dragPointerId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    function setFramePosition(left, top) {
      const width = frame.offsetWidth || 0;
      const height = frame.offsetHeight || 0;
      const margin = 24;
      const minLeft = margin;
      const minTop = margin;
      const maxLeft = Math.max(minLeft, window.innerWidth - width - margin);
      const maxTop = Math.max(minTop, window.innerHeight - height - margin);
      const boundedLeft = Math.min(Math.max(left, minLeft), maxLeft);
      const boundedTop = Math.min(Math.max(top, minTop), maxTop);
      frame.style.left = `${Math.round(boundedLeft)}px`;
      frame.style.top = `${Math.round(boundedTop)}px`;
      framePosition = {
        left: Math.round(boundedLeft),
        top: Math.round(boundedTop)
      };
    }
    function centerFrame() {
      const width = frame.offsetWidth || 0;
      const height = frame.offsetHeight || 0;
      const left = (window.innerWidth - width) / 2;
      const top = (window.innerHeight - height) / 2;
      setFramePosition(left, top);
    }
    function applyFrameLayout() {
      const viewportWidth = window.innerWidth || 1280;
      const viewportHeight = window.innerHeight || 720;
      const margin = 48;
      const maxWidth = Math.max(360, viewportWidth - margin);
      const maxHeight = Math.max(280, viewportHeight - margin);
      const targetWidth = Math.min(
        Math.max(560, viewportWidth * 0.82),
        maxWidth,
        1280
      );
      const targetHeight = Math.min(
        Math.max(420, viewportHeight * 0.82),
        maxHeight,
        900
      );
      frame.style.width = `${Math.round(targetWidth)}px`;
      frame.style.height = `${Math.round(targetHeight)}px`;
      surface.style.width = "100%";
      surface.style.height = "100%";
    }
    function refreshLayout({ forceCenter = false } = {}) {
      applyFrameLayout();
      if (forceCenter || framePosition.left == null || framePosition.top == null) {
        centerFrame();
      } else {
        setFramePosition(framePosition.left, framePosition.top);
      }
    }
    function startDrag(event) {
      if (event.button !== 0) return;
      event.preventDefault();
      const rect = frame.getBoundingClientRect();
      dragPointerId = event.pointerId;
      dragOffsetX = event.clientX - rect.left;
      dragOffsetY = event.clientY - rect.top;
      frame.setPointerCapture(dragPointerId);
    }
    function handleDrag(event) {
      if (dragPointerId == null || event.pointerId !== dragPointerId) return;
      event.preventDefault();
      setFramePosition(event.clientX - dragOffsetX, event.clientY - dragOffsetY);
    }
    function stopDrag(event) {
      if (dragPointerId == null || event.pointerId !== dragPointerId) return;
      event.preventDefault();
      frame.releasePointerCapture(dragPointerId);
      dragPointerId = null;
      if (framePosition.left == null || framePosition.top == null) {
        centerFrame();
      } else {
        setFramePosition(framePosition.left, framePosition.top);
      }
    }
    dragHandle.addEventListener("pointerdown", startDrag);
    frame.addEventListener("pointermove", handleDrag);
    frame.addEventListener("pointerup", stopDrag);
    frame.addEventListener("pointercancel", stopDrag);
    function toggleReveal(element) {
      const id = element?.dataset?.id;
      if (!id) return;
      const next = !(revealStates.get(id) === true);
      revealStates.set(id, next);
      setOcclusionRevealState(element, next);
    }
    function updateBoxes() {
      const metrics = resolveImageMetrics(cloned);
      const occlusions = parseImageOcclusions(cloned);
      const seen = /* @__PURE__ */ new Set();
      occlusions.forEach((box) => {
        let element = boxElements.get(box.id);
        if (!element) {
          element = document.createElement("div");
          element.className = "image-occlusion-box";
          element.dataset.id = box.id;
          element.tabIndex = 0;
          element.setAttribute("role", "button");
          element.setAttribute("aria-pressed", "false");
          element.setAttribute("aria-label", "Toggle occlusion");
          element.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleReveal(element);
          });
          element.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              toggleReveal(element);
            }
          });
          layer.appendChild(element);
          boxElements.set(box.id, element);
        }
        applyOcclusionBoxGeometry(element, box, metrics || cloned);
        const revealed = revealStates.get(box.id) === true;
        setOcclusionRevealState(element, revealed);
        seen.add(box.id);
      });
      boxElements.forEach((element, id) => {
        if (!seen.has(id)) {
          element.remove();
          boxElements.delete(id);
          revealStates.delete(id);
        }
      });
      layer.hidden = boxElements.size === 0;
      layer.classList.toggle("is-active", boxElements.size > 0);
    }
    function updateHighlights() {
      const metrics = resolveImageMetrics(cloned);
      const highlights = parseImageHighlights(cloned);
      const seen = /* @__PURE__ */ new Set();
      highlights.forEach((box) => {
        let element = highlightElements.get(box.id);
        if (!element) {
          element = document.createElement("div");
          element.className = "image-highlight-box";
          element.dataset.id = box.id;
          highlightLayer.appendChild(element);
          highlightElements.set(box.id, element);
        }
        element.style.borderColor = box.color;
        element.style.backgroundColor = highlightColorToRgba(box.color, 0.35);
        applyOcclusionBoxGeometry(element, box, metrics || cloned);
        seen.add(box.id);
      });
      highlightElements.forEach((element, id) => {
        if (!seen.has(id)) {
          element.remove();
          highlightElements.delete(id);
        }
      });
      highlightLayer.hidden = highlightElements.size === 0;
    }
    function updateTextboxes() {
      const metrics = resolveImageMetrics(cloned);
      const textboxes = parseImageTextboxes(cloned);
      const seen = /* @__PURE__ */ new Set();
      textboxes.forEach((box) => {
        let element = textboxElements.get(box.id);
        if (!element) {
          element = document.createElement("div");
          element.className = "image-textbox";
          element.dataset.id = box.id;
          const content2 = document.createElement("div");
          content2.className = "image-textbox-content";
          content2.setAttribute("aria-hidden", "true");
          element.appendChild(content2);
          textLayer.appendChild(element);
          textboxElements.set(box.id, element);
        }
        const content = element.querySelector(".image-textbox-content");
        if (content && (content.textContent || "") !== (box.text || "")) {
          content.textContent = box.text || "";
        }
        applyOcclusionBoxGeometry(element, box, metrics || cloned);
        seen.add(box.id);
      });
      textboxElements.forEach((element, id) => {
        if (!seen.has(id)) {
          element.remove();
          textboxElements.delete(id);
        }
      });
      textLayer.hidden = textboxElements.size === 0;
    }
    function updateAll() {
      updateBoxes();
      updateHighlights();
      updateTextboxes();
    }
    const onKeyDown = (event) => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeImageLightbox();
      }
    };
    const onResize = () => {
      refreshLayout();
      updateAll();
    };
    closeBtn.addEventListener("click", () => closeImageLightbox());
    overlay.addEventListener("click", (event) => {
      if (event.target === overlay || event.target === backdrop) {
        closeImageLightbox();
      }
    });
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("resize", onResize);
    cloned.addEventListener("load", () => updateAll());
    document.body.appendChild(overlay);
    requestAnimationFrame(() => {
      refreshLayout({ forceCenter: true });
      updateAll();
    });
    activeImageLightbox = {
      element: overlay,
      onKeyDown,
      onResize
    };
  }
  function createRichContentImageManager(container, options = {}) {
    const { enableLightbox = true } = options;
    const overlays = /* @__PURE__ */ new Map();
    const clickHandlers = /* @__PURE__ */ new Map();
    const images = Array.from(container.querySelectorAll("img"));
    const resizeObserver = typeof ResizeObserver === "function" ? new ResizeObserver((entries) => {
      for (const entry of entries) {
        const image = entry.target;
        const overlay = overlays.get(image);
        if (overlay) overlay.update();
      }
    }) : null;
    function createDisplayOverlay(image) {
      const overlayEl = document.createElement("div");
      overlayEl.className = "rich-content-occlusion-overlay";
      overlayEl.setAttribute("aria-hidden", "true");
      const highlightLayer = document.createElement("div");
      highlightLayer.className = "image-annotation-layer image-highlight-layer";
      overlayEl.appendChild(highlightLayer);
      const textLayer = document.createElement("div");
      textLayer.className = "image-annotation-layer image-text-layer";
      overlayEl.appendChild(textLayer);
      const layer = document.createElement("div");
      layer.className = "image-occlusion-layer";
      overlayEl.appendChild(layer);
      container.appendChild(overlayEl);
      const boxElements = /* @__PURE__ */ new Map();
      const highlightElements = /* @__PURE__ */ new Map();
      const textboxElements = /* @__PURE__ */ new Map();
      const revealStates = /* @__PURE__ */ new Map();
      function toggleReveal(element) {
        const id = element?.dataset?.id;
        if (!id) return;
        const next = !(revealStates.get(id) === true);
        revealStates.set(id, next);
        setOcclusionRevealState(element, next);
      }
      function updatePosition() {
        if (!container.contains(image)) {
          destroy();
          return;
        }
        const rect = image.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        overlayEl.style.width = `${rect.width}px`;
        overlayEl.style.height = `${rect.height}px`;
        overlayEl.style.left = `${rect.left - containerRect.left}px`;
        overlayEl.style.top = `${rect.top - containerRect.top}px`;
      }
      function updateOcclusions() {
        const metrics = resolveImageMetrics(image);
        const occlusions = parseImageOcclusions(image);
        const seen = /* @__PURE__ */ new Set();
        occlusions.forEach((box) => {
          let element = boxElements.get(box.id);
          if (!element) {
            element = document.createElement("div");
            element.className = "image-occlusion-box";
            element.dataset.id = box.id;
            element.tabIndex = 0;
            element.setAttribute("role", "button");
            element.setAttribute("aria-pressed", "false");
            element.setAttribute("aria-label", "Toggle occlusion");
            element.addEventListener("click", (event) => {
              event.preventDefault();
              event.stopPropagation();
              toggleReveal(element);
            });
            element.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                toggleReveal(element);
              }
            });
            layer.appendChild(element);
            boxElements.set(box.id, element);
          }
          applyOcclusionBoxGeometry(element, box, metrics || image);
          const revealed = revealStates.get(box.id) === true;
          setOcclusionRevealState(element, revealed);
          seen.add(box.id);
        });
        boxElements.forEach((element, id) => {
          if (!seen.has(id)) {
            element.remove();
            boxElements.delete(id);
            revealStates.delete(id);
          }
        });
      }
      function updateHighlights() {
        const metrics = resolveImageMetrics(image);
        const highlights = parseImageHighlights(image);
        const seen = /* @__PURE__ */ new Set();
        highlights.forEach((box) => {
          let element = highlightElements.get(box.id);
          if (!element) {
            element = document.createElement("div");
            element.className = "image-highlight-box";
            element.dataset.id = box.id;
            highlightLayer.appendChild(element);
            highlightElements.set(box.id, element);
          }
          element.style.borderColor = box.color;
          element.style.backgroundColor = highlightColorToRgba(box.color, 0.35);
          applyOcclusionBoxGeometry(element, box, metrics || image);
          seen.add(box.id);
        });
        highlightElements.forEach((element, id) => {
          if (!seen.has(id)) {
            element.remove();
            highlightElements.delete(id);
          }
        });
        highlightLayer.classList.toggle("is-hidden", highlightElements.size === 0);
      }
      function updateTextboxes() {
        const metrics = resolveImageMetrics(image);
        const textboxes = parseImageTextboxes(image);
        const seen = /* @__PURE__ */ new Set();
        textboxes.forEach((box) => {
          let element = textboxElements.get(box.id);
          if (!element) {
            element = document.createElement("div");
            element.className = "image-textbox";
            element.dataset.id = box.id;
            const content2 = document.createElement("div");
            content2.className = "image-textbox-content";
            content2.setAttribute("aria-hidden", "true");
            element.appendChild(content2);
            textLayer.appendChild(element);
            textboxElements.set(box.id, element);
          }
          const content = element.querySelector(".image-textbox-content");
          if (content && (content.textContent || "") !== (box.text || "")) {
            content.textContent = box.text || "";
          }
          applyOcclusionBoxGeometry(element, box, metrics || image);
          seen.add(box.id);
        });
        textboxElements.forEach((element, id) => {
          if (!seen.has(id)) {
            element.remove();
            textboxElements.delete(id);
          }
        });
        textLayer.classList.toggle("is-hidden", textboxElements.size === 0);
      }
      function updateVisibility() {
        const hasOcclusions = boxElements.size > 0;
        const hasHighlights = highlightElements.size > 0;
        const hasTextboxes = textboxElements.size > 0;
        overlayEl.classList.toggle("is-hidden", !hasOcclusions && !hasHighlights && !hasTextboxes);
      }
      function update() {
        updatePosition();
        updateOcclusions();
        updateHighlights();
        updateTextboxes();
        updateVisibility();
      }
      const handleChange = () => {
        revealStates.clear();
        updateOcclusions();
        updateHighlights();
        updateTextboxes();
        updateVisibility();
        updatePosition();
      };
      function destroy() {
        boxElements.clear();
        highlightElements.clear();
        textboxElements.clear();
        revealStates.clear();
        overlayEl.remove();
        image.removeEventListener("load", update);
        image.removeEventListener(IMAGE_OCCLUSION_EVENT, handleChange);
      }
      image.addEventListener("load", update);
      image.addEventListener(IMAGE_OCCLUSION_EVENT, handleChange);
      update();
      return { update, destroy };
    }
    function setupImage(image) {
      if (!(image instanceof HTMLImageElement)) return;
      if (enableLightbox) {
        const handler = (event) => {
          event.preventDefault();
          openImageLightbox(image);
        };
        image.addEventListener("dblclick", handler);
        clickHandlers.set(image, handler);
        image.classList.add("rich-content-image-interactive");
      }
      const hasOcclusions = parseImageOcclusions(image).length > 0;
      const hasHighlights = parseImageHighlights(image).length > 0;
      const hasTextboxes = parseImageTextboxes(image).length > 0;
      if (hasOcclusions || hasHighlights || hasTextboxes) {
        const overlay = createDisplayOverlay(image);
        overlays.set(image, overlay);
        if (resizeObserver) {
          try {
            resizeObserver.observe(image);
          } catch (err) {
          }
        }
      }
    }
    images.forEach(setupImage);
    function updateAll() {
      overlays.forEach((overlay) => overlay.update());
    }
    const onScroll = () => updateAll();
    document.addEventListener("scroll", onScroll, true);
    container.addEventListener("scroll", onScroll);
    window.addEventListener("resize", updateAll);
    return {
      destroy() {
        document.removeEventListener("scroll", onScroll, true);
        container.removeEventListener("scroll", onScroll);
        window.removeEventListener("resize", updateAll);
        if (resizeObserver) resizeObserver.disconnect();
        overlays.forEach((overlay, image) => {
          overlay.destroy();
          if (resizeObserver) {
            try {
              resizeObserver.unobserve(image);
            } catch (err) {
            }
          }
        });
        overlays.clear();
        clickHandlers.forEach((handler, image) => {
          image.removeEventListener("dblclick", handler);
          image.classList.remove("rich-content-image-interactive");
        });
        clickHandlers.clear();
      }
    };
  }
  function enhanceRichContentImages(target, options = {}) {
    if (!target) return;
    closeImageLightbox();
    const existing = richContentManagers.get(target);
    if (existing && typeof existing.destroy === "function") {
      existing.destroy();
      richContentManagers.delete(target);
    }
    if (!target.querySelector("img")) {
      return;
    }
    const manager = createRichContentImageManager(target, options);
    richContentManagers.set(target, manager);
  }
  function setClozeState(node, state2) {
    if (!(node instanceof HTMLElement)) return;
    const next = state2 === CLOZE_STATE_REVEALED ? CLOZE_STATE_REVEALED : CLOZE_STATE_HIDDEN;
    node.setAttribute("data-cloze-state", next);
    if (next === CLOZE_STATE_REVEALED) {
      node.classList.add("is-cloze-revealed");
      node.classList.remove("is-cloze-hidden");
    } else {
      node.classList.add("is-cloze-hidden");
      node.classList.remove("is-cloze-revealed");
    }
    if (node.classList.contains("cloze-text-interactive")) {
      node.setAttribute("aria-pressed", next === CLOZE_STATE_REVEALED ? "true" : "false");
    } else if (node.hasAttribute("aria-pressed")) {
      node.removeAttribute("aria-pressed");
    }
  }
  function toggleCloze(node) {
    if (!(node instanceof HTMLElement)) return;
    const current = node.getAttribute("data-cloze-state");
    const next = current === CLOZE_STATE_REVEALED ? CLOZE_STATE_HIDDEN : CLOZE_STATE_REVEALED;
    setClozeState(node, next);
  }
  function handleClozeClick(event) {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    const cloze = target.closest(CLOZE_SELECTOR);
    if (!cloze) return;
    event.stopPropagation();
    toggleCloze(cloze);
  }
  function handleClozeKey(event) {
    if (event.key !== "Enter" && event.key !== " ") return;
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    const cloze = target.closest(CLOZE_SELECTOR);
    if (!cloze) return;
    event.preventDefault();
    event.stopPropagation();
    toggleCloze(cloze);
  }
  function detachClozeHandlers(container) {
    const handlers = container.__clozeHandlers;
    if (!handlers) return;
    container.removeEventListener("click", handlers.click);
    container.removeEventListener("keydown", handlers.key);
    delete container.__clozeHandlers;
  }
  function enhanceClozeContent(target, { clozeMode = "static" } = {}) {
    const nodes = target.querySelectorAll(CLOZE_SELECTOR);
    if (!nodes.length) {
      target.classList.remove("rich-content-with-cloze");
      detachClozeHandlers(target);
      return;
    }
    target.classList.add("rich-content-with-cloze");
    const interactive = clozeMode === "interactive";
    nodes.forEach((node) => {
      node.classList.add("cloze-text");
      if (interactive) {
        node.classList.add("cloze-text-interactive");
        if (!node.hasAttribute("tabindex")) node.setAttribute("tabindex", "0");
        node.setAttribute("role", "button");
        const current = node.getAttribute("data-cloze-state");
        if (current !== CLOZE_STATE_REVEALED && current !== CLOZE_STATE_HIDDEN) {
          setClozeState(node, CLOZE_STATE_HIDDEN);
        } else {
          setClozeState(node, current);
        }
      } else {
        node.classList.remove("cloze-text-interactive");
        if (node.getAttribute("tabindex") === "0") node.removeAttribute("tabindex");
        if (node.getAttribute("role") === "button") node.removeAttribute("role");
        setClozeState(node, CLOZE_STATE_REVEALED);
      }
    });
    if (interactive) {
      if (!target.__clozeHandlers) {
        const handlers = {
          click: handleClozeClick,
          key: handleClozeKey
        };
        target.addEventListener("click", handlers.click);
        target.addEventListener("keydown", handlers.key);
        target.__clozeHandlers = handlers;
      }
    } else {
      detachClozeHandlers(target);
    }
  }
  function normalizedFromCache(value) {
    if (!value) return "";
    const key = typeof value === "string" ? value : null;
    if (key !== null && richTextCache.has(key)) {
      return richTextCache.get(key);
    }
    const normalized2 = normalizeInput(value);
    if (key !== null && key.length <= 2e4) {
      if (!richTextCache.has(key)) {
        richTextCacheKeys.push(key);
        if (richTextCacheKeys.length > RICH_TEXT_CACHE_LIMIT) {
          const oldest = richTextCacheKeys.shift();
          if (oldest != null) richTextCache.delete(oldest);
        }
      }
      richTextCache.set(key, normalized2);
    }
    return normalized2;
  }
  function renderRichText(target, value, options = {}) {
    const normalized2 = normalizedFromCache(value);
    if (!normalized2) {
      const existing = richContentManagers.get(target);
      if (existing && typeof existing.destroy === "function") {
        existing.destroy();
        richContentManagers.delete(target);
      }
      target.textContent = "";
      target.classList.remove("rich-content");
      detachClozeHandlers(target);
      return;
    }
    target.classList.add("rich-content");
    target.innerHTML = normalized2;
    enhanceClozeContent(target, options);
    enhanceRichContentImages(target, options);
  }
  function hasRichTextContent(value) {
    return !isEmptyHtml(normalizeInput(value));
  }
  var allowedTags, allowedAttributes, allowedStyles, RICH_TEXT_CACHE_LIMIT, richTextCache, richTextCacheKeys, htmlEntityDecoder, IMAGE_OCCLUSION_ATTR, IMAGE_HIGHLIGHT_ATTR, IMAGE_TEXTBOX_ATTR, IMAGE_OCCLUSION_EVENT, WORKSPACE_HIGHLIGHT_COLORS, richContentManagers, activeImageLightbox, CLOZE_ATTR, CLOZE_VALUE, CLOZE_SELECTOR, FONT_SIZE_VALUES, FONT_OPTIONS, CLOZE_STATE_HIDDEN, CLOZE_STATE_REVEALED;
  var init_rich_text = __esm({
    "js/ui/components/rich-text.js"() {
      init_media_upload();
      allowedTags = /* @__PURE__ */ new Set([
        "a",
        "b",
        "strong",
        "i",
        "em",
        "u",
        "s",
        "strike",
        "del",
        "mark",
        "span",
        "font",
        "p",
        "div",
        "br",
        "ul",
        "ol",
        "li",
        "img",
        "sub",
        "sup",
        "blockquote",
        "code",
        "pre",
        "hr",
        "video",
        "audio",
        "source",
        "iframe"
      ]);
      allowedAttributes = {
        "a": ["href", "title", "target", "rel"],
        "img": ["src", "alt", "title", "width", "height", "data-occlusions", "data-highlights", "data-textboxes"],
        "span": ["style", "data-cloze"],
        "div": ["style"],
        "p": ["style"],
        "font": ["style", "color", "face", "size"],
        "blockquote": ["style"],
        "code": ["style"],
        "pre": ["style"],
        "video": ["src", "controls", "width", "height", "poster", "preload", "loop", "muted", "playsinline"],
        "audio": ["src", "controls", "preload", "loop", "muted"],
        "source": ["src", "type"],
        "iframe": ["src", "title", "width", "height", "allow", "allowfullscreen", "frameborder"]
      };
      allowedStyles = /* @__PURE__ */ new Set([
        "color",
        "background-color",
        "font-size",
        "font-family",
        "font-weight",
        "font-style",
        "text-decoration-line",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-style",
        "text-align"
      ]);
      RICH_TEXT_CACHE_LIMIT = 400;
      richTextCache = /* @__PURE__ */ new Map();
      richTextCacheKeys = [];
      htmlEntityDecoder = typeof document !== "undefined" ? document.createElement("textarea") : null;
      IMAGE_OCCLUSION_ATTR = "data-occlusions";
      IMAGE_HIGHLIGHT_ATTR = "data-highlights";
      IMAGE_TEXTBOX_ATTR = "data-textboxes";
      IMAGE_OCCLUSION_EVENT = "imageocclusionchange";
      WORKSPACE_HIGHLIGHT_COLORS = [
        "#facc15",
        // amber
        "#60a5fa",
        // blue
        "#f472b6",
        // pink
        "#34d399",
        // green
        "#f97316"
        // orange
      ];
      richContentManagers = /* @__PURE__ */ new WeakMap();
      activeImageLightbox = null;
      CLOZE_ATTR = "data-cloze";
      CLOZE_VALUE = "true";
      CLOZE_SELECTOR = `[${CLOZE_ATTR}="${CLOZE_VALUE}"]`;
      FONT_SIZE_VALUES = [10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36, 40, 48];
      FONT_OPTIONS = [
        { value: "", label: "Default" },
        { value: '"Inter", "Segoe UI", sans-serif', label: "Modern Sans" },
        { value: '"Helvetica Neue", Arial, sans-serif', label: "Classic Sans" },
        { value: '"Times New Roman", Times, serif', label: "Serif" },
        { value: '"Source Code Pro", Menlo, monospace', label: "Monospace" },
        { value: '"Comic Neue", "Comic Sans MS", cursive', label: "Handwriting" }
      ];
      CLOZE_STATE_HIDDEN = "hidden";
      CLOZE_STATE_REVEALED = "revealed";
    }
  });

  // js/ui/components/editor.js
  function escapeHtml3(str = "") {
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  async function openEditor(kind, onSave, existing = null) {
    let isDirty = false;
    let status;
    let statusFadeTimer = null;
    let autoSaveTimer = null;
    let idleSaveHandle = null;
    const AUTOSAVE_DELAY = 9e3;
    const AUTOSAVE_IDLE_TIMEOUT = 15e3;
    const runWhenIdle = typeof requestIdleCallback === "function" ? requestIdleCallback : null;
    const cancelIdle = typeof cancelIdleCallback === "function" ? cancelIdleCallback : null;
    const computePersistSignature = (item) => {
      if (!item || typeof item !== "object") return null;
      try {
        return JSON.stringify(item);
      } catch (err) {
        return null;
      }
    };
    let lastPersistSignature = existing ? computePersistSignature(existing) : null;
    const editorCleanups = /* @__PURE__ */ new Set();
    function registerCleanup(fn) {
      if (typeof fn !== "function") {
        return () => {
        };
      }
      editorCleanups.add(fn);
      return () => {
        editorCleanups.delete(fn);
      };
    }
    function runEditorCleanups() {
      editorCleanups.forEach((fn) => {
        try {
          fn();
        } catch (err) {
          console.error("Failed to cleanup editor resources", err);
        }
      });
      editorCleanups.clear();
    }
    function trackEditorInstance(editor) {
      if (!editor || typeof editor.destroy !== "function") {
        return () => {
        };
      }
      let disposed = false;
      const cleanup = () => {
        if (disposed) return;
        disposed = true;
        try {
          editor.destroy();
        } catch (err) {
          console.error("Failed to destroy rich text editor", err);
        }
      };
      const unregister = registerCleanup(cleanup);
      return () => {
        if (disposed) return;
        unregister();
        cleanup();
      };
    }
    const win = createFloatingWindow({
      title: `${existing ? "Edit" : "Add"} ${titleMap[kind] || kind}`,
      width: 660,
      onClose: () => {
        cancelAutoSave();
        if (statusFadeTimer) {
          clearTimeout(statusFadeTimer);
          statusFadeTimer = null;
        }
        runEditorCleanups();
      },
      onBeforeClose: async (reason) => {
        if (reason === "saved") return true;
        cancelAutoSave();
        if (!isDirty) return true;
        if (reason !== "close") return true;
        const shouldSave = await confirmModal("Save changes before closing?");
        if (shouldSave) {
          try {
            await persist({ closeAfter: true });
          } catch (err) {
            console.error(err);
          }
          return false;
        }
        return true;
      }
    });
    const form = document.createElement("form");
    form.className = "editor-form";
    const nameLabel = document.createElement("label");
    nameLabel.className = "editor-field";
    const nameTitle = document.createElement("span");
    nameTitle.className = "editor-field-label";
    nameTitle.textContent = kind === "concept" ? "Concept" : "Name";
    nameLabel.appendChild(nameTitle);
    const nameInput = document.createElement("input");
    nameInput.className = "input";
    nameInput.value = existing ? existing.name || existing.concept || "" : "";
    nameInput.placeholder = kind === "concept" ? "Enter concept title" : "Enter name";
    nameLabel.appendChild(nameInput);
    form.appendChild(nameLabel);
    const cancelAutoSave = () => {
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = null;
      }
      if (idleSaveHandle != null && cancelIdle) {
        cancelIdle(idleSaveHandle);
        idleSaveHandle = null;
      }
    };
    const queueAutoSave = () => {
      cancelAutoSave();
      if (!isDirty) return;
      if (!nameInput.value.trim()) return;
      if (!hasLectureSelection()) return;
      autoSaveTimer = setTimeout(() => {
        autoSaveTimer = null;
        if (!isDirty) return;
        if (!hasLectureSelection()) return;
        const attemptSave = () => {
          persist({ silent: true }).catch((err) => {
            console.error("Autosave failed", err);
          });
        };
        if (runWhenIdle) {
          idleSaveHandle = runWhenIdle(() => {
            idleSaveHandle = null;
            attemptSave();
          }, { timeout: AUTOSAVE_IDLE_TIMEOUT });
        } else {
          attemptSave();
        }
      }, AUTOSAVE_DELAY);
    };
    const markDirty = () => {
      isDirty = true;
      if (status) {
        if (statusFadeTimer) {
          clearTimeout(statusFadeTimer);
          statusFadeTimer = null;
        }
        status.textContent = "";
        status.classList.remove("editor-status-muted");
      }
      queueAutoSave();
    };
    nameInput.addEventListener("input", markDirty);
    const fieldInputs = {};
    fieldMap[kind].forEach(([field, label]) => {
      const fieldWrap = document.createElement("div");
      fieldWrap.className = "editor-field";
      const labelEl = document.createElement("label");
      labelEl.className = "editor-field-label";
      labelEl.textContent = label;
      const labelId = `field-${field}-${uid()}`;
      labelEl.id = labelId;
      fieldWrap.appendChild(labelEl);
      const editor = createRichTextEditor({
        value: existing ? existing[field] || "" : "",
        onChange: markDirty,
        ariaLabelledBy: labelId
      });
      trackEditorInstance(editor);
      const inp = editor.element;
      fieldInputs[field] = editor;
      fieldWrap.appendChild(inp);
      form.appendChild(fieldWrap);
    });
    const extrasWrap = document.createElement("section");
    extrasWrap.className = "editor-extras";
    const extrasHeader = document.createElement("div");
    extrasHeader.className = "editor-extras-header";
    const extrasTitle = document.createElement("h3");
    extrasTitle.textContent = "Custom Sections";
    extrasHeader.appendChild(extrasTitle);
    const addExtraBtn = document.createElement("button");
    addExtraBtn.type = "button";
    addExtraBtn.className = "btn subtle";
    addExtraBtn.textContent = "Add Section";
    extrasHeader.appendChild(addExtraBtn);
    extrasWrap.appendChild(extrasHeader);
    const extrasList = document.createElement("div");
    extrasList.className = "editor-extras-list";
    extrasWrap.appendChild(extrasList);
    form.appendChild(extrasWrap);
    const extraControls = /* @__PURE__ */ new Map();
    function addExtra(extra = null) {
      const data = extra || {};
      const id = data.id || uid();
      const row = document.createElement("div");
      row.className = "editor-extra";
      row.dataset.id = id;
      const titleRow = document.createElement("div");
      titleRow.className = "editor-extra-title-row";
      const titleInput = document.createElement("input");
      titleInput.className = "input editor-extra-title";
      titleInput.placeholder = "Section title";
      titleInput.value = data.title || "";
      titleRow.appendChild(titleInput);
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "icon-btn ghost";
      removeBtn.title = "Remove section";
      removeBtn.textContent = "\u2715";
      titleRow.appendChild(removeBtn);
      row.appendChild(titleRow);
      const editor = createRichTextEditor({ value: data.body || "", onChange: markDirty });
      const disposeEditor = trackEditorInstance(editor);
      row.appendChild(editor.element);
      extrasList.appendChild(row);
      extraControls.set(id, { id, titleInput, editor, dispose: disposeEditor });
      titleInput.addEventListener("input", markDirty);
      row.addEventListener("input", markDirty);
      if (!extra) markDirty();
      removeBtn.addEventListener("click", () => {
        extraControls.delete(id);
        disposeEditor();
        row.remove();
        markDirty();
      });
    }
    addExtraBtn.addEventListener("click", () => addExtra());
    const legacyExtras = (() => {
      if (existing?.extras && existing.extras.length) return existing.extras;
      if (existing?.facts && existing.facts.length) {
        return [{
          id: uid(),
          title: "Highlights",
          body: existing.facts.map((f) => `<p>${escapeHtml3(f)}</p>`).join("")
        }];
      }
      return [];
    })();
    legacyExtras.forEach((extra) => addExtra(extra));
    const colorLabel = document.createElement("label");
    colorLabel.className = "editor-field";
    colorLabel.textContent = "Color";
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.className = "input";
    colorInput.value = existing?.color || "#ffffff";
    colorLabel.appendChild(colorInput);
    form.appendChild(colorLabel);
    colorInput.addEventListener("input", markDirty);
    const catalog = await loadBlockCatalog({ force: true });
    const blocks = (catalog.blocks || []).map((block) => ({
      ...block,
      lectures: (catalog.lectureLists?.[block.blockId] || []).map((lecture) => ({ ...lecture }))
    }));
    const blockMap = new Map(blocks.map((b) => [b.blockId, b]));
    const blockSet = new Set(Array.isArray(existing?.blocks) ? existing.blocks : []);
    const manualWeeks = new Set(
      Array.isArray(existing?.weeks) ? existing.weeks.filter((value) => Number.isFinite(Number(value))).map((value) => Number(value)) : []
    );
    const lectSet = /* @__PURE__ */ new Set();
    const lectureBlockCounts = /* @__PURE__ */ new Map();
    function hasLectureSelection() {
      if (lectSet.size > 0) return true;
      return Array.isArray(existing?.lectures) && existing.lectures.length > 0;
    }
    function incrementBlockCount(blockId) {
      if (!blockId) return;
      const key = String(blockId);
      const next = (lectureBlockCounts.get(key) || 0) + 1;
      lectureBlockCounts.set(key, next);
    }
    function decrementBlockCount(blockId) {
      if (!blockId) return;
      const key = String(blockId);
      const prev = lectureBlockCounts.get(key) || 0;
      if (prev <= 1) {
        lectureBlockCounts.delete(key);
      } else {
        lectureBlockCounts.set(key, prev - 1);
      }
    }
    existing?.lectures?.forEach((l) => {
      if (l.blockId != null && l.id != null) {
        const key = `${l.blockId}|${l.id}`;
        lectSet.add(key);
        incrementBlockCount(l.blockId);
      }
    });
    const blockWrap = document.createElement("section");
    blockWrap.className = "editor-tags";
    const blockTitle = document.createElement("div");
    blockTitle.className = "editor-tags-title";
    blockTitle.textContent = "Curriculum tags";
    blockWrap.appendChild(blockTitle);
    const blockDescription = document.createElement("p");
    blockDescription.className = "editor-tags-description";
    blockDescription.textContent = "Pick the lectures that relate to this entry. Block and week tags update automatically as you choose lectures.";
    blockWrap.appendChild(blockDescription);
    const blockChipRow = document.createElement("div");
    blockChipRow.className = "editor-chip-row";
    blockWrap.appendChild(blockChipRow);
    const manualWeeksBox = document.createElement("div");
    manualWeeksBox.className = "editor-manual-weeks";
    const manualWeeksHeader = document.createElement("div");
    manualWeeksHeader.className = "editor-manual-weeks-header";
    const manualWeeksTitle = document.createElement("span");
    manualWeeksTitle.textContent = "Additional week tags";
    manualWeeksHeader.appendChild(manualWeeksTitle);
    manualWeeksBox.appendChild(manualWeeksHeader);
    const manualWeekList = document.createElement("div");
    manualWeekList.className = "editor-manual-weeks-list";
    manualWeeksBox.appendChild(manualWeekList);
    const blockBrowser = document.createElement("div");
    blockBrowser.className = "editor-curriculum-browser";
    blockWrap.appendChild(blockBrowser);
    const runNextFrame = typeof requestAnimationFrame === "function" ? (cb) => requestAnimationFrame(cb) : (cb) => setTimeout(cb, 16);
    let scheduledRender = null;
    function scheduleRender({ chips = false, blocks: blocks2 = false, weeks = false, lectures = false } = {}) {
      if (!scheduledRender) {
        scheduledRender = { chips, blocks: blocks2, weeks, lectures };
        runNextFrame(() => {
          const payload = scheduledRender;
          scheduledRender = null;
          if (payload.chips) renderBlockChips();
          if (payload.blocks) renderBlockList();
          if (payload.weeks) renderWeekList();
          if (payload.lectures) renderLectureList();
        });
        return;
      }
      if (chips) scheduledRender.chips = true;
      if (blocks2) scheduledRender.blocks = true;
      if (weeks) scheduledRender.weeks = true;
      if (lectures) scheduledRender.lectures = true;
    }
    const blockColumn = document.createElement("div");
    blockColumn.className = "editor-curriculum-column editor-block-column";
    const blockColumnHeading = document.createElement("h4");
    blockColumnHeading.className = "editor-column-heading";
    blockColumnHeading.textContent = "Blocks";
    blockColumn.appendChild(blockColumnHeading);
    const blockListEl = document.createElement("div");
    blockListEl.className = "editor-block-list";
    blockColumn.appendChild(blockListEl);
    blockBrowser.appendChild(blockColumn);
    const weekColumn = document.createElement("div");
    weekColumn.className = "editor-curriculum-column editor-week-column";
    const weekHeading = document.createElement("h4");
    weekHeading.className = "editor-column-heading";
    weekHeading.textContent = "Weeks";
    weekColumn.appendChild(weekHeading);
    const weekListEl = document.createElement("div");
    weekListEl.className = "editor-week-browser";
    weekColumn.appendChild(weekListEl);
    weekColumn.appendChild(manualWeeksBox);
    blockBrowser.appendChild(weekColumn);
    const lectureColumn = document.createElement("div");
    lectureColumn.className = "editor-curriculum-column editor-lecture-column";
    const lectureHeading = document.createElement("h4");
    lectureHeading.className = "editor-column-heading";
    lectureHeading.textContent = "Lectures";
    lectureColumn.appendChild(lectureHeading);
    const lectureListEl = document.createElement("div");
    lectureListEl.className = "editor-lecture-browser";
    lectureColumn.appendChild(lectureListEl);
    blockBrowser.appendChild(lectureColumn);
    const UNSCHEDULED_KEY = "__unscheduled";
    function createTagChip(label, variant, active = false) {
      const chip = document.createElement("button");
      chip.type = "button";
      chip.className = `tag-chip tag-chip-${variant}`;
      chip.textContent = label;
      setToggleState(chip, active);
      return chip;
    }
    function blockHasSelectedLectures(blockId) {
      if (!blockId) return false;
      return lectureBlockCounts.has(String(blockId));
    }
    function collectSelectedWeekKeys() {
      const selected = /* @__PURE__ */ new Set();
      lectSet.forEach((key) => {
        const [blockId, lectureId] = key.split("|");
        const lecId = Number(lectureId);
        if (!blockId || !Number.isFinite(lecId)) return;
        const block = blockMap.get(blockId);
        const lecture = block?.lectures?.find((le) => le.id === lecId);
        if (!lecture) return;
        const weekValue = lecture.week == null || lecture.week === "" ? UNSCHEDULED_KEY : lecture.week;
        selected.add(`${blockId}|${weekValue}`);
      });
      return selected;
    }
    function collectWeekNumbers() {
      const numbers = new Set(manualWeeks);
      lectSet.forEach((key) => {
        const [blockId, lectureId] = key.split("|");
        const lecId = Number(lectureId);
        if (!blockId || !Number.isFinite(lecId)) return;
        const block = blockMap.get(blockId);
        const lecture = block?.lectures?.find((le) => le.id === lecId);
        if (!lecture) return;
        const weekValue = Number(lecture.week);
        if (Number.isFinite(weekValue)) numbers.add(weekValue);
      });
      return numbers;
    }
    function renderManualWeekTags() {
      manualWeekList.innerHTML = "";
      if (!manualWeeks.size) {
        const empty = document.createElement("span");
        empty.className = "editor-manual-weeks-empty";
        empty.textContent = "No extra week tags yet.";
        manualWeekList.appendChild(empty);
        manualWeeksBox.classList.add("empty");
      } else {
        manualWeeksBox.classList.remove("empty");
        Array.from(manualWeeks).sort((a, b) => a - b).forEach((weekNum) => {
          const chip = document.createElement("div");
          chip.className = "editor-manual-week-chip";
          const label = document.createElement("span");
          label.textContent = `Week ${weekNum}`;
          chip.appendChild(label);
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-btn ghost";
          removeBtn.title = "Remove week tag";
          removeBtn.setAttribute("aria-label", `Remove week ${weekNum}`);
          removeBtn.textContent = "\u2715";
          removeBtn.addEventListener("click", () => {
            manualWeeks.delete(weekNum);
            markDirty();
            renderManualWeekTags();
            scheduleRender({ weeks: true, lectures: true });
          });
          chip.appendChild(removeBtn);
          manualWeekList.appendChild(chip);
        });
      }
    }
    let activeBlockId = null;
    let activeWeekKey = null;
    function weekGroupsForBlock(block) {
      if (!block) return [];
      const weekNumbers = /* @__PURE__ */ new Set();
      if (Number.isFinite(block.weeks)) {
        for (let i = 1; i <= block.weeks; i++) weekNumbers.add(i);
      }
      (block.lectures || []).forEach((l) => {
        if (typeof l.week === "number") weekNumbers.add(l.week);
      });
      const sortedWeeks = Array.from(weekNumbers).sort((a, b) => a - b);
      const groups = sortedWeeks.map((weekNumber) => ({
        key: `${block.blockId}|${weekNumber}`,
        label: `Week ${weekNumber}`,
        lectures: (block.lectures || []).filter((l) => l.week === weekNumber),
        weekNumber
      }));
      const unscheduledLectures = (block.lectures || []).filter((l) => l.week == null || l.week === "");
      if (unscheduledLectures.length) {
        groups.push({
          key: `${block.blockId}|${UNSCHEDULED_KEY}`,
          label: "Unscheduled",
          lectures: unscheduledLectures,
          unscheduled: true
        });
      }
      return groups;
    }
    function ensureActiveBlock2() {
      if (activeBlockId && blockMap.has(activeBlockId)) return;
      for (const key of lectSet) {
        const [blockId] = key.split("|");
        if (blockId && blockMap.has(blockId)) {
          activeBlockId = blockId;
          return;
        }
      }
      for (const id of blockSet) {
        if (blockMap.has(id)) {
          activeBlockId = id;
          return;
        }
      }
      activeBlockId = blocks[0]?.blockId || null;
    }
    function ensureActiveWeek() {
      if (!activeBlockId || !blockMap.has(activeBlockId)) {
        activeWeekKey = null;
        return;
      }
      const block = blockMap.get(activeBlockId);
      const groups = weekGroupsForBlock(block);
      if (activeWeekKey && groups.some((group) => group.key === activeWeekKey)) return;
      const selected = collectSelectedWeekKeys();
      for (const key of selected) {
        if (key.startsWith(`${activeBlockId}|`)) {
          activeWeekKey = key;
          return;
        }
      }
      activeWeekKey = groups.length ? groups[0].key : null;
    }
    function renderBlockChips() {
      blockChipRow.innerHTML = "";
      const taggedBlocks = Array.from(blockSet).filter((id) => blockMap.has(id));
      if (!taggedBlocks.length) {
        const hint = document.createElement("div");
        hint.className = "editor-tags-empty subtle";
        hint.textContent = "Block tags update automatically as you choose lectures.";
        blockChipRow.appendChild(hint);
        return;
      }
      taggedBlocks.sort((a, b) => {
        const aTitle = blockMap.get(a)?.title || String(a);
        const bTitle = blockMap.get(b)?.title || String(b);
        return aTitle.localeCompare(bTitle);
      });
      taggedBlocks.forEach((blockId) => {
        const title = blockMap.get(blockId)?.title || blockId;
        const chip = createTagChip(title, "block", true);
        chip.addEventListener("click", () => {
          blockSet.delete(blockId);
          markDirty();
          scheduleRender({ chips: true, blocks: true, weeks: true, lectures: true });
        });
        blockChipRow.appendChild(chip);
      });
    }
    function renderBlockList() {
      blockListEl.innerHTML = "";
      if (!blocks.length) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty";
        empty.textContent = "No curriculum blocks have been created yet.";
        blockListEl.appendChild(empty);
        return;
      }
      ensureActiveBlock2();
      ensureActiveWeek();
      blocks.forEach((block) => {
        if (!block) return;
        const blockId = block.blockId;
        const row = document.createElement("div");
        row.className = "editor-block-row";
        if (blockHasSelectedLectures(blockId)) row.classList.add("has-lectures");
        const button = document.createElement("button");
        button.type = "button";
        button.className = "editor-block-button";
        setToggleState(button, blockId === activeBlockId);
        const label = document.createElement("span");
        label.className = "editor-block-label";
        label.textContent = block.title || blockId;
        button.appendChild(label);
        const count = lectureBlockCounts.get(String(blockId)) || 0;
        if (count) {
          const badge = document.createElement("span");
          badge.className = "editor-block-count";
          badge.textContent = `${count}`;
          badge.setAttribute("aria-label", `${count} selected lecture${count === 1 ? "" : "s"}`);
          button.appendChild(badge);
        }
        button.addEventListener("click", () => {
          activeBlockId = blockId;
          activeWeekKey = null;
          ensureActiveWeek();
          scheduleRender({ blocks: true, weeks: true, lectures: true });
        });
        row.appendChild(button);
        blockListEl.appendChild(row);
      });
    }
    function renderWeekList() {
      weekListEl.innerHTML = "";
      if (!blocks.length) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty subtle";
        empty.textContent = "Add blocks to browse weeks.";
        weekListEl.appendChild(empty);
        return;
      }
      ensureActiveBlock2();
      if (!activeBlockId || !blockMap.has(activeBlockId)) {
        const prompt2 = document.createElement("div");
        prompt2.className = "editor-tags-empty subtle";
        prompt2.textContent = "Select a block to view weeks.";
        weekListEl.appendChild(prompt2);
        return;
      }
      const block = blockMap.get(activeBlockId);
      const groups = weekGroupsForBlock(block);
      ensureActiveWeek();
      const selectedWeekKeys = collectSelectedWeekKeys();
      if (!groups.length) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty subtle";
        empty.textContent = "Add weeks or lectures to this block to start tagging.";
        weekListEl.appendChild(empty);
        return;
      }
      groups.forEach((group) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "editor-week-button";
        setToggleState(btn, group.key === activeWeekKey);
        if (selectedWeekKeys.has(group.key)) btn.classList.add("has-selection");
        if (Number.isFinite(group.weekNumber) && manualWeeks.has(Number(group.weekNumber))) {
          btn.classList.add("manual");
        }
        const label = document.createElement("span");
        label.className = "editor-week-label";
        label.textContent = group.label;
        btn.appendChild(label);
        const meta = document.createElement("span");
        meta.className = "editor-week-meta";
        const total = group.lectures?.length || 0;
        if (total) {
          meta.textContent = `${total} lecture${total === 1 ? "" : "s"}`;
        } else if (group.unscheduled) {
          meta.textContent = "No unscheduled lectures";
        } else {
          meta.textContent = "No lectures yet";
        }
        btn.appendChild(meta);
        btn.addEventListener("click", () => {
          activeWeekKey = group.key;
          scheduleRender({ weeks: true, lectures: true });
        });
        weekListEl.appendChild(btn);
      });
    }
    function renderLectureList() {
      lectureListEl.innerHTML = "";
      if (!blocks.length) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty subtle";
        empty.textContent = "Add blocks and lectures to start tagging.";
        lectureListEl.appendChild(empty);
        return;
      }
      ensureActiveBlock2();
      ensureActiveWeek();
      if (!activeBlockId || !blockMap.has(activeBlockId)) {
        const prompt2 = document.createElement("div");
        prompt2.className = "editor-tags-empty subtle";
        prompt2.textContent = "Select a block to choose lectures.";
        lectureListEl.appendChild(prompt2);
        return;
      }
      if (!activeWeekKey) {
        const prompt2 = document.createElement("div");
        prompt2.className = "editor-tags-empty subtle";
        prompt2.textContent = "Pick a week to see its lectures.";
        lectureListEl.appendChild(prompt2);
        return;
      }
      const [blockId] = activeWeekKey.split("|");
      const block = blockMap.get(blockId);
      const groups = weekGroupsForBlock(block);
      const current = groups.find((group) => group.key === activeWeekKey);
      if (!current) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty subtle";
        empty.textContent = "No lectures available for this week yet.";
        lectureListEl.appendChild(empty);
        return;
      }
      if (!current.lectures.length) {
        const empty = document.createElement("div");
        empty.className = "editor-tags-empty subtle";
        empty.textContent = current.unscheduled ? "No unscheduled lectures yet." : "No lectures linked to this week yet.";
        lectureListEl.appendChild(empty);
        return;
      }
      current.lectures.forEach((lecture) => {
        const key = `${blockId}|${lecture.id}`;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "editor-lecture-button";
        btn.textContent = lecture.name || `Lecture ${lecture.id}`;
        setToggleState(btn, lectSet.has(key));
        btn.addEventListener("click", () => {
          if (lectSet.has(key)) {
            lectSet.delete(key);
            decrementBlockCount(blockId);
          } else {
            lectSet.add(key);
            incrementBlockCount(blockId);
          }
          markDirty();
          scheduleRender({ chips: true, blocks: true, weeks: true, lectures: true });
        });
        lectureListEl.appendChild(btn);
      });
    }
    renderManualWeekTags();
    renderBlockChips();
    renderBlockList();
    renderWeekList();
    renderLectureList();
    form.appendChild(blockWrap);
    const actionBar = document.createElement("div");
    actionBar.className = "editor-actions";
    status = document.createElement("span");
    status.className = "editor-status";
    let saveBtn;
    let headerSaveBtn;
    async function persist(options = {}) {
      const opts = typeof options === "boolean" ? { closeAfter: options } : options;
      const { closeAfter = false, silent = false } = opts;
      cancelAutoSave();
      const titleKey = kind === "concept" ? "concept" : "name";
      const trimmed = nameInput.value.trim();
      if (!trimmed) {
        if (!silent) {
          status.textContent = "Name is required.";
        }
        return false;
      }
      if (!silent && status) {
        status.classList.remove("editor-status-muted");
        status.textContent = "Saving\u2026";
      }
      const wasNew = !existing;
      const item = existing || { id: uid(), kind };
      item[titleKey] = trimmed;
      fieldMap[kind].forEach(([field]) => {
        const control = fieldInputs[field];
        const v = control?.getValue ? control.getValue() : "";
        item[field] = v;
      });
      item.extras = Array.from(extraControls.values()).map(({ id, titleInput, editor }) => ({
        id,
        title: titleInput.value.trim(),
        body: editor.getValue()
      })).filter((ex) => ex.title || ex.body);
      item.facts = [];
      const blockTags = new Set(blockSet);
      lectSet.forEach((key) => {
        const [blockId] = key.split("|");
        if (blockId) blockTags.add(blockId);
      });
      item.blocks = Array.from(blockTags);
      const weekNums = collectWeekNumbers();
      item.weeks = Array.from(weekNums).sort((a, b) => a - b);
      const lectures = [];
      for (const key of lectSet) {
        const [blockId, lecIdStr] = key.split("|");
        const lecId = Number(lecIdStr);
        const blk = blockMap.get(blockId);
        const l = blk?.lectures.find((le) => le.id === lecId);
        if (l) lectures.push({ blockId, id: l.id, name: l.name, week: l.week });
      }
      item.lectures = lectures;
      item.color = colorInput.value;
      const signature = computePersistSignature(item);
      const canCompareSignature = signature && lastPersistSignature && existing && existing.id === item.id;
      const shouldSkipPersist = Boolean(canCompareSignature && signature === lastPersistSignature);
      try {
        if (!shouldSkipPersist) {
          await upsertItem(item);
        }
      } catch (err) {
        console.error(err);
        if (status) {
          if (statusFadeTimer) {
            clearTimeout(statusFadeTimer);
            statusFadeTimer = null;
          }
          status.classList.remove("editor-status-muted");
          status.textContent = silent ? "Autosave failed" : "Failed to save.";
        }
        throw err;
      }
      existing = item;
      lastPersistSignature = signature;
      updateTitle();
      isDirty = false;
      const shouldNotify = onSave && (!silent || wasNew);
      if (shouldNotify) onSave();
      if (closeAfter) {
        win.close("saved");
      } else {
        if (statusFadeTimer) {
          clearTimeout(statusFadeTimer);
          statusFadeTimer = null;
        }
        if (status) {
          if (silent) {
            status.textContent = "Autosaved";
            status.classList.add("editor-status-muted");
            statusFadeTimer = setTimeout(() => {
              status.classList.remove("editor-status-muted");
              statusFadeTimer = null;
            }, 1800);
          } else {
            status.textContent = shouldSkipPersist ? "Up to date" : "Saved";
            status.classList.remove("editor-status-muted");
          }
        }
      }
      return true;
    }
    function handleSaveRequest() {
      if (headerSaveBtn) headerSaveBtn.disabled = true;
      if (saveBtn) saveBtn.disabled = true;
      persist({ closeAfter: true }).catch(() => {
      }).finally(() => {
        if (headerSaveBtn) headerSaveBtn.disabled = false;
        if (saveBtn) saveBtn.disabled = false;
      });
    }
    headerSaveBtn = win.addAction({
      text: "\u2713",
      ariaLabel: "Save entry",
      title: "Save and close",
      className: "floating-action--confirm",
      onClick: handleSaveRequest
    });
    saveBtn = document.createElement("button");
    saveBtn.type = "button";
    saveBtn.className = "btn";
    saveBtn.textContent = "Save & Close";
    saveBtn.addEventListener("click", handleSaveRequest);
    actionBar.appendChild(saveBtn);
    actionBar.appendChild(status);
    form.appendChild(actionBar);
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      handleSaveRequest();
    });
    win.setContent(form);
    const updateTitle = () => {
      const base = `${existing ? "Edit" : "Add"} ${titleMap[kind] || kind}`;
      const name = nameInput.value.trim();
      if (name) {
        win.setTitle(`${base}: ${name}`);
      } else {
        win.setTitle(base);
      }
    };
    nameInput.addEventListener("input", updateTitle);
    updateTitle();
    win.focus();
    nameInput.focus();
  }
  var fieldMap, titleMap;
  var init_editor = __esm({
    "js/ui/components/editor.js"() {
      init_utils();
      init_storage();
      init_block_catalog();
      init_window_manager();
      init_rich_text();
      init_confirm();
      fieldMap = {
        disease: [
          ["etiology", "Etiology"],
          ["pathophys", "Pathophysiology"],
          ["clinical", "Clinical Presentation"],
          ["diagnosis", "Diagnosis"],
          ["treatment", "Treatment"],
          ["complications", "Complications"],
          ["mnemonic", "Mnemonic"]
        ],
        drug: [
          ["class", "Class"],
          ["source", "Source"],
          ["moa", "MOA"],
          ["uses", "Uses"],
          ["sideEffects", "Side Effects"],
          ["contraindications", "Contraindications"],
          ["mnemonic", "Mnemonic"]
        ],
        concept: [
          ["type", "Type"],
          ["definition", "Definition"],
          ["mechanism", "Mechanism"],
          ["clinicalRelevance", "Clinical Relevance"],
          ["example", "Example"],
          ["mnemonic", "Mnemonic"]
        ]
      };
      titleMap = { disease: "Disease", drug: "Drug", concept: "Concept" };
    }
  });

  // js/ui/components/linker.js
  async function openLinker(item, onSave) {
    const overlay = document.createElement("div");
    overlay.className = "modal";
    const card = document.createElement("div");
    card.className = "card";
    const title = document.createElement("h2");
    title.textContent = `Links for ${item.name || item.concept || ""}`;
    card.appendChild(title);
    const all = [
      ...await listItemsByKind("disease"),
      ...await listItemsByKind("drug"),
      ...await listItemsByKind("concept")
    ];
    const idMap = new Map(all.map((i) => [i.id, i]));
    const links = new Set((item.links || []).map((l) => l.id));
    const list = document.createElement("div");
    list.className = "link-list";
    card.appendChild(list);
    function renderList() {
      list.innerHTML = "";
      links.forEach((id) => {
        const row = document.createElement("div");
        row.className = "row";
        const label = document.createElement("span");
        const it = idMap.get(id);
        label.textContent = it ? it.name || it.concept || id : id;
        row.appendChild(label);
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = "Remove";
        btn.addEventListener("click", () => {
          links.delete(id);
          renderList();
        });
        row.appendChild(btn);
        list.appendChild(row);
      });
    }
    renderList();
    const input = document.createElement("input");
    input.className = "input";
    input.placeholder = "Search items...";
    card.appendChild(input);
    const sug = document.createElement("ul");
    sug.className = "quiz-suggestions";
    card.appendChild(sug);
    input.addEventListener("input", () => {
      const v = input.value.toLowerCase();
      sug.innerHTML = "";
      if (!v) return;
      all.filter((it) => it.id !== item.id && (it.name || it.concept || "").toLowerCase().includes(v)).slice(0, 5).forEach((it) => {
        const li = document.createElement("li");
        li.textContent = it.name || it.concept || "";
        li.addEventListener("mousedown", () => {
          links.add(it.id);
          input.value = "";
          sug.innerHTML = "";
          renderList();
        });
        sug.appendChild(li);
      });
    });
    const actions = document.createElement("div");
    actions.className = "modal-actions";
    const cancel2 = document.createElement("button");
    cancel2.type = "button";
    cancel2.className = "btn";
    cancel2.textContent = "Close";
    cancel2.addEventListener("click", () => document.body.removeChild(overlay));
    const save = document.createElement("button");
    save.type = "button";
    save.className = "btn";
    save.textContent = "Save";
    save.addEventListener("click", async () => {
      const newLinks = new Set(links);
      const oldLinks = new Set((item.links || []).map((l) => l.id));
      item.links = Array.from(newLinks).map((id) => ({ id, type: "assoc" }));
      await upsertItem(item);
      const affected = /* @__PURE__ */ new Set([...oldLinks, ...newLinks]);
      for (const id of affected) {
        const other = idMap.get(id);
        if (!other) continue;
        other.links = other.links || [];
        const has = other.links.some((l) => l.id === item.id);
        const should = newLinks.has(id);
        if (should && !has) other.links.push({ id: item.id, type: "assoc" });
        if (!should && has) other.links = other.links.filter((l) => l.id !== item.id);
        await upsertItem(other);
      }
      document.body.removeChild(overlay);
      onSave && onSave();
    });
    actions.appendChild(cancel2);
    actions.appendChild(save);
    card.appendChild(actions);
    overlay.appendChild(card);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) document.body.removeChild(overlay);
    });
    document.body.appendChild(overlay);
    input.focus();
  }
  var init_linker = __esm({
    "js/ui/components/linker.js"() {
      init_storage();
    }
  });

  // js/ui/components/cardlist.js
  var cardlist_exports = {};
  __export(cardlist_exports, {
    createItemCard: () => createItemCard,
    renderCardList: () => renderCardList
  });
  function escapeHtml4(str = "") {
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function ensureExtras(item) {
    if (Array.isArray(item.extras) && item.extras.length) {
      return item.extras;
    }
    if (item.facts && item.facts.length) {
      return [{
        id: "legacy-facts",
        title: "Highlights",
        body: `<ul>${item.facts.map((f) => `<li>${escapeHtml4(f)}</li>`).join("")}</ul>`
      }];
    }
    return [];
  }
  function createItemCard(item, onChange) {
    const card = document.createElement("div");
    card.className = `item-card card--${item.kind}`;
    const color = item.color || kindColors[item.kind] || "var(--gray)";
    card.style.borderTop = `3px solid ${color}`;
    const header = document.createElement("div");
    header.className = "card-header";
    const mainBtn = document.createElement("button");
    mainBtn.className = "card-title-btn";
    mainBtn.textContent = item.name || item.concept || "Untitled";
    mainBtn.setAttribute("aria-expanded", expanded.has(item.id));
    header.appendChild(mainBtn);
    const settings = document.createElement("div");
    settings.className = "card-settings";
    const menu = document.createElement("div");
    menu.className = "card-menu hidden";
    menu.setAttribute("role", "menu");
    menu.setAttribute("aria-hidden", "true");
    const gear = document.createElement("button");
    gear.type = "button";
    gear.className = "icon-btn card-settings-toggle";
    gear.title = "Entry options";
    gear.setAttribute("aria-haspopup", "true");
    gear.setAttribute("aria-expanded", "false");
    gear.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a7.723 7.723 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.47 6.47 0 0 1-.22.128c-.331.183-.581.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a6.932 6.932 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.086.22-.128.332-.183.582-.495.644-.869z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="2.8" stroke="currentColor" stroke-width="1.6"/></svg>';
    settings.append(gear, menu);
    header.appendChild(settings);
    function closeMenu() {
      menu.classList.add("hidden");
      menu.setAttribute("aria-hidden", "true");
      settings.classList.remove("open");
      gear.setAttribute("aria-expanded", "false");
      document.removeEventListener("mousedown", handleOutside);
    }
    function openMenu() {
      menu.classList.remove("hidden");
      menu.setAttribute("aria-hidden", "false");
      settings.classList.add("open");
      gear.setAttribute("aria-expanded", "true");
      document.addEventListener("mousedown", handleOutside);
    }
    function handleOutside(e) {
      if (!settings.contains(e.target)) {
        closeMenu();
      }
    }
    gear.addEventListener("click", (e) => {
      e.stopPropagation();
      if (menu.classList.contains("hidden")) openMenu();
      else closeMenu();
    });
    menu.addEventListener("click", (e) => e.stopPropagation());
    const fav = document.createElement("button");
    fav.className = "icon-btn";
    fav.textContent = item.favorite ? "\u2605" : "\u2606";
    fav.title = "Toggle Favorite";
    fav.setAttribute("aria-label", "Toggle Favorite");
    fav.addEventListener("click", async (e) => {
      e.stopPropagation();
      closeMenu();
      item.favorite = !item.favorite;
      await upsertItem(item);
      fav.textContent = item.favorite ? "\u2605" : "\u2606";
      onChange && onChange();
    });
    menu.appendChild(fav);
    const link = document.createElement("button");
    link.className = "icon-btn";
    link.textContent = "\u{1FAA2}";
    link.title = "Links";
    link.setAttribute("aria-label", "Manage links");
    link.addEventListener("click", (e) => {
      e.stopPropagation();
      closeMenu();
      openLinker(item, onChange);
    });
    menu.appendChild(link);
    const edit = document.createElement("button");
    edit.className = "icon-btn";
    edit.textContent = "\u270F\uFE0F";
    edit.title = "Edit";
    edit.setAttribute("aria-label", "Edit");
    edit.addEventListener("click", (e) => {
      e.stopPropagation();
      closeMenu();
      openEditor(item.kind, onChange, item);
    });
    menu.appendChild(edit);
    const copy = document.createElement("button");
    copy.className = "icon-btn";
    copy.textContent = "\u{1F4CB}";
    copy.title = "Copy Title";
    copy.setAttribute("aria-label", "Copy Title");
    copy.addEventListener("click", (e) => {
      e.stopPropagation();
      closeMenu();
      navigator.clipboard && navigator.clipboard.writeText(item.name || item.concept || "");
    });
    menu.appendChild(copy);
    const del = document.createElement("button");
    del.className = "icon-btn danger";
    del.textContent = "\u{1F5D1}\uFE0F";
    del.title = "Delete";
    del.setAttribute("aria-label", "Delete");
    del.addEventListener("click", async (e) => {
      e.stopPropagation();
      closeMenu();
      if (await confirmModal("Delete this item?")) {
        await deleteItem(item.id);
        onChange && onChange();
      }
    });
    menu.appendChild(del);
    card.appendChild(header);
    const body = document.createElement("div");
    body.className = "card-body";
    card.appendChild(body);
    let bodyRendered = false;
    function renderBody() {
      body.innerHTML = "";
      const identifiers = document.createElement("div");
      identifiers.className = "identifiers";
      (item.blocks || []).forEach((b) => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = b;
        identifiers.appendChild(chip);
      });
      (item.weeks || []).forEach((w) => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = "W" + w;
        identifiers.appendChild(chip);
      });
      if (item.lectures) {
        item.lectures.forEach((l) => {
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = "\u{1F4DA} " + (l.name || l.id);
          identifiers.appendChild(chip);
        });
      }
      body.appendChild(identifiers);
      const defs = fieldDefs[item.kind] || [];
      defs.forEach(([f, label, icon]) => {
        if (!item[f]) return;
        const sec = document.createElement("div");
        sec.className = "section";
        sec.style.borderLeftColor = color;
        const tl = document.createElement("div");
        tl.className = "section-title";
        tl.textContent = label;
        if (icon) tl.prepend(icon + " ");
        sec.appendChild(tl);
        const txt = document.createElement("div");
        txt.className = "section-content";
        renderRichText(txt, item[f]);
        sec.appendChild(txt);
        body.appendChild(sec);
      });
      const extras = ensureExtras(item);
      extras.forEach((extra) => {
        if (!extra || !extra.body) return;
        const sec = document.createElement("div");
        sec.className = "section section--extra";
        const tl = document.createElement("div");
        tl.className = "section-title";
        tl.textContent = extra.title || "Additional Section";
        sec.appendChild(tl);
        const txt = document.createElement("div");
        txt.className = "section-content";
        renderRichText(txt, extra.body);
        sec.appendChild(txt);
        body.appendChild(sec);
      });
      if (item.links && item.links.length) {
        const lc = document.createElement("span");
        lc.className = "chip link-chip";
        lc.textContent = `\u{1FAA2} ${item.links.length}`;
        body.appendChild(lc);
      }
    }
    function ensureBodyRendered() {
      if (bodyRendered) return;
      renderBody();
      bodyRendered = true;
    }
    if (expanded.has(item.id)) {
      ensureBodyRendered();
      card.classList.add("expanded");
    }
    mainBtn.addEventListener("click", () => {
      const isExpanded = expanded.has(item.id);
      if (isExpanded) {
        expanded.delete(item.id);
      } else {
        expanded.add(item.id);
        ensureBodyRendered();
      }
      card.classList.toggle("expanded", !isExpanded);
      mainBtn.setAttribute("aria-expanded", String(!isExpanded));
    });
    return card;
  }
  async function renderCardList(container, itemSource, kind, onChange) {
    container.innerHTML = "";
    const { blocks } = await loadBlockCatalog();
    const latestBlockId = resolveLatestBlockId(blocks);
    const blockTitleMap = new Map(blocks.map((block) => [block.blockId, block.title || block.blockId]));
    const blockTitle = (id) => blockTitleMap.get(id) || id;
    const orderMap = new Map(blocks.map((b, i) => [b.blockId, i]));
    const blockWeekMap = /* @__PURE__ */ new Map();
    const allWeeks = /* @__PURE__ */ new Set();
    blocks.forEach((block) => {
      if (!block) return;
      const weeks = /* @__PURE__ */ new Set();
      if (Number.isFinite(block.weeks)) {
        for (let i = 1; i <= block.weeks; i++) weeks.add(i);
      }
      (block.lectures || []).forEach((lecture) => {
        if (typeof lecture.week === "number") weeks.add(lecture.week);
      });
      const sortedWeeks = Array.from(weeks).sort((a, b) => a - b);
      blockWeekMap.set(block.blockId, sortedWeeks);
      sortedWeeks.forEach((weekNumber) => allWeeks.add(weekNumber));
    });
    const sortedAllWeeks = Array.from(allWeeks).sort((a, b) => a - b);
    const groups = /* @__PURE__ */ new Map();
    let totalItems = 0;
    function addItem(it) {
      if (!it) return;
      totalItems += 1;
      let block = "_";
      let week = "_";
      if (Array.isArray(it.lectures) && it.lectures.length) {
        let bestOrd = Infinity;
        let bestWeek = -Infinity;
        let bestLec = -Infinity;
        it.lectures.forEach((l) => {
          if (!l) return;
          const ord = orderMap.has(l.blockId) ? orderMap.get(l.blockId) : Infinity;
          if (ord < bestOrd || ord === bestOrd && (l.week > bestWeek || l.week === bestWeek && l.id > bestLec)) {
            block = l.blockId;
            week = l.week;
            bestOrd = ord;
            bestWeek = l.week;
            bestLec = l.id;
          }
        });
      } else {
        let bestOrd = Infinity;
        (Array.isArray(it.blocks) ? it.blocks : []).forEach((id) => {
          const ord = orderMap.has(id) ? orderMap.get(id) : Infinity;
          if (ord < bestOrd) {
            block = id;
            bestOrd = ord;
          }
        });
        if (Array.isArray(it.weeks) && it.weeks.length) {
          week = Math.max(...it.weeks);
        }
      }
      if (!groups.has(block)) {
        groups.set(block, /* @__PURE__ */ new Map());
      }
      const wkMap = groups.get(block);
      const current = wkMap.get(week) || [];
      current.push(it);
      wkMap.set(week, current);
    }
    if (itemSource) {
      if (typeof itemSource?.[Symbol.asyncIterator] === "function") {
        for await (const batch of itemSource) {
          if (Array.isArray(batch)) {
            batch.forEach(addItem);
          } else if (batch) {
            addItem(batch);
          }
        }
      } else if (typeof itemSource?.toArray === "function") {
        const collected = await itemSource.toArray();
        collected.forEach(addItem);
      } else if (Array.isArray(itemSource)) {
        itemSource.forEach(addItem);
      }
    }
    const sortedBlocks = Array.from(groups.keys()).sort((a, b) => {
      const ao = orderMap.has(a) ? orderMap.get(a) : Infinity;
      const bo = orderMap.has(b) ? orderMap.get(b) : Infinity;
      return ao - bo;
    });
    reportListComplexity("cardlist", { items: totalItems, columns: state.entryLayout?.columns || 1 });
    const perfMode = getPerformanceMode();
    const LIST_CHUNK_SIZE = perfMode === "conservative" ? 48 : perfMode === "balanced" ? 120 : 200;
    const layoutState = state.entryLayout;
    const scheduleChunk = typeof window !== "undefined" && typeof window.requestIdleCallback === "function" ? (cb) => window.requestIdleCallback(() => cb(), { timeout: 120 }) : (cb) => requestAnimationFrame(cb);
    const toolbar = document.createElement("div");
    toolbar.className = "entry-layout-toolbar";
    const rawSort = state.filters?.sort;
    const sortOptions = ["updated", "created", "lecture", "name"];
    let currentSortField = "updated";
    let currentSortDirection = "desc";
    if (typeof rawSort === "string" && rawSort) {
      const parts = rawSort.split("-");
      if (parts.length === 1) {
        currentSortField = sortOptions.includes(parts[0]) ? parts[0] : "updated";
      } else {
        const [fieldPart, dirPart] = parts;
        currentSortField = sortOptions.includes(fieldPart) ? fieldPart : "updated";
        currentSortDirection = dirPart === "asc" ? "asc" : "desc";
      }
    } else if (rawSort && typeof rawSort === "object") {
      const mode2 = rawSort.mode;
      const dir = rawSort.direction;
      if (typeof mode2 === "string" && sortOptions.includes(mode2)) {
        currentSortField = mode2;
      }
      if (dir === "asc" || dir === "desc") {
        currentSortDirection = dir;
      }
    }
    const filterGroup = document.createElement("div");
    filterGroup.className = "entry-toolbar-group entry-toolbar-filters";
    const filterControls = document.createElement("div");
    filterControls.className = "entry-filter-controls";
    const currentBlockFilter = typeof state.filters?.block === "string" ? state.filters.block : "";
    const currentWeekFilter = state.filters?.week ?? "";
    const blockFilterLabel = document.createElement("label");
    blockFilterLabel.className = "entry-filter-select";
    blockFilterLabel.textContent = "Block";
    const blockFilterSelect = document.createElement("select");
    blockFilterSelect.className = "entry-filter-block";
    blockFilterSelect.setAttribute("aria-label", "Filter entries by block");
    const blockOptions = [
      { value: "", label: "All blocks" },
      { value: "__unlabeled", label: "Unlabeled" }
    ];
    blocks.forEach((block) => {
      if (!block) return;
      blockOptions.push({ value: block.blockId, label: blockTitle(block.blockId) });
    });
    blockOptions.forEach((opt) => {
      const option = document.createElement("option");
      option.value = opt.value;
      option.textContent = opt.label;
      blockFilterSelect.appendChild(option);
    });
    if (blockOptions.some((opt) => opt.value === currentBlockFilter)) {
      blockFilterSelect.value = currentBlockFilter;
    } else {
      blockFilterSelect.value = "";
    }
    blockFilterLabel.appendChild(blockFilterSelect);
    filterControls.appendChild(blockFilterLabel);
    const weekFilterLabel = document.createElement("label");
    weekFilterLabel.className = "entry-filter-select";
    weekFilterLabel.textContent = "Week";
    const weekFilterSelect = document.createElement("select");
    weekFilterSelect.className = "entry-filter-week";
    weekFilterSelect.setAttribute("aria-label", "Filter entries by week");
    weekFilterLabel.appendChild(weekFilterSelect);
    filterControls.appendChild(weekFilterLabel);
    function populateWeekFilter() {
      const selectedBlock = blockFilterSelect.value;
      weekFilterSelect.innerHTML = "";
      const defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.textContent = "All weeks";
      weekFilterSelect.appendChild(defaultOption);
      if (selectedBlock === "__unlabeled") {
        weekFilterSelect.disabled = true;
        return;
      }
      weekFilterSelect.disabled = false;
      const weeks = selectedBlock && blockWeekMap.has(selectedBlock) ? blockWeekMap.get(selectedBlock) : sortedAllWeeks;
      if (!weeks.length) {
        const none = document.createElement("option");
        none.value = "";
        none.textContent = selectedBlock ? "No weeks available" : "No weeks defined";
        none.disabled = true;
        weekFilterSelect.appendChild(none);
        return;
      }
      weeks.forEach((weekNumber) => {
        const option = document.createElement("option");
        option.value = String(weekNumber);
        option.textContent = `Week ${weekNumber}`;
        weekFilterSelect.appendChild(option);
      });
    }
    filterGroup.appendChild(filterControls);
    toolbar.appendChild(filterGroup);
    populateWeekFilter();
    const normalizedWeekFilter = currentWeekFilter === "" || currentWeekFilter == null ? "" : String(currentWeekFilter);
    if (normalizedWeekFilter && weekFilterSelect.querySelector(`option[value="${normalizedWeekFilter}"]`)) {
      weekFilterSelect.value = normalizedWeekFilter;
    } else {
      weekFilterSelect.value = "";
    }
    blockFilterSelect.addEventListener("change", () => {
      populateWeekFilter();
      weekFilterSelect.value = "";
      const nextBlock = blockFilterSelect.value || "";
      const patch = { block: nextBlock, week: "" };
      const currentBlockValue = state.filters.block || "";
      const currentWeekValue = state.filters.week || "";
      if (currentBlockValue !== patch.block || currentWeekValue !== patch.week) {
        setFilters(patch);
        onChange && onChange();
      }
    });
    weekFilterSelect.addEventListener("change", () => {
      if (weekFilterSelect.disabled) return;
      const raw = weekFilterSelect.value;
      const normalized2 = raw ? Number(raw) : "";
      if (normalized2 !== "" && !Number.isFinite(normalized2)) return;
      const currentValue = state.filters.week ?? "";
      const normalizedCurrent = currentValue === "" ? "" : Number(currentValue);
      if (normalized2 === "" && currentValue === "") return;
      if (normalized2 !== "" && String(normalizedCurrent) === String(normalized2)) return;
      setFilters({ week: normalized2 });
      onChange && onChange();
    });
    const sortControls = document.createElement("div");
    sortControls.className = "sort-controls";
    const sortLabel = document.createElement("label");
    sortLabel.className = "sort-select";
    sortLabel.textContent = "Sort by";
    const sortSelect = document.createElement("select");
    sortSelect.className = "sort-field";
    sortSelect.setAttribute("aria-label", "Sort entries");
    [
      { value: "updated", label: "Date Modified" },
      { value: "created", label: "Date Added" },
      { value: "lecture", label: "Lecture Added" },
      { value: "name", label: "Alphabetical" }
    ].forEach((opt) => {
      const option = document.createElement("option");
      option.value = opt.value;
      option.textContent = opt.label;
      sortSelect.appendChild(option);
    });
    sortSelect.value = currentSortField;
    sortLabel.appendChild(sortSelect);
    sortControls.appendChild(sortLabel);
    const directionBtn = document.createElement("button");
    directionBtn.type = "button";
    directionBtn.className = "sort-direction-btn";
    directionBtn.setAttribute("aria-label", "Toggle sort direction");
    directionBtn.setAttribute("title", "Toggle sort direction");
    function updateDirectionButton() {
      directionBtn.dataset.direction = currentSortDirection;
      directionBtn.textContent = currentSortDirection === "asc" ? "\u2191 Asc" : "\u2193 Desc";
    }
    function applySortChange() {
      const nextValue = `${currentSortField}-${currentSortDirection}`;
      if (state.filters.sort === nextValue) return;
      setFilters({ sort: nextValue });
      onChange && onChange();
    }
    updateDirectionButton();
    sortSelect.addEventListener("change", () => {
      const selected = sortSelect.value;
      currentSortField = sortOptions.includes(selected) ? selected : "updated";
      applySortChange();
    });
    directionBtn.addEventListener("click", () => {
      currentSortDirection = currentSortDirection === "asc" ? "desc" : "asc";
      updateDirectionButton();
      applySortChange();
    });
    sortControls.appendChild(directionBtn);
    sortControls.classList.add("entry-toolbar-group");
    toolbar.appendChild(sortControls);
    const viewToggle = document.createElement("div");
    viewToggle.className = "layout-toggle";
    const listBtn = document.createElement("button");
    listBtn.type = "button";
    listBtn.className = "layout-btn";
    setToggleState(listBtn, layoutState.mode === "list");
    listBtn.textContent = "List";
    listBtn.addEventListener("click", () => {
      if (layoutState.mode === "list") return;
      setEntryLayout({ mode: "list" });
      updateToolbar();
      applyLayout();
    });
    const gridBtn = document.createElement("button");
    gridBtn.type = "button";
    gridBtn.className = "layout-btn";
    setToggleState(gridBtn, layoutState.mode === "grid");
    gridBtn.textContent = "Grid";
    gridBtn.addEventListener("click", () => {
      if (layoutState.mode === "grid") return;
      setEntryLayout({ mode: "grid" });
      updateToolbar();
      applyLayout();
    });
    viewToggle.appendChild(listBtn);
    viewToggle.appendChild(gridBtn);
    viewToggle.classList.add("entry-toolbar-group");
    toolbar.appendChild(viewToggle);
    const controlsToggle = document.createElement("button");
    controlsToggle.type = "button";
    controlsToggle.className = "layout-advanced-toggle";
    setToggleState(controlsToggle, layoutState.controlsVisible);
    controlsToggle.addEventListener("click", () => {
      setEntryLayout({ controlsVisible: !state.entryLayout.controlsVisible });
      updateToolbar();
    });
    controlsToggle.classList.add("entry-toolbar-group");
    toolbar.appendChild(controlsToggle);
    const controlsWrap = document.createElement("div");
    controlsWrap.className = "layout-controls";
    const controlsId = `layout-controls-${Math.random().toString(36).slice(2, 8)}`;
    controlsWrap.id = controlsId;
    controlsToggle.setAttribute("aria-controls", controlsId);
    toolbar.appendChild(controlsWrap);
    const columnWrap = document.createElement("label");
    columnWrap.className = "layout-control";
    columnWrap.textContent = "Columns";
    const columnInput = document.createElement("input");
    columnInput.type = "range";
    columnInput.min = "1";
    columnInput.max = "6";
    columnInput.step = "1";
    columnInput.value = String(layoutState.columns);
    const columnValue = document.createElement("span");
    columnValue.className = "layout-value";
    columnValue.textContent = String(layoutState.columns);
    columnInput.addEventListener("input", () => {
      setEntryLayout({ columns: Number(columnInput.value) });
      columnValue.textContent = String(state.entryLayout.columns);
      applyLayout();
    });
    columnWrap.appendChild(columnInput);
    columnWrap.appendChild(columnValue);
    controlsWrap.appendChild(columnWrap);
    const scaleWrap = document.createElement("label");
    scaleWrap.className = "layout-control";
    scaleWrap.textContent = "Scale";
    const scaleInput = document.createElement("input");
    scaleInput.type = "range";
    scaleInput.min = "0.6";
    scaleInput.max = "1.4";
    scaleInput.step = "0.05";
    scaleInput.value = String(layoutState.scale);
    const scaleValue = document.createElement("span");
    scaleValue.className = "layout-value";
    scaleValue.textContent = `${layoutState.scale.toFixed(2)}x`;
    scaleInput.addEventListener("input", () => {
      setEntryLayout({ scale: Number(scaleInput.value) });
      scaleValue.textContent = `${state.entryLayout.scale.toFixed(2)}x`;
      applyLayout();
    });
    scaleWrap.appendChild(scaleInput);
    scaleWrap.appendChild(scaleValue);
    controlsWrap.appendChild(scaleWrap);
    container.appendChild(toolbar);
    function updateToolbar() {
      const { mode: mode2, controlsVisible } = state.entryLayout;
      setToggleState(listBtn, mode2 === "list");
      setToggleState(gridBtn, mode2 === "grid");
      columnWrap.style.display = mode2 === "grid" ? "" : "none";
      controlsWrap.style.display = controlsVisible ? "" : "none";
      controlsWrap.setAttribute("aria-hidden", controlsVisible ? "false" : "true");
      controlsToggle.textContent = controlsVisible ? "Hide layout tools" : "Show layout tools";
      controlsToggle.setAttribute("aria-expanded", controlsVisible ? "true" : "false");
      setToggleState(controlsToggle, controlsVisible);
    }
    function applyLayout() {
      const lists = container.querySelectorAll(".card-list");
      lists.forEach((list) => {
        list.classList.toggle("grid-layout", state.entryLayout.mode === "grid");
        list.style.setProperty("--entry-scale", state.entryLayout.scale);
        list.style.setProperty("--entry-columns", state.entryLayout.columns);
      });
    }
    updateToolbar();
    const blockKeys = sortedBlocks.map((b) => String(b));
    function applyBlockActivation(nextKey) {
      const candidate = nextKey && blockKeys.includes(nextKey) ? nextKey : null;
      activeBlockKey = candidate;
      collapsedBlocks.clear();
      if (!activeBlockKey) {
        blockKeys.forEach((key) => collapsedBlocks.add(key));
      } else {
        blockKeys.forEach((key) => {
          if (key !== activeBlockKey) {
            collapsedBlocks.add(key);
          }
        });
      }
    }
    if (blockKeys.length) {
      const preferred = latestBlockId && blockKeys.includes(String(latestBlockId)) ? String(latestBlockId) : null;
      const initial = preferred || (activeBlockKey && blockKeys.includes(activeBlockKey) ? activeBlockKey : null) || blockKeys[0];
      applyBlockActivation(initial);
    } else {
      applyBlockActivation(null);
    }
    const blockUpdaters = /* @__PURE__ */ new Map();
    const refreshBlocks = () => {
      blockUpdaters.forEach((fn) => fn());
    };
    sortedBlocks.forEach((b) => {
      const blockSec = document.createElement("section");
      blockSec.className = "block-section";
      const blockHeader = document.createElement("button");
      blockHeader.type = "button";
      blockHeader.className = "block-header";
      const blockLabel = b === "_" ? "Unassigned" : blockTitle(b);
      const blockKey = String(b);
      const bdef = blocks.find((bl) => bl.blockId === b);
      if (bdef?.color) blockHeader.style.background = bdef.color;
      const weekEntries = [];
      const ensureVisibleWeeks = () => {
        if (collapsedBlocks.has(blockKey)) return;
        weekEntries.forEach((entry) => {
          if (!collapsedWeeks.has(entry.weekKey)) entry.ensureListRendered();
        });
      };
      function updateBlockState() {
        const isCollapsed = collapsedBlocks.has(blockKey);
        blockSec.classList.toggle("collapsed", isCollapsed);
        blockHeader.textContent = `${isCollapsed ? "\u25B8" : "\u25BE"} ${blockLabel}`;
        blockHeader.setAttribute("aria-expanded", String(!isCollapsed));
        if (!isCollapsed) {
          ensureVisibleWeeks();
        }
      }
      blockUpdaters.set(blockKey, updateBlockState);
      updateBlockState();
      blockHeader.addEventListener("click", () => {
        const isCollapsed = collapsedBlocks.has(blockKey);
        if (isCollapsed) {
          applyBlockActivation(blockKey);
        } else if (activeBlockKey === blockKey) {
          applyBlockActivation(null);
        } else {
          collapsedBlocks.add(blockKey);
        }
        refreshBlocks();
      });
      blockSec.appendChild(blockHeader);
      const wkMap = groups.get(b);
      if (!wkMap) {
        return;
      }
      const sortedWeeks = Array.from(wkMap.keys()).sort((a, b2) => {
        if (a === "_" && b2 !== "_") return 1;
        if (b2 === "_" && a !== "_") return -1;
        return Number(b2) - Number(a);
      });
      sortedWeeks.forEach((w) => {
        const weekSec = document.createElement("div");
        weekSec.className = "week-section";
        const weekHeader = document.createElement("button");
        weekHeader.type = "button";
        weekHeader.className = "week-header";
        const weekLabel = w === "_" ? "Unassigned" : `Week ${w}`;
        const weekKey = `${blockKey}__${w}`;
        let listRendered = false;
        function updateWeekState() {
          const isCollapsed = collapsedWeeks.has(weekKey);
          weekSec.classList.toggle("collapsed", isCollapsed);
          weekHeader.textContent = `${isCollapsed ? "\u25B8" : "\u25BE"} ${weekLabel}`;
          weekHeader.setAttribute("aria-expanded", String(!isCollapsed));
          if (!isCollapsed && !collapsedBlocks.has(blockKey)) {
            ensureListRendered();
          }
        }
        updateWeekState();
        weekHeader.addEventListener("click", () => {
          if (collapsedWeeks.has(weekKey)) collapsedWeeks.delete(weekKey);
          else collapsedWeeks.add(weekKey);
          updateWeekState();
        });
        weekSec.appendChild(weekHeader);
        const list = document.createElement("div");
        list.className = "card-list";
        list.style.setProperty("--entry-scale", state.entryLayout.scale);
        list.style.setProperty("--entry-columns", state.entryLayout.columns);
        list.classList.toggle("grid-layout", state.entryLayout.mode === "grid");
        const rows = wkMap.get(w) || [];
        function renderChunk(start = 0) {
          if (!rows.length) return;
          const slice = rows.slice(start, start + LIST_CHUNK_SIZE);
          if (!slice.length) return;
          const fragment = document.createDocumentFragment();
          slice.forEach((it) => {
            fragment.appendChild(createItemCard(it, onChange));
          });
          list.appendChild(fragment);
          if (start + LIST_CHUNK_SIZE < rows.length) {
            scheduleChunk(() => renderChunk(start + LIST_CHUNK_SIZE));
          }
        }
        function ensureListRendered() {
          if (listRendered) return;
          listRendered = true;
          renderChunk();
        }
        weekEntries.push({ weekKey, ensureListRendered });
        weekSec.appendChild(list);
        blockSec.appendChild(weekSec);
      });
      ensureVisibleWeeks();
      container.appendChild(blockSec);
    });
    applyLayout();
  }
  var kindColors, fieldDefs, expanded, collapsedBlocks, collapsedWeeks, activeBlockKey;
  var init_cardlist = __esm({
    "js/ui/components/cardlist.js"() {
      init_storage();
      init_block_catalog();
      init_state();
      init_utils();
      init_editor();
      init_confirm();
      init_linker();
      init_rich_text();
      init_performance();
      kindColors = { disease: "var(--purple)", drug: "var(--green)", concept: "var(--blue)" };
      fieldDefs = {
        disease: [
          ["etiology", "Etiology", "\u{1F9EC}"],
          ["pathophys", "Pathophys", "\u2699\uFE0F"],
          ["clinical", "Clinical", "\u{1FA7A}"],
          ["diagnosis", "Diagnosis", "\u{1F50E}"],
          ["treatment", "Treatment", "\u{1F48A}"],
          ["complications", "Complications", "\u26A0\uFE0F"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ],
        drug: [
          ["class", "Class", "\u{1F3F7}\uFE0F"],
          ["source", "Source", "\u{1F331}"],
          ["moa", "MOA", "\u2699\uFE0F"],
          ["uses", "Uses", "\u{1F48A}"],
          ["sideEffects", "Side Effects", "\u26A0\uFE0F"],
          ["contraindications", "Contraindications", "\u{1F6AB}"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ],
        concept: [
          ["type", "Type", "\u{1F3F7}\uFE0F"],
          ["definition", "Definition", "\u{1F4D6}"],
          ["mechanism", "Mechanism", "\u2699\uFE0F"],
          ["clinicalRelevance", "Clinical Relevance", "\u{1FA7A}"],
          ["example", "Example", "\u{1F4DD}"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ]
      };
      expanded = /* @__PURE__ */ new Set();
      collapsedBlocks = /* @__PURE__ */ new Set();
      collapsedWeeks = /* @__PURE__ */ new Set();
      activeBlockKey = null;
    }
  });

  // js/ui/components/sections.js
  function createNoopInstrumentation() {
    return {
      noteRender() {
      },
      trackSectionUsage() {
      }
    };
  }
  function initLayoutInstrumentation() {
    if (layoutInstrumentation) return layoutInstrumentation;
    if (typeof window === "undefined") {
      layoutInstrumentation = createNoopInstrumentation();
      return layoutInstrumentation;
    }
    const userAgent = typeof navigator === "object" ? String(navigator.userAgent || "") : "";
    const isElectron = /Electron/i.test(userAgent);
    if (!isElectron) {
      layoutInstrumentation = createNoopInstrumentation();
      return layoutInstrumentation;
    }
    const lastRenderByScope = /* @__PURE__ */ new Map();
    const sectionHitCache = /* @__PURE__ */ new Map();
    const getTime = () => {
      if (typeof performance === "object" && typeof performance.now === "function") {
        return performance.now();
      }
      return Date.now();
    };
    const scheduleFrame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : ((cb) => setTimeout(cb, 16));
    let flushTimer = 0;
    const layoutSummary = { shifts: 0, longTasks: 0 };
    const scheduleFlush = () => {
      if (flushTimer) return;
      flushTimer = setTimeout(() => {
        flushTimer = 0;
        const { shifts, longTasks } = layoutSummary;
        if (shifts >= 4 || longTasks >= 1) {
          console.warn("[layout-monitor] Frequent layout work detected", {
            layoutShifts: Number(shifts.toFixed ? shifts.toFixed(3) : shifts),
            longTasks
          });
        }
        layoutSummary.shifts = 0;
        layoutSummary.longTasks = 0;
      }, 160);
    };
    if (typeof PerformanceObserver === "function") {
      try {
        const layoutObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry && entry.value && !entry.hadRecentInput) {
              layoutSummary.shifts += entry.value;
            }
          }
          scheduleFlush();
        });
        layoutObserver.observe({ type: "layout-shift", buffered: true });
      } catch (err) {
        console.debug("[layout-monitor] Layout shift observer unavailable", err);
      }
      try {
        const longTaskObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          if (entries && entries.length) {
            layoutSummary.longTasks += entries.length;
            scheduleFlush();
          }
        });
        longTaskObserver.observe({ type: "longtask", buffered: true });
      } catch (err) {
        console.debug("[layout-monitor] Long task observer unavailable", err);
      }
    }
    function noteRender(scope) {
      if (!scope) return;
      const now = getTime();
      const previous = lastRenderByScope.get(scope);
      lastRenderByScope.set(scope, now);
      if (previous && now - previous < 48) {
        console.warn("[layout-monitor] Duplicate render detected", {
          scope,
          delta: Math.round(now - previous)
        });
      }
    }
    function trackSectionUsage(itemId, sectionKey) {
      if (!sectionKey) return;
      const id = itemId != null ? String(itemId) : "unknown";
      const signature = `${id}::${sectionKey}`;
      const now = getTime();
      const previous = sectionHitCache.get(signature);
      sectionHitCache.set(signature, now);
      scheduleFrame(() => {
        const timestamp = sectionHitCache.get(signature);
        if (timestamp && now !== timestamp && now < timestamp) {
          return;
        }
        const LIMIT = 200;
        if (sectionHitCache.size > LIMIT) {
          const cutoff = getTime() - 2e3;
          for (const [key, value] of sectionHitCache.entries()) {
            if (value < cutoff) sectionHitCache.delete(key);
          }
        }
      });
      if (previous && now - previous < 250) {
        console.warn("[layout-monitor] Rapid section reuse detected", {
          itemId: id,
          sectionKey,
          delta: Math.round(now - previous)
        });
      }
    }
    layoutInstrumentation = { noteRender, trackSectionUsage };
    return layoutInstrumentation;
  }
  function getLayoutInstrumentation() {
    if (!layoutInstrumentation) {
      layoutInstrumentation = initLayoutInstrumentation();
    }
    return layoutInstrumentation;
  }
  function sectionDefsForKind(kind) {
    return SECTION_DEFS[kind] || [];
  }
  function noteTabRender(scope) {
    getLayoutInstrumentation().noteRender(scope);
  }
  function noteSectionUsage(itemId, sectionKey) {
    getLayoutInstrumentation().trackSectionUsage(itemId, sectionKey);
  }
  var SECTION_DEFS, layoutInstrumentation;
  var init_sections = __esm({
    "js/ui/components/sections.js"() {
      SECTION_DEFS = {
        disease: [
          { key: "etiology", label: "Etiology" },
          { key: "pathophys", label: "Pathophys" },
          { key: "clinical", label: "Clinical Presentation" },
          { key: "diagnosis", label: "Diagnosis" },
          { key: "treatment", label: "Treatment" },
          { key: "complications", label: "Complications" },
          { key: "mnemonic", label: "Mnemonic" }
        ],
        drug: [
          { key: "moa", label: "Mechanism" },
          { key: "uses", label: "Uses" },
          { key: "sideEffects", label: "Side Effects" },
          { key: "contraindications", label: "Contraindications" },
          { key: "mnemonic", label: "Mnemonic" }
        ],
        concept: [
          { key: "definition", label: "Definition" },
          { key: "mechanism", label: "Mechanism" },
          { key: "clinicalRelevance", label: "Clinical Relevance" },
          { key: "example", label: "Example" },
          { key: "mnemonic", label: "Mnemonic" }
        ]
      };
      layoutInstrumentation = null;
    }
  });

  // js/ui/components/cards.js
  var cards_exports = {};
  __export(cards_exports, {
    __setCardsDeps: () => __setCardsDeps,
    renderCards: () => renderCards
  });
  function __setCardsDeps(overrides = {}) {
    deps.loadBlockCatalog = typeof overrides.loadBlockCatalog === "function" ? overrides.loadBlockCatalog : loadBlockCatalog;
  }
  function formatWeekLabel(value) {
    if (typeof value === "number" && Number.isFinite(value)) {
      return `Week ${value}`;
    }
    return "Unscheduled";
  }
  function titleFromItem(item) {
    if (item && typeof item === "object") {
      if (TITLE_CACHE.has(item)) {
        return TITLE_CACHE.get(item);
      }
      const title = item?.name || item?.concept || "Untitled Card";
      TITLE_CACHE.set(item, title);
      return title;
    }
    return item?.name || item?.concept || "Untitled Card";
  }
  function compareByCreation(a, b) {
    const av = typeof a?.createdAt === "number" ? a.createdAt : 0;
    const bv = typeof b?.createdAt === "number" ? b.createdAt : 0;
    if (av !== bv) return av - bv;
    const at = titleFromItem(a);
    const bt = titleFromItem(b);
    return at.localeCompare(bt);
  }
  function escapeHtml5(str = "") {
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function ensureExtras2(item) {
    if (Array.isArray(item?.extras) && item.extras.length) {
      return item.extras;
    }
    if (item?.facts && item.facts.length) {
      return [{
        id: "legacy-facts",
        title: "Highlights",
        body: `<ul>${item.facts.map((f) => `<li>${escapeHtml5(f)}</li>`).join("")}</ul>`
      }];
    }
    return [];
  }
  function createMutationScheduler() {
    if (typeof requestAnimationFrame !== "function") {
      return (task) => {
        if (typeof task !== "function") return;
        try {
          task();
        } catch (err) {
          console.error("[cards] Failed to apply DOM mutation", err);
        }
      };
    }
    let queue = [];
    let raf = 0;
    const flush = () => {
      raf = 0;
      const tasks = queue;
      queue = [];
      for (const task of tasks) {
        try {
          task();
        } catch (err) {
          console.error("[cards] Failed to apply DOM mutation", err);
        }
      }
    };
    return (task) => {
      if (typeof task !== "function") return;
      queue.push(task);
      if (!raf) {
        raf = requestAnimationFrame(flush);
      }
    };
  }
  function getItemAccent(item) {
    if (item?.color) return item.color;
    if (item?.kind && KIND_COLORS[item.kind]) return KIND_COLORS[item.kind];
    return "var(--accent)";
  }
  function collectLectureColors(cards, limit = 5) {
    if (!Array.isArray(cards) || !cards.length) {
      return ["var(--accent)"];
    }
    const seen = /* @__PURE__ */ new Set();
    const colors = [];
    for (const card of cards) {
      const accent = getItemAccent(card);
      if (!seen.has(accent)) {
        seen.add(accent);
        colors.push(accent);
        if (colors.length >= limit) break;
      }
    }
    if (!colors.length) colors.push("var(--accent)");
    return colors.slice(0, Math.max(1, limit));
  }
  function buildGradient(colors) {
    const palette2 = colors && colors.length ? colors : ["var(--accent)"];
    if (palette2.length === 1) {
      const single = palette2[0];
      return `linear-gradient(135deg, ${single} 0%, color-mix(in srgb, ${single} 38%, transparent) 100%)`;
    }
    const stops = palette2.map((color, idx) => {
      const pct = palette2.length === 1 ? 0 : Math.round(idx / (palette2.length - 1) * 100);
      return `${color} ${pct}%`;
    });
    return `linear-gradient(135deg, ${stops.join(", ")})`;
  }
  function getLecturePalette(cards) {
    const colors = collectLectureColors(cards);
    return {
      accent: colors[0] || "var(--accent)",
      colors,
      gradient: buildGradient(colors)
    };
  }
  function getLectureAccent(cards) {
    return getLecturePalette(cards).accent;
  }
  async function renderCards(container, items, onChange) {
    noteTabRender("cards");
    if (typeof document !== "undefined") {
      document.body.classList.remove("is-deck-open");
      document.body.classList.remove("is-occlusion-workspace-open");
    }
    container.innerHTML = "";
    container.classList.add("cards-tab");
    container.style.overflowY = "auto";
    container.style.overscrollBehavior = "contain";
    container.style.scrollbarGutter = "stable both-edges";
    const shell = document.createElement("div");
    shell.className = "cards-shell";
    container.appendChild(shell);
    const scheduleDomMutation = createMutationScheduler();
    const runMutation = (task, options = {}) => {
      if (typeof task !== "function") return;
      const immediate = options.immediate === true;
      if (immediate) {
        try {
          task();
        } catch (err) {
          console.error("[cards] Failed to apply DOM mutation", err);
        }
        return;
      }
      scheduleDomMutation(task);
    };
    const sortedItems = Array.isArray(items) ? items.slice().sort(compareByCreation) : [];
    reportListComplexity("cards", { items: sortedItems.length, weight: 1.1 });
    const perfMode = getPerformanceMode();
    const MAX_EAGER_QUEUE = perfMode === "conservative" ? 2 : perfMode === "balanced" ? 4 : 6;
    const GRID_CHUNK_BUDGET = perfMode === "conservative" ? 3 : perfMode === "balanced" ? 5 : 6;
    const GRID_FRAME_BUDGET = perfMode === "conservative" ? 9 : perfMode === "balanced" ? 12 : 14;
    const OBSERVER_ROOT_MARGIN = perfMode === "conservative" ? "120px 0px" : perfMode === "balanced" ? "160px 0px" : "200px 0px";
    let blockDefs = [];
    try {
      const catalog2 = await deps.loadBlockCatalog();
      blockDefs = Array.isArray(catalog2?.blocks) ? catalog2.blocks : [];
    } catch (err) {
      console.warn("[cards] Unable to load block catalog, continuing with card data only", err);
      blockDefs = [];
    }
    const blockLookup = new Map(blockDefs.map((def) => [def.blockId, def]));
    const blockOrder = new Map(blockDefs.map((def, idx) => [def.blockId, idx]));
    const itemLookup = new Map(sortedItems.map((item) => [item.id, item]));
    const deckContextLookup = /* @__PURE__ */ new Map();
    const cardsState = state.cards || {};
    const stateInitialized = cardsState?.initialized === true;
    const hasCollapsedBlockState = stateInitialized && Array.isArray(cardsState.collapsedBlocks);
    const hasCollapsedWeekState = stateInitialized && Array.isArray(cardsState.collapsedWeeks);
    const collapsedBlockSet = new Set(hasCollapsedBlockState ? cardsState.collapsedBlocks : []);
    const collapsedWeekSet = new Set(hasCollapsedWeekState ? cardsState.collapsedWeeks : []);
    const scheduleFrame = typeof requestAnimationFrame === "function" ? ((cb) => requestAnimationFrame(cb)) : ((cb) => setTimeout(cb, 16));
    let persistHandle = 0;
    function schedulePersist2() {
      if (persistHandle) return;
      persistHandle = scheduleFrame(() => {
        persistHandle = 0;
        setCardsState({
          collapsedBlocks: Array.from(collapsedBlockSet),
          collapsedWeeks: Array.from(collapsedWeekSet)
        });
      });
    }
    function setBlockCollapsedState(key, collapsed) {
      if (!key) return;
      if (collapsed) {
        if (!collapsedBlockSet.has(key)) {
          collapsedBlockSet.add(key);
          schedulePersist2();
        }
      } else if (collapsedBlockSet.delete(key)) {
        schedulePersist2();
      }
    }
    function setWeekCollapsedState(key, collapsed) {
      if (!key) return;
      if (collapsed) {
        if (!collapsedWeekSet.has(key)) {
          collapsedWeekSet.add(key);
          schedulePersist2();
        }
      } else if (collapsedWeekSet.delete(key)) {
        schedulePersist2();
      }
    }
    const blockBuckets = /* @__PURE__ */ new Map();
    function ensureBlock(blockId) {
      const key = blockId || UNASSIGNED_BLOCK_KEY;
      if (!blockBuckets.has(key)) {
        const def = blockLookup.get(blockId);
        const order = typeof blockId === "string" ? blockOrder.get(blockId) ?? 999 : 1200;
        blockBuckets.set(key, {
          key,
          blockId: blockId || null,
          title: def?.title || (blockId ? blockId : "Unassigned"),
          accent: def?.color || null,
          order,
          weeks: /* @__PURE__ */ new Map()
        });
      }
      return blockBuckets.get(key);
    }
    function ensureWeek(blockBucket, weekValue) {
      const weekKey = weekValue == null ? "none" : String(weekValue);
      if (!blockBucket.weeks.has(weekKey)) {
        blockBucket.weeks.set(weekKey, {
          key: weekKey,
          value: typeof weekValue === "number" && Number.isFinite(weekValue) ? weekValue : null,
          label: formatWeekLabel(weekValue),
          order: typeof weekValue === "number" && Number.isFinite(weekValue) ? weekValue : 999,
          lectures: /* @__PURE__ */ new Map()
        });
      }
      return blockBucket.weeks.get(weekKey);
    }
    function ensureLecture(weekBucket, lectureKey2, lectureName) {
      if (!weekBucket.lectures.has(lectureKey2)) {
        weekBucket.lectures.set(lectureKey2, {
          key: lectureKey2,
          title: lectureName || "Lecture",
          cards: []
        });
      }
      return weekBucket.lectures.get(lectureKey2);
    }
    sortedItems.forEach((item) => {
      const lectureRefs = Array.isArray(item.lectures) ? item.lectures : [];
      if (lectureRefs.length) {
        lectureRefs.forEach((ref) => {
          const blockBucket = ensureBlock(ref.blockId);
          const weekBucket = ensureWeek(blockBucket, ref.week);
          const lectureKeyParts = [ref.blockId || blockBucket.key];
          if (ref.id != null) lectureKeyParts.push(`lec-${ref.id}`);
          if (ref.name) lectureKeyParts.push(ref.name);
          const lectureKey2 = lectureKeyParts.join("::") || `${blockBucket.key}-${titleFromItem(item)}`;
          const lecture = ensureLecture(weekBucket, lectureKey2, ref.name || (ref.id != null ? `Lecture ${ref.id}` : "Lecture"));
          if (!lecture.cards.includes(item)) {
            lecture.cards.push(item);
          }
        });
      } else if (Array.isArray(item.blocks) && item.blocks.length) {
        item.blocks.forEach((blockId) => {
          const blockBucket = ensureBlock(blockId);
          const weeks = Array.isArray(item.weeks) && item.weeks.length ? item.weeks : [null];
          weeks.forEach((weekVal) => {
            const weekBucket = ensureWeek(blockBucket, weekVal);
            const lecture = ensureLecture(weekBucket, `${blockBucket.key}::${MISC_LECTURE_KEY}`, "Ungrouped Items");
            lecture.cards.push(item);
          });
        });
      } else {
        const blockBucket = ensureBlock(null);
        const weekBucket = ensureWeek(blockBucket, null);
        const lecture = ensureLecture(weekBucket, `${blockBucket.key}::${MISC_LECTURE_KEY}`, "Unassigned Items");
        lecture.cards.push(item);
      }
    });
    const latestBlockId = resolveLatestBlockId(blockDefs);
    const blockSections = Array.from(blockBuckets.values()).map((block) => {
      const weeks = Array.from(block.weeks.values()).map((week) => {
        const lectures = Array.from(week.lectures.values()).map((lec) => {
          const cards = lec.cards.slice().sort(compareByCreation);
          return {
            ...lec,
            cards,
            palette: getLecturePalette(cards)
          };
        }).filter((lec) => lec.cards.length > 0).sort((a, b) => a.title.localeCompare(b.title));
        const totalCards2 = lectures.reduce((sum, lec) => sum + lec.cards.length, 0);
        return {
          ...week,
          lectures,
          totalCards: totalCards2,
          lectureCount: lectures.length
        };
      }).filter((week) => week.totalCards > 0).sort((a, b) => {
        const aValue = Number.isFinite(a.value) ? a.value : -Infinity;
        const bValue = Number.isFinite(b.value) ? b.value : -Infinity;
        if (aValue !== bValue) return bValue - aValue;
        return a.label.localeCompare(b.label);
      });
      const totalCards = weeks.reduce((sum, week) => sum + week.totalCards, 0);
      const lectureCount = weeks.reduce((sum, week) => sum + week.lectureCount, 0);
      return {
        ...block,
        weeks,
        totalCards,
        lectureCount
      };
    }).filter((block) => block.totalCards > 0).sort((a, b) => a.order - b.order || a.title.localeCompare(b.title));
    const totalLectures = blockSections.reduce((sum, block) => sum + block.lectureCount, 0);
    const heroStats = { blocks: blockSections.length, lectures: totalLectures };
    blockSections.forEach((block) => {
      block.weeks.forEach((week) => {
        week.lectures.forEach((lecture) => {
          lecture.cards.forEach((card) => {
            if (!deckContextLookup.has(card.id)) {
              deckContextLookup.set(card.id, []);
            }
            deckContextLookup.get(card.id).push({ block, week, lecture });
          });
        });
      });
    });
    if (!hasCollapsedBlockState) {
      const latestBlockKey = blockSections.find((block) => String(block.blockId ?? "") === String(latestBlockId))?.key;
      blockSections.forEach((block) => {
        if (!block?.key) return;
        if (latestBlockKey && block.key === latestBlockKey) return;
        collapsedBlockSet.add(block.key);
      });
      schedulePersist2();
    }
    if (!hasCollapsedWeekState) {
      const latestBlockKey = blockSections.find((block) => String(block.blockId ?? "") === String(latestBlockId))?.key;
      blockSections.forEach((block) => {
        block.weeks.forEach((week, index) => {
          const key = `${block.key}::${week.key}`;
          if (latestBlockKey && block.key === latestBlockKey && index === 0) return;
          collapsedWeekSet.add(key);
        });
      });
      schedulePersist2();
    }
    const gridPayload = /* @__PURE__ */ new WeakMap();
    const activeGrids = /* @__PURE__ */ new Set();
    let gridPumpHandle = 0;
    const getTime = typeof performance === "object" && typeof performance.now === "function" ? () => performance.now() : () => Date.now();
    const eagerGridQueue = [];
    const eagerGridSet = /* @__PURE__ */ new Set();
    let eagerGridFlushHandle = 0;
    function requestEagerGrid(grid) {
      if (!grid || eagerGridSet.has(grid)) return;
      if (eagerGridQueue.length >= MAX_EAGER_QUEUE) return;
      eagerGridQueue.push(grid);
      eagerGridSet.add(grid);
      if (eagerGridFlushHandle) return;
      eagerGridFlushHandle = scheduleFrame(() => {
        eagerGridFlushHandle = 0;
        while (eagerGridQueue.length) {
          const nextGrid = eagerGridQueue.shift();
          eagerGridSet.delete(nextGrid);
          if (!nextGrid || nextGrid.dataset.rendered === "true") continue;
          if (!nextGrid.isConnected) continue;
          ensureGridRendered(nextGrid);
        }
      });
    }
    const deckTileObserver = typeof IntersectionObserver === "function" ? new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          deckTileObserver.unobserve(entry.target);
          startGridRender(entry.target);
        }
      });
    }, { rootMargin: OBSERVER_ROOT_MARGIN }) : null;
    function scheduleGridPump() {
      if (gridPumpHandle) return;
      gridPumpHandle = requestAnimationFrame(() => {
        gridPumpHandle = 0;
        pumpGridRenders();
      });
    }
    function startGridRender(grid) {
      if (!grid || grid.dataset.rendered === "true") return;
      activeGrids.add(grid);
      scheduleGridPump();
    }
    function renderGridChunk(grid) {
      const payload = gridPayload.get(grid);
      if (!payload) {
        grid.dataset.rendered = "true";
        grid.classList.remove("is-loading");
        return;
      }
      const { entries } = payload;
      let { index = 0 } = payload;
      const frag = document.createDocumentFragment();
      const chunkStart = getTime();
      let elapsed = 0;
      while (index < entries.length && elapsed < GRID_CHUNK_BUDGET) {
        const { block, week, lecture } = entries[index++];
        frag.appendChild(createDeckTile(block, week, lecture));
        elapsed = getTime() - chunkStart;
      }
      payload.index = index;
      grid.appendChild(frag);
      if (index > 0) {
        grid.classList.remove("is-loading");
      }
      if (index >= entries.length) {
        grid.dataset.rendered = "true";
        grid.classList.remove("is-loading");
        gridPayload.delete(grid);
      }
    }
    function pumpGridRenders() {
      if (!activeGrids.size) return;
      const iterator = Array.from(activeGrids);
      const frameStart = getTime();
      for (const grid of iterator) {
        renderGridChunk(grid);
        if (grid.dataset.rendered === "true") {
          activeGrids.delete(grid);
        }
        if (getTime() - frameStart > GRID_FRAME_BUDGET) break;
      }
      if (activeGrids.size) {
        scheduleGridPump();
      }
    }
    function registerGrid(grid, entries, options = {}) {
      grid.dataset.rendered = "false";
      grid.classList.add("is-loading");
      gridPayload.set(grid, { entries, index: 0 });
      const deferInitialRender = Boolean(options?.deferInitialRender);
      if (!deferInitialRender) {
        requestEagerGrid(grid);
      }
      if (deckTileObserver) {
        requestAnimationFrame(() => {
          if (grid.dataset.rendered === "true") return;
          deckTileObserver.observe(grid);
        });
      } else if (!deferInitialRender) {
        startGridRender(grid);
      }
    }
    function ensureGridRendered(grid) {
      if (!grid || grid.dataset.rendered === "true") return;
      if (deckTileObserver) {
        deckTileObserver.unobserve(grid);
      }
      startGridRender(grid);
    }
    const blockRefs = [];
    function refreshHeroStats({ blocks = 0, lectures = 0 }) {
      statBlocksValue.textContent = String(blocks);
      statLecturesValue.textContent = String(lectures);
      statCardsValue.textContent = String(sortedItems.length);
    }
    function expandAllBlocks() {
      blockRefs.forEach((ref) => {
        ref.populate?.();
        ref.section.classList.remove("is-collapsed");
        ref.header.setAttribute("aria-expanded", "true");
        setBlockCollapsedState(ref.blockKey, false);
        ref.ensureVisibleWeekGrids?.();
        (ref.weeks || []).forEach((week) => {
          week.section.classList.remove("is-collapsed");
          week.header.setAttribute("aria-expanded", "true");
          setWeekCollapsedState(week.stateKey, false);
          ensureGridRendered(week.grid);
        });
      });
    }
    function collapseAllBlocks() {
      blockRefs.forEach((ref) => {
        ref.populate?.();
        ref.section.classList.add("is-collapsed");
        ref.header.setAttribute("aria-expanded", "false");
        setBlockCollapsedState(ref.blockKey, true);
        (ref.weeks || []).forEach((week) => {
          week.section.classList.add("is-collapsed");
          week.header.setAttribute("aria-expanded", "false");
          setWeekCollapsedState(week.stateKey, true);
        });
      });
    }
    const hero = document.createElement("section");
    hero.className = "cards-hero";
    const heroText = document.createElement("div");
    heroText.className = "cards-hero__text";
    const heroTitle = document.createElement("h1");
    heroTitle.className = "cards-hero__title";
    heroTitle.textContent = "Card decks";
    heroText.appendChild(heroTitle);
    const heroSubtitle = document.createElement("p");
    heroSubtitle.className = "cards-hero__subtitle";
    heroSubtitle.textContent = "Browse lecture-aligned decks with smoother spacing and quick controls for expanding everything or focusing on your most recent content.";
    heroText.appendChild(heroSubtitle);
    hero.appendChild(heroText);
    const heroMeta = document.createElement("div");
    heroMeta.className = "cards-hero__meta";
    const createStatPill = (label, initialValue = "0") => {
      const pill = document.createElement("span");
      pill.className = "cards-hero__pill";
      const labelEl = document.createElement("small");
      labelEl.textContent = label;
      const valueEl = document.createElement("strong");
      valueEl.textContent = initialValue;
      pill.append(labelEl, valueEl);
      return { pill, valueEl };
    };
    const { pill: statBlocks, valueEl: statBlocksValue } = createStatPill("Blocks");
    heroMeta.appendChild(statBlocks);
    const { pill: statLectures, valueEl: statLecturesValue } = createStatPill("Lectures");
    heroMeta.appendChild(statLectures);
    const { pill: statCards, valueEl: statCardsValue } = createStatPill("Cards", String(sortedItems.length));
    heroMeta.appendChild(statCards);
    hero.appendChild(heroMeta);
    const heroActions = document.createElement("div");
    heroActions.className = "cards-hero__actions";
    const expandAllBtn = document.createElement("button");
    expandAllBtn.type = "button";
    expandAllBtn.className = "cards-hero__action";
    expandAllBtn.textContent = "Expand all sections";
    expandAllBtn.addEventListener("click", expandAllBlocks);
    heroActions.appendChild(expandAllBtn);
    const collapseAllBtn = document.createElement("button");
    collapseAllBtn.type = "button";
    collapseAllBtn.className = "cards-hero__action ghost";
    collapseAllBtn.textContent = "Collapse all sections";
    collapseAllBtn.addEventListener("click", collapseAllBlocks);
    heroActions.appendChild(collapseAllBtn);
    hero.appendChild(heroActions);
    shell.appendChild(hero);
    refreshHeroStats(heroStats);
    const catalog = document.createElement("div");
    catalog.className = "card-catalog";
    shell.appendChild(catalog);
    const overlay = document.createElement("div");
    overlay.className = "deck-overlay";
    overlay.dataset.active = "false";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.hidden = true;
    overlay.inert = true;
    const viewer = document.createElement("div");
    viewer.className = "deck-viewer";
    overlay.appendChild(viewer);
    container.appendChild(overlay);
    let activeKeyHandler = null;
    let persistRelatedVisibility = false;
    let deckDirty = false;
    let overlayHideTimer = 0;
    let deckHistory = [];
    function closeDeck() {
      if (overlayHideTimer) {
        clearTimeout(overlayHideTimer);
        overlayHideTimer = 0;
      }
      runMutation(() => {
        overlay.dataset.active = "false";
        viewer.innerHTML = "";
        viewer.className = "deck-viewer";
        overlay.inert = true;
      }, { immediate: true });
      overlay.scrollTop = 0;
      document.body.classList.remove("is-deck-open");
      if (activeKeyHandler) {
        document.removeEventListener("keydown", activeKeyHandler);
        activeKeyHandler = null;
      }
      persistRelatedVisibility = false;
      deckHistory = [];
      if (deckDirty && typeof onChange === "function") {
        const result = onChange();
        if (result && typeof result.catch === "function") {
          result.catch(() => {
          });
        }
      }
      deckDirty = false;
      overlayHideTimer = setTimeout(() => {
        if (overlay.dataset.active !== "true") {
          overlay.hidden = true;
        }
        overlayHideTimer = 0;
      }, 320);
    }
    overlay.addEventListener("click", (evt) => {
      if (evt.target === overlay) closeDeck();
    });
    function openDeck(context, targetCardId = null, options = {}) {
      if (overlayHideTimer) {
        clearTimeout(overlayHideTimer);
        overlayHideTimer = 0;
      }
      overlay.hidden = false;
      overlay.inert = false;
      const { pushHistory = true, replaceHistory = false } = options;
      if (pushHistory) {
        if (!overlay.dataset || overlay.dataset.active !== "true" || replaceHistory) {
          deckHistory = [];
        }
        deckHistory.push({ context, targetCardId });
      } else if (!deckHistory.length) {
        deckHistory.push({ context, targetCardId });
      }
      const { block, week, lecture } = context;
      if (activeKeyHandler) {
        document.removeEventListener("keydown", activeKeyHandler);
        activeKeyHandler = null;
      }
      const baseContext = { block, week, lecture };
      const slideCache = /* @__PURE__ */ new WeakMap();
      const handleCardEdited = (item) => {
        deckDirty = true;
        slideCache.delete(item);
        if (lecture.cards[idx] === item) {
          renderCard();
        }
      };
      function prepareSlideActions(slide, item) {
        if (!slide) return;
        const editBtn = slide.querySelector('[data-role="deck-edit"]');
        if (editBtn) {
          editBtn.addEventListener("click", () => {
            openEditor(item.kind, () => handleCardEdited(item), item);
          });
        }
      }
      function acquireSlide(item) {
        if (!slideCache.has(item)) {
          slideCache.set(item, () => createDeckSlide(item, baseContext, { allowEdit: true }));
        }
        const factory = slideCache.get(item);
        const slide = factory();
        slide.classList.add("deck-slide-full");
        prepareSlideActions(slide, item);
        return slide;
      }
      const viewerContent = document.createDocumentFragment();
      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.className = "deck-close";
      closeBtn.innerHTML = '<span aria-hidden="true">\xD7</span><span class="sr-only">Close deck</span>';
      closeBtn.addEventListener("click", closeDeck);
      viewerContent.appendChild(closeBtn);
      const backBtn = document.createElement("button");
      backBtn.type = "button";
      backBtn.className = "deck-back";
      backBtn.innerHTML = '<span aria-hidden="true">\u2190</span><span class="deck-back-label">Back</span><span class="sr-only">Return to previous card</span>';
      backBtn.disabled = deckHistory.length <= 1;
      backBtn.addEventListener("click", () => {
        if (deckHistory.length <= 1) {
          closeDeck();
          return;
        }
        deckHistory.pop();
        const previous = deckHistory[deckHistory.length - 1];
        if (previous) {
          openDeck(previous.context, previous.targetCardId, { pushHistory: false });
        }
      });
      viewerContent.appendChild(backBtn);
      const summary = document.createElement("div");
      summary.className = "deck-card-summary";
      const crumb = document.createElement("span");
      crumb.className = "deck-card-summary-crumb";
      const crumbPieces = [];
      if (block.title) crumbPieces.push(block.title);
      if (week?.label) crumbPieces.push(week.label);
      crumb.textContent = crumbPieces.join(" \u2022 ");
      summary.appendChild(crumb);
      const title = document.createElement("h2");
      title.className = "deck-card-summary-title";
      title.textContent = lecture.title;
      summary.appendChild(title);
      const counter = document.createElement("span");
      counter.className = "deck-card-summary-counter";
      counter.textContent = `Card 1 of ${lecture.cards.length}`;
      summary.appendChild(counter);
      viewerContent.appendChild(summary);
      const stage = document.createElement("div");
      stage.className = "deck-card-stage-full";
      const prev = document.createElement("button");
      prev.type = "button";
      prev.className = "deck-card-nav deck-card-nav-prev";
      prev.innerHTML = '<span class="sr-only">Previous card</span><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 18L8 12L14 6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      const slideHolder = document.createElement("div");
      slideHolder.className = "deck-card-holder";
      const next = document.createElement("button");
      next.type = "button";
      next.className = "deck-card-nav deck-card-nav-next";
      next.innerHTML = '<span class="sr-only">Next card</span><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 6L16 12L10 18" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      stage.appendChild(prev);
      stage.appendChild(slideHolder);
      stage.appendChild(next);
      viewerContent.appendChild(stage);
      const relatedPanel = document.createElement("div");
      relatedPanel.className = "deck-related-panel";
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "deck-related-toggle";
      toggle.dataset.active = "false";
      toggle.textContent = "Show related cards";
      toggle.setAttribute("aria-expanded", "false");
      relatedPanel.appendChild(toggle);
      const relatedWrapId = `deck-related-${Math.random().toString(36).slice(2)}`;
      const relatedWrap = document.createElement("div");
      relatedWrap.className = "deck-related";
      relatedWrap.dataset.visible = "false";
      relatedWrap.id = relatedWrapId;
      relatedWrap.setAttribute("aria-hidden", "true");
      toggle.setAttribute("aria-controls", relatedWrapId);
      relatedPanel.appendChild(relatedWrap);
      viewerContent.appendChild(relatedPanel);
      let idx = 0;
      if (targetCardId != null) {
        const initialIdx = lecture.cards.findIndex((card) => card.id === targetCardId);
        if (initialIdx >= 0) idx = initialIdx;
      }
      let showRelated = persistRelatedVisibility;
      function updateToggle(current, options2 = {}) {
        const { schedule: schedule2 = true } = options2;
        const apply = () => {
          const linkCount = Array.isArray(current?.links) ? current.links.length : 0;
          const hasLinks = linkCount > 0;
          toggle.disabled = !hasLinks;
          toggle.dataset.active = showRelated && hasLinks ? "true" : "false";
          toggle.setAttribute("aria-expanded", showRelated && hasLinks ? "true" : "false");
          toggle.textContent = hasLinks ? `${showRelated ? "Hide" : "Show"} related (${linkCount})` : "No related cards";
        };
        if (schedule2) {
          runMutation(apply);
        } else {
          apply();
        }
      }
      function renderRelated(current, options2 = {}) {
        const { schedule: schedule2 = true } = options2;
        const apply = () => {
          relatedWrap.innerHTML = "";
          if (!showRelated) {
            relatedWrap.dataset.visible = "false";
            relatedWrap.setAttribute("aria-hidden", "true");
            toggle.dataset.active = "false";
            toggle.setAttribute("aria-expanded", "false");
            return;
          }
          const links = Array.isArray(current?.links) ? current.links : [];
          links.forEach((link) => {
            const related = itemLookup.get(link.id);
            if (related) {
              relatedWrap.appendChild(createRelatedCard(related, baseContext));
            }
          });
          const visible = relatedWrap.children.length > 0;
          relatedWrap.dataset.visible = visible ? "true" : "false";
          relatedWrap.setAttribute("aria-hidden", visible ? "false" : "true");
          if (!visible) {
            toggle.dataset.active = "false";
            toggle.setAttribute("aria-expanded", "false");
          }
        };
        if (schedule2) {
          runMutation(apply);
        } else {
          apply();
        }
      }
      function renderCard() {
        const current = lecture.cards[idx];
        const slide = acquireSlide(current);
        const accent = getItemAccent(current);
        const multiple = lecture.cards.length > 1;
        runMutation(() => {
          slideHolder.innerHTML = "";
          slideHolder.appendChild(slide);
          viewer.style.setProperty("--deck-current-accent", accent);
          counter.textContent = `Card ${idx + 1} of ${lecture.cards.length}`;
          prev.disabled = !multiple;
          next.disabled = !multiple;
          updateToggle(current, { schedule: false });
          renderRelated(current, { schedule: false });
        });
      }
      prev.addEventListener("click", () => {
        idx = (idx - 1 + lecture.cards.length) % lecture.cards.length;
        renderCard();
      });
      next.addEventListener("click", () => {
        idx = (idx + 1) % lecture.cards.length;
        renderCard();
      });
      toggle.addEventListener("click", () => {
        if (toggle.disabled) return;
        showRelated = !showRelated;
        persistRelatedVisibility = showRelated;
        updateToggle(lecture.cards[idx], { schedule: false });
        renderRelated(lecture.cards[idx], { schedule: false });
      });
      const keyHandler2 = (event) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          prev.click();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          next.click();
        } else if (event.key === "Escape") {
          event.preventDefault();
          closeDeck();
        }
      };
      document.addEventListener("keydown", keyHandler2);
      activeKeyHandler = keyHandler2;
      renderCard();
      requestAnimationFrame(() => closeBtn.focus());
      document.body.classList.add("is-deck-open");
      overlay.scrollTop = 0;
      runMutation(() => {
        viewer.className = "deck-viewer deck-viewer-card";
        viewer.replaceChildren(viewerContent);
        overlay.dataset.active = "true";
      });
    }
    function createCollapseIcon() {
      const icon = document.createElement("span");
      icon.className = "card-collapse-icon";
      icon.innerHTML = '<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 8L10 12L14 8" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      return icon;
    }
    function createDeckTile(block, week, lecture) {
      const tile = document.createElement("button");
      tile.type = "button";
      tile.className = "deck-tile";
      tile.setAttribute("aria-label", `${lecture.title} (${lecture.cards.length} cards)`);
      const palette2 = lecture.palette || getLecturePalette(lecture.cards);
      lecture.palette = palette2;
      const accent = palette2.accent;
      const stack = document.createElement("div");
      stack.className = "deck-stack";
      stack.style.setProperty("--deck-accent", accent);
      stack.style.setProperty("--deck-gradient", palette2.gradient);
      const preview = lecture.cards.slice(0, 4);
      stack.style.setProperty("--spread", preview.length > 0 ? (preview.length - 1) / 2 : 0);
      if (!preview.length) {
        const placeholder = document.createElement("div");
        placeholder.className = "stack-card stack-card-empty";
        placeholder.style.setProperty("--index", "0");
        placeholder.textContent = "No cards yet";
        stack.appendChild(placeholder);
      } else {
        preview.forEach((card, idx) => {
          const mini = document.createElement("div");
          mini.className = "stack-card";
          mini.style.setProperty("--index", String(idx));
          mini.textContent = titleFromItem(card);
          stack.appendChild(mini);
        });
      }
      tile.style.setProperty("--deck-accent", accent);
      tile.style.setProperty("--deck-gradient", palette2.gradient);
      tile.appendChild(stack);
      const info = document.createElement("div");
      info.className = "deck-info";
      const count = document.createElement("span");
      count.className = "deck-count-pill";
      count.textContent = `${lecture.cards.length} card${lecture.cards.length === 1 ? "" : "s"}`;
      info.appendChild(count);
      const label = document.createElement("h3");
      label.className = "deck-title";
      label.textContent = lecture.title;
      info.appendChild(label);
      const meta = document.createElement("div");
      meta.className = "deck-meta";
      const pieces = [];
      if (block.title) pieces.push(block.title);
      if (week?.label) pieces.push(week.label);
      meta.textContent = pieces.join(" \u2022 ");
      info.appendChild(meta);
      tile.appendChild(info);
      const open = () => openDeck({ block, week, lecture }, null, { replaceHistory: true });
      tile.addEventListener("click", open);
      tile.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          open();
        }
      });
      return tile;
    }
    function createMetaChip(text, icon) {
      const chip = document.createElement("span");
      chip.className = "deck-chip";
      if (icon) {
        const iconEl = document.createElement("span");
        iconEl.className = "deck-chip-icon";
        iconEl.textContent = icon;
        chip.appendChild(iconEl);
      }
      const label = document.createElement("span");
      label.className = "deck-chip-label";
      label.textContent = text;
      chip.appendChild(label);
      return chip;
    }
    function createDeckSlide(item, context, options = {}) {
      const slide = document.createElement("article");
      slide.className = "deck-slide";
      const accent = getItemAccent(item);
      slide.style.setProperty("--slide-accent", accent);
      const heading = document.createElement("header");
      heading.className = "deck-slide-header";
      const crumb = document.createElement("div");
      crumb.className = "deck-slide-crumb";
      const crumbPieces = [];
      if (context.block?.title) crumbPieces.push(context.block.title);
      if (context.week?.label) crumbPieces.push(context.week.label);
      crumb.textContent = crumbPieces.join(" \u2022 ");
      heading.appendChild(crumb);
      if (options.allowEdit) {
        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "deck-slide-edit";
        editBtn.dataset.role = "deck-edit";
        editBtn.innerHTML = '<span class="deck-slide-edit-icon">\u270F\uFE0F</span><span>Edit card</span>';
        heading.appendChild(editBtn);
      }
      const title = document.createElement("h3");
      title.className = "deck-slide-title";
      title.textContent = titleFromItem(item);
      heading.appendChild(title);
      const kind = document.createElement("span");
      kind.className = "deck-slide-kind";
      kind.textContent = item.kind ? item.kind.toUpperCase() : "CARD";
      heading.appendChild(kind);
      slide.appendChild(heading);
      const meta = document.createElement("div");
      meta.className = "deck-slide-meta";
      const seen = /* @__PURE__ */ new Set();
      const addMeta = (text, icon) => {
        if (!text || seen.has(text)) return;
        seen.add(text);
        meta.appendChild(createMetaChip(text, icon));
      };
      if (context.block?.title) addMeta(context.block.title, "\u{1F9ED}");
      if (context.week?.label) addMeta(context.week.label, "\u{1F4C6}");
      (item.blocks || []).forEach((blockId) => {
        const label = blockLookup.get(blockId)?.title || blockId;
        addMeta(label, "\u{1F9F1}");
      });
      (item.weeks || []).forEach((weekValue) => addMeta(`Week ${weekValue}`, "\u{1F4C5}"));
      (item.lectures || []).forEach((lec) => addMeta(lec.name || (lec.id != null ? `Lecture ${lec.id}` : ""), "\u{1F4DA}"));
      if (meta.children.length) slide.appendChild(meta);
      const sections = document.createElement("div");
      sections.className = "deck-slide-sections";
      const buildContentSection = ({ labelText, iconText = "", bodyHtml = "", extra = false }) => {
        const section = document.createElement("section");
        section.className = "deck-section";
        if (extra) section.classList.add("deck-section-extra");
        section.style.setProperty("--section-accent", accent);
        section.classList.add("is-collapsed");
        const headerBtn = document.createElement("button");
        headerBtn.type = "button";
        headerBtn.className = "deck-section-header";
        headerBtn.setAttribute("aria-expanded", "false");
        const titleWrap = document.createElement("div");
        titleWrap.className = "deck-section-title";
        if (iconText) {
          const iconEl = document.createElement("span");
          iconEl.className = "deck-section-icon";
          iconEl.textContent = iconText;
          titleWrap.appendChild(iconEl);
        }
        const labelNode = document.createElement("span");
        labelNode.textContent = labelText;
        titleWrap.appendChild(labelNode);
        headerBtn.appendChild(titleWrap);
        headerBtn.appendChild(createCollapseIcon());
        const bodyWrap = document.createElement("div");
        bodyWrap.className = "deck-section-body";
        const content = document.createElement("div");
        content.className = "deck-section-content";
        renderRichText(content, bodyHtml, { clozeMode: "interactive" });
        bodyWrap.appendChild(content);
        section.appendChild(headerBtn);
        section.appendChild(bodyWrap);
        headerBtn.addEventListener("click", () => {
          runMutation(() => {
            const collapsed = section.classList.toggle("is-collapsed");
            headerBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
          });
        });
        return section;
      };
      const defs = KIND_FIELDS[item.kind] || [];
      defs.forEach(([field, label, icon]) => {
        const value = item[field];
        if (!value) return;
        sections.appendChild(buildContentSection({ labelText: label, iconText: icon, bodyHtml: value }));
      });
      ensureExtras2(item).forEach((extra) => {
        if (!extra?.body) return;
        sections.appendChild(
          buildContentSection({
            labelText: extra.title || "Additional Notes",
            bodyHtml: extra.body,
            extra: true
          })
        );
      });
      if (!sections.children.length) {
        const empty = document.createElement("p");
        empty.className = "deck-section-empty";
        empty.textContent = "No detailed content yet for this card.";
        sections.appendChild(empty);
      }
      slide.appendChild(sections);
      return slide;
    }
    function resolveDeckContext(item, origin) {
      const contexts = deckContextLookup.get(item.id);
      if (!contexts || !contexts.length) return null;
      if (origin?.lecture?.key) {
        const lectureMatch = contexts.find((ctx) => ctx.lecture.key === origin.lecture.key);
        if (lectureMatch) return lectureMatch;
      }
      if (origin?.block?.key) {
        const blockMatch = contexts.find((ctx) => ctx.block.key === origin.block.key);
        if (blockMatch) return blockMatch;
      }
      return contexts[0];
    }
    function createRelatedCard(item, originContext) {
      const entry = document.createElement("button");
      entry.type = "button";
      entry.className = "related-card-chip";
      const accent = getItemAccent(item);
      entry.style.setProperty("--related-accent", accent);
      entry.title = titleFromItem(item);
      const heading = document.createElement("strong");
      heading.className = "related-card-title";
      heading.textContent = titleFromItem(item);
      entry.appendChild(heading);
      const kind = document.createElement("span");
      kind.className = "related-card-kind";
      kind.textContent = item.kind ? item.kind.toUpperCase() : "";
      entry.appendChild(kind);
      const target = resolveDeckContext(item, originContext);
      if (!target) {
        entry.disabled = true;
        entry.classList.add("is-disabled");
      } else {
        entry.addEventListener("click", () => {
          openDeck(target, item.id);
        });
      }
      return entry;
    }
    function buildBlockSection(block) {
      const section = document.createElement("section");
      section.className = "card-block-section";
      const blockKey = block.key;
      const firstLecture = block.weeks.find((week) => week.lectures.length)?.lectures.find((lec) => lec.cards.length);
      const blockAccent = block.accent || getLectureAccent(firstLecture?.cards || []);
      if (blockAccent) section.style.setProperty("--block-accent", blockAccent);
      const header = document.createElement("button");
      header.type = "button";
      header.className = "card-block-header";
      const blockInitiallyCollapsed = collapsedBlockSet.has(blockKey);
      header.setAttribute("aria-expanded", blockInitiallyCollapsed ? "false" : "true");
      const heading = document.createElement("div");
      heading.className = "card-block-heading";
      const swatch = document.createElement("span");
      swatch.className = "card-block-mark";
      heading.appendChild(swatch);
      const title = document.createElement("span");
      title.className = "card-block-title";
      title.textContent = block.title;
      heading.appendChild(title);
      header.appendChild(heading);
      const stats = document.createElement("span");
      stats.className = "card-block-stats";
      stats.textContent = `${block.lectureCount} lecture${block.lectureCount === 1 ? "" : "s"} \u2022 ${block.totalCards} card${block.totalCards === 1 ? "" : "s"}`;
      header.appendChild(stats);
      const icon = createCollapseIcon();
      header.appendChild(icon);
      section.appendChild(header);
      const body = document.createElement("div");
      body.className = "card-block-body";
      section.appendChild(body);
      if (blockInitiallyCollapsed) {
        section.classList.add("is-collapsed");
      }
      const ref = {
        blockKey,
        section,
        header,
        populate: populateBody,
        ensureVisibleWeekGrids,
        weeks: []
      };
      let blockWeekGrids = ref.weeks;
      function populateBody() {
        if (body.dataset.populated === "true") return;
        body.dataset.populated = "true";
        const frag = document.createDocumentFragment();
        const grids = [];
        block.weeks.forEach((week) => {
          const weekSection = document.createElement("div");
          weekSection.className = "card-week-section";
          const weekAccent = getLectureAccent(week.lectures.find((lec) => lec.cards.length)?.cards || []);
          if (weekAccent) weekSection.style.setProperty("--week-accent", weekAccent);
          const weekHeader = document.createElement("button");
          weekHeader.type = "button";
          weekHeader.className = "card-week-header";
          const weekStateKey = `${blockKey}::${week.key}`;
          const weekInitiallyCollapsed = collapsedWeekSet.has(weekStateKey) && hasCollapsedWeekState;
          weekHeader.setAttribute("aria-expanded", weekInitiallyCollapsed ? "false" : "true");
          const weekTitle = document.createElement("span");
          weekTitle.className = "card-week-title";
          weekTitle.textContent = week.label;
          weekHeader.appendChild(weekTitle);
          const weekStats = document.createElement("span");
          weekStats.className = "card-week-stats";
          weekStats.textContent = `${week.lectureCount} lecture${week.lectureCount === 1 ? "" : "s"} \u2022 ${week.totalCards} card${week.totalCards === 1 ? "" : "s"}`;
          weekHeader.appendChild(weekStats);
          weekHeader.appendChild(createCollapseIcon());
          const deckGrid = document.createElement("div");
          deckGrid.className = "deck-grid";
          registerGrid(deckGrid, week.lectures.map((lecture) => ({ block, week, lecture })), {
            deferInitialRender: weekInitiallyCollapsed
          });
          if (weekInitiallyCollapsed) {
            weekSection.classList.add("is-collapsed");
          }
          grids.push({ grid: deckGrid, section: weekSection, header: weekHeader, stateKey: weekStateKey });
          weekSection.appendChild(weekHeader);
          weekSection.appendChild(deckGrid);
          frag.appendChild(weekSection);
          weekHeader.addEventListener("click", () => {
            runMutation(() => {
              const collapsed = weekSection.classList.toggle("is-collapsed");
              weekHeader.setAttribute("aria-expanded", collapsed ? "false" : "true");
              setWeekCollapsedState(weekStateKey, collapsed);
              if (!collapsed) {
                ensureGridRendered(deckGrid);
              }
            }, { immediate: true });
          });
        });
        blockWeekGrids = grids;
        ref.weeks = grids;
        body.appendChild(frag);
      }
      function ensureVisibleWeekGrids() {
        blockWeekGrids.forEach(({ grid, section: weekSection }) => {
          if (!weekSection.classList.contains("is-collapsed")) {
            ensureGridRendered(grid);
          }
        });
      }
      if (!blockInitiallyCollapsed) {
        populateBody();
        requestAnimationFrame(ensureVisibleWeekGrids);
      }
      header.addEventListener("click", () => {
        runMutation(() => {
          const collapsed = section.classList.toggle("is-collapsed");
          header.setAttribute("aria-expanded", collapsed ? "false" : "true");
          setBlockCollapsedState(blockKey, collapsed);
          if (!collapsed) {
            populateBody();
            ensureVisibleWeekGrids();
          }
        }, { immediate: true });
      });
      blockRefs.push(ref);
      return section;
    }
    if (!blockSections.length) {
      const empty = document.createElement("div");
      empty.className = "cards-empty";
      const heading = document.createElement("h3");
      heading.textContent = "No cards match your filters yet";
      empty.appendChild(heading);
      const body = document.createElement("p");
      body.textContent = "Assign lectures, blocks, or create new entries to populate this view.";
      empty.appendChild(body);
      catalog.appendChild(empty);
      return;
    }
    const renderQueue = blockSections.slice();
    function pump() {
      const start = getTime();
      const frag = document.createDocumentFragment();
      let appended = 0;
      let elapsed = 0;
      while (renderQueue.length && elapsed < 12) {
        frag.appendChild(buildBlockSection(renderQueue.shift()));
        appended += 1;
        elapsed = getTime() - start;
      }
      if (appended) {
        catalog.appendChild(frag);
      }
      if (renderQueue.length) {
        requestAnimationFrame(pump);
      }
    }
    pump();
  }
  var UNASSIGNED_BLOCK_KEY, MISC_LECTURE_KEY, deps, KIND_COLORS, KIND_FIELDS, TITLE_CACHE;
  var init_cards = __esm({
    "js/ui/components/cards.js"() {
      init_state();
      init_rich_text();
      init_editor();
      init_block_catalog();
      init_performance();
      init_sections();
      init_utils();
      UNASSIGNED_BLOCK_KEY = "__unassigned__";
      MISC_LECTURE_KEY = "__misc__";
      deps = {
        loadBlockCatalog
      };
      KIND_COLORS = {
        disease: "var(--pink)",
        drug: "var(--blue)",
        concept: "var(--green)"
      };
      KIND_FIELDS = {
        disease: [
          ["etiology", "Etiology", "\u{1F9EC}"],
          ["pathophys", "Pathophys", "\u2699\uFE0F"],
          ["clinical", "Clinical", "\u{1FA7A}"],
          ["diagnosis", "Diagnosis", "\u{1F50E}"],
          ["treatment", "Treatment", "\u{1F48A}"],
          ["complications", "Complications", "\u26A0\uFE0F"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ],
        drug: [
          ["class", "Class", "\u{1F3F7}\uFE0F"],
          ["source", "Source", "\u{1F331}"],
          ["moa", "MOA", "\u2699\uFE0F"],
          ["uses", "Uses", "\u{1F48A}"],
          ["sideEffects", "Side Effects", "\u26A0\uFE0F"],
          ["contraindications", "Contraindications", "\u{1F6AB}"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ],
        concept: [
          ["type", "Type", "\u{1F3F7}\uFE0F"],
          ["definition", "Definition", "\u{1F4D6}"],
          ["mechanism", "Mechanism", "\u2699\uFE0F"],
          ["clinicalRelevance", "Clinical Relevance", "\u{1FA7A}"],
          ["example", "Example", "\u{1F4DD}"],
          ["mnemonic", "Mnemonic", "\u{1F9E0}"]
        ]
      };
      TITLE_CACHE = /* @__PURE__ */ new WeakMap();
    }
  });

  // js/study/study-sessions.js
  function clone4(value) {
    if (value === void 0) return null;
    return deepClone(value);
  }
  function safeClone(value, fallback = null) {
    try {
      const result = clone4(value);
      if (result === null && fallback !== void 0) {
        return clone4(fallback ?? null);
      }
      return result;
    } catch (err) {
      console.warn("Failed to clone study session value", err);
      if (fallback === void 0) return null;
      try {
        return clone4(fallback ?? null);
      } catch (_) {
        if (Array.isArray(fallback)) return [];
        if (fallback && typeof fallback === "object") return {};
        return fallback ?? null;
      }
    }
  }
  function sanitizeRatings(map) {
    if (!map || typeof map !== "object" || Array.isArray(map)) return {};
    const next = {};
    Object.entries(map).forEach(([key, value]) => {
      if (typeof key !== "string") return;
      if (typeof value === "string") {
        next[key] = value;
      }
    });
    return next;
  }
  function sanitizeAnswers(map) {
    if (!map || typeof map !== "object" || Array.isArray(map)) return {};
    const next = {};
    Object.entries(map).forEach(([key, value]) => {
      if (typeof key !== "string" || !value || typeof value !== "object") return;
      const entry = {
        value: typeof value.value === "string" ? value.value : "",
        isCorrect: Boolean(value.isCorrect),
        checked: Boolean(value.checked),
        revealed: Boolean(value.revealed)
      };
      next[key] = entry;
    });
    return next;
  }
  function sanitizePoolEntry(entry) {
    if (entry === null || entry === void 0) return null;
    if (typeof entry !== "object") return entry;
    return safeClone(entry, {});
  }
  function sanitizeSession(mode2, session) {
    const source = safeClone(session, {});
    const next = source && typeof source === "object" ? source : {};
    delete next.dict;
    if (Array.isArray(next.pool)) {
      next.pool = next.pool.map((item) => sanitizePoolEntry(item)).filter((item) => item !== null && item !== void 0);
    } else {
      next.pool = [];
    }
    if (typeof next.idx !== "number" || Number.isNaN(next.idx)) {
      next.idx = 0;
    }
    next.idx = next.pool.length ? Math.max(0, Math.min(Math.floor(next.idx), next.pool.length - 1)) : 0;
    if (next.answers && typeof next.answers === "object" && !Array.isArray(next.answers)) {
      next.answers = sanitizeAnswers(next.answers);
    } else if (next.answers !== void 0) {
      next.answers = {};
    }
    if (next.ratings && typeof next.ratings === "object" && !Array.isArray(next.ratings)) {
      next.ratings = sanitizeRatings(next.ratings);
    } else {
      next.ratings = {};
    }
    if (mode2 === "review") {
      next.mode = "review";
    } else if (typeof next.mode !== "string" || next.mode !== "review") {
      next.mode = "study";
    }
    return next;
  }
  function sanitizeCohort(list) {
    const cloned = safeClone(list, []);
    if (!Array.isArray(cloned)) return [];
    return cloned.map((item) => sanitizePoolEntry(item)).filter((item) => item !== null && item !== void 0);
  }
  function sanitizeMetadata(meta) {
    const cloned = safeClone(meta, {});
    return cloned && typeof cloned === "object" && !Array.isArray(cloned) ? cloned : {};
  }
  async function hydrateStudySessions(force = false) {
    if (!force && state.studySessionsLoaded) {
      return state.studySessions || {};
    }
    if (!pendingLoad) {
      pendingLoad = listStudySessions().then((entries) => {
        const map = {};
        entries.forEach((entry) => {
          if (entry && entry.mode) {
            map[entry.mode] = {
              mode: entry.mode,
              updatedAt: entry.updatedAt || Date.now(),
              session: sanitizeSession(entry.mode, entry.session),
              cohort: sanitizeCohort(entry.cohort),
              metadata: sanitizeMetadata(entry.metadata)
            };
          }
        });
        setStudySessions(map);
        return state.studySessions;
      }).catch((err) => {
        console.error("Failed to load study sessions", err);
        clearStudySessionsState();
        setStudySessions({});
        return state.studySessions;
      }).finally(() => {
        pendingLoad = null;
      });
    }
    return pendingLoad;
  }
  function getStudySessionEntry(mode2) {
    return state.studySessions && state.studySessions[mode2] || null;
  }
  async function persistStudySession(mode2, payload) {
    if (!mode2) throw new Error("Mode is required to save study session");
    const entry = {
      mode: mode2,
      updatedAt: Date.now(),
      session: sanitizeSession(mode2, payload?.session ?? {}),
      cohort: sanitizeCohort(payload?.cohort ?? []),
      metadata: sanitizeMetadata(payload?.metadata ?? {})
    };
    await saveStudySessionRecord(entry);
    setStudySessionEntry(mode2, entry);
    return entry;
  }
  async function removeStudySession(mode2) {
    if (!mode2) return;
    await deleteStudySessionRecord(mode2);
    setStudySessionEntry(mode2, null);
  }
  async function removeAllStudySessions() {
    await clearAllStudySessionRecords();
    setStudySessions({});
  }
  var pendingLoad;
  var init_study_sessions = __esm({
    "js/study/study-sessions.js"() {
      init_state();
      init_storage();
      init_utils();
      pendingLoad = null;
    }
  });

  // js/ui/components/section-utils.js
  function escapeHtml6(str = "") {
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function rawExtras(item) {
    if (Array.isArray(item?.extras) && item.extras.length) {
      return item.extras;
    }
    if (Array.isArray(item?.facts) && item.facts.length) {
      return [{
        id: "legacy-facts",
        title: "Highlights",
        body: `<ul>${item.facts.map((f) => `<li>${escapeHtml6(f)}</li>`).join("")}</ul>`
      }];
    }
    return [];
  }
  function normalizeExtras(item) {
    const extras = rawExtras(item);
    const seenKeys = /* @__PURE__ */ new Set();
    return extras.map((extra, index) => {
      const source = extra && typeof extra === "object" ? extra : {};
      const title = typeof source.title === "string" ? source.title.trim() : "";
      const body = typeof source.body === "string" ? source.body : "";
      let keyId = source.id != null && `${source.id}`.trim() ? `${source.id}`.trim() : `idx-${index}`;
      let key = `${EXTRA_SECTION_PREFIX}${keyId}`;
      let attempt = 0;
      while (seenKeys.has(key)) {
        attempt += 1;
        key = `${EXTRA_SECTION_PREFIX}${keyId}-${attempt}`;
      }
      seenKeys.add(key);
      return {
        key,
        id: source.id ?? null,
        title,
        body,
        index,
        source
      };
    });
  }
  function findExtraByKey(item, key) {
    if (!key || !key.startsWith(EXTRA_SECTION_PREFIX)) return null;
    return normalizeExtras(item).find((entry) => entry.key === key) || null;
  }
  function hasRichContent(value) {
    if (typeof document === "undefined") {
      if (value == null) return false;
      const text = String(value).replace(/<[^>]*>/g, " ").replace(/&nbsp;/g, " ").trim();
      return text.length > 0;
    }
    return hasRichTextContent(value);
  }
  function hasSectionContent(item, key) {
    if (!item || !key) return false;
    if (key.startsWith(EXTRA_SECTION_PREFIX)) {
      const extra = findExtraByKey(item, key);
      return extra ? hasRichContent(extra.body) : false;
    }
    const defs = sectionDefsForKind(item.kind);
    if (!defs.some((def) => def.key === key)) return false;
    const raw = item[key];
    if (raw === null || raw === void 0) return false;
    return hasRichContent(raw);
  }
  function sectionsForItem(item, allowedKeys = null) {
    const defs = sectionDefsForKind(item.kind);
    const allowSet = allowedKeys ? new Set(allowedKeys) : null;
    const sections = defs.filter((def) => (!allowSet || allowSet.has(def.key)) && hasSectionContent(item, def.key)).map((def) => {
      noteSectionUsage(item?.id ?? null, def.key);
      return { key: def.key, label: def.label, content: item?.[def.key] || "" };
    });
    normalizeExtras(item).forEach((extra) => {
      if (!hasRichContent(extra.body)) return;
      noteSectionUsage(item?.id ?? null, extra.key);
      sections.push({
        key: extra.key,
        label: extra.title || "Additional Notes",
        content: extra.body,
        extra: true,
        extraId: extra.id
      });
    });
    return sections;
  }
  function getSectionLabel(item, key) {
    if (key && key.startsWith(EXTRA_SECTION_PREFIX)) {
      const extra = findExtraByKey(item, key);
      return extra ? extra.title || "Additional Notes" : key;
    }
    const defs = sectionDefsForKind(item.kind);
    const def = defs.find((entry) => entry.key === key);
    return def ? def.label : key;
  }
  function getSectionContent(item, key) {
    if (key && key.startsWith(EXTRA_SECTION_PREFIX)) {
      const extra = findExtraByKey(item, key);
      return extra ? extra.body || "" : "";
    }
    return item?.[key] || "";
  }
  var EXTRA_SECTION_PREFIX;
  var init_section_utils = __esm({
    "js/ui/components/section-utils.js"() {
      init_sections();
      init_rich_text();
      EXTRA_SECTION_PREFIX = "extra:";
    }
  });

  // js/review/scheduler.js
  function digestContent(value) {
    if (value == null) return null;
    const str = typeof value === "string" ? value : JSON.stringify(value);
    if (!str) return null;
    let hash = 0;
    for (let i = 0; i < str.length; i += 1) {
      hash = hash * 31 + str.charCodeAt(i) >>> 0;
    }
    return hash.toString(16);
  }
  function normalizeLectureScope(scope) {
    if (!Array.isArray(scope) || !scope.length) return [];
    const normalized2 = scope.map((entry) => typeof entry === "string" ? entry.trim() : "").filter(Boolean);
    return Array.from(new Set(normalized2)).sort();
  }
  function computeLectureScope(item) {
    if (!item || !Array.isArray(item.lectures) || !item.lectures.length) {
      return [UNASSIGNED_LECTURE_TOKEN];
    }
    const tokens = item.lectures.map((lecture) => {
      if (!lecture || typeof lecture !== "object") return "";
      const blockId = lecture.blockId == null ? "" : String(lecture.blockId);
      const id = lecture.id == null ? "" : String(lecture.id);
      return `${blockId}|${id}`.trim();
    });
    return normalizeLectureScope(tokens);
  }
  function computeSectionDigest(item, key) {
    if (!item || !key) return null;
    const raw = getSectionContent(item, key);
    return digestContent(raw);
  }
  async function getReviewDurations() {
    if (cachedDurations) return cachedDurations;
    try {
      const settings = await getSettings();
      cachedDurations = normalizeReviewSteps(settings?.reviewSteps);
    } catch (err) {
      console.warn("Failed to load review settings, using defaults", err);
      cachedDurations = { ...DEFAULT_REVIEW_STEPS };
    }
    return cachedDurations;
  }
  function ensureItemSr(item) {
    if (!item || typeof item !== "object") return { version: SR_VERSION, sections: {} };
    const sr = item.sr && typeof item.sr === "object" ? item.sr : { version: SR_VERSION, sections: {} };
    if (sr.version !== SR_VERSION || typeof sr.sections !== "object" || !sr.sections) {
      item.sr = normalizeSrRecord(sr);
      return item.sr;
    }
    item.sr.sections = item.sr.sections || {};
    return item.sr;
  }
  function ensureSectionState(item, key) {
    const sr = ensureItemSr(item);
    if (!sr.sections[key] || typeof sr.sections[key] !== "object") {
      sr.sections[key] = defaultSectionState();
    } else {
      sr.sections[key] = normalizeSectionRecord(sr.sections[key]);
    }
    return sr.sections[key];
  }
  function getSectionStateSnapshot(item, key) {
    const sr = item?.sr;
    if (!sr || typeof sr !== "object") return null;
    const entry = sr.sections && typeof sr.sections === "object" ? sr.sections[key] : null;
    if (!entry || typeof entry !== "object") return null;
    const normalized2 = normalizeSectionRecord(entry);
    const digest = computeSectionDigest(item, key);
    const scope = computeLectureScope(item);
    const storedDigest = normalized2.contentDigest;
    const storedScope = normalizeLectureScope(normalized2.lectureScope);
    const removedLectures = storedScope.length ? storedScope.some((token) => !scope.includes(token)) : false;
    const contentChanged = storedDigest != null && digest != null && storedDigest !== digest;
    if (contentChanged || removedLectures) {
      const nowTs = Date.now();
      normalized2.streak = 0;
      normalized2.lastRating = null;
      normalized2.last = nowTs;
      normalized2.due = nowTs;
      normalized2.retired = false;
      normalized2.suspended = false;
      normalized2.phase = "new";
      normalized2.learningStepIndex = 0;
      normalized2.interval = 0;
      normalized2.pendingInterval = 0;
      normalized2.ease = DEFAULT_REVIEW_STEPS.startingEase;
      normalized2.lapses = 0;
    }
    normalized2.contentDigest = digest;
    normalized2.lectureScope = scope;
    sr.sections[key] = normalized2;
    return normalized2;
  }
  function asMinutes(value, fallback) {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return fallback;
    return Math.max(1, Math.round(num));
  }
  function normalizeStepList(list, fallback) {
    if (Array.isArray(list) && list.length) {
      const parsed = list.map((value) => asMinutes(value, 0)).filter((value) => value > 0);
      if (parsed.length) return parsed;
    }
    return fallback;
  }
  function ensurePhase(section) {
    if (!section.phase) {
      section.phase = section.interval > 0 ? "review" : "new";
    }
    if (section.phase === "suspended") {
      section.phase = section.interval > 0 ? "review" : "learning";
    }
    return section.phase;
  }
  function minutesToMs(minutes) {
    return Math.max(0, Math.round(minutes * 60 * 1e3));
  }
  function scheduleDue(section, minutes, now) {
    const clamped = Math.max(1, Math.round(minutes));
    section.due = now + minutesToMs(clamped);
    return clamped;
  }
  function applyRatingState(section, rating, config, now) {
    if (rating === RETIRE_RATING) {
      section.streak = 0;
      section.lastRating = RETIRE_RATING;
      section.last = now;
      section.interval = Number.MAX_SAFE_INTEGER;
      section.pendingInterval = 0;
      section.phase = "review";
      section.due = Number.MAX_SAFE_INTEGER;
      section.retired = true;
      section.suspended = false;
      return section;
    }
    const normalizedRating = REVIEW_RATINGS.includes(rating) ? rating : "good";
    const baseAgain = asMinutes(config.again ?? DEFAULT_REVIEW_STEPS.again, DEFAULT_REVIEW_STEPS.again);
    const baseHard = asMinutes(config.hard ?? DEFAULT_REVIEW_STEPS.hard, baseAgain);
    const baseGood = asMinutes(config.good ?? DEFAULT_REVIEW_STEPS.good, baseHard);
    const baseEasy = asMinutes(config.easy ?? DEFAULT_REVIEW_STEPS.easy, baseGood);
    const learningSteps = normalizeStepList(config.learningSteps, [baseAgain]);
    const relearningSteps = normalizeStepList(config.relearningSteps, [baseAgain]);
    const intervalModifier = Number.isFinite(config.intervalModifier) && config.intervalModifier > 0 ? config.intervalModifier : 1;
    const lapseIntervalMultiplier = Number.isFinite(config.lapseIntervalMultiplier) && config.lapseIntervalMultiplier > 0 ? config.lapseIntervalMultiplier : 0.5;
    const easyIntervalBonus = Number.isFinite(config.easyIntervalBonus) && config.easyIntervalBonus > 0 ? config.easyIntervalBonus : 1.5;
    const hardIntervalMultiplier = Number.isFinite(config.hardIntervalMultiplier) && config.hardIntervalMultiplier > 0 ? config.hardIntervalMultiplier : 1.2;
    const startingEase = Number.isFinite(config.startingEase) && config.startingEase > 0 ? config.startingEase : DEFAULT_REVIEW_STEPS.startingEase;
    const minimumEase = Number.isFinite(config.minimumEase) && config.minimumEase > 0 ? config.minimumEase : DEFAULT_REVIEW_STEPS.minimumEase;
    const easeBonus = Number.isFinite(config.easeBonus) ? config.easeBonus : DEFAULT_REVIEW_STEPS.easeBonus;
    const easePenalty = Number.isFinite(config.easePenalty) ? config.easePenalty : DEFAULT_REVIEW_STEPS.easePenalty;
    const hardEasePenalty = Number.isFinite(config.hardEasePenalty) ? config.hardEasePenalty : DEFAULT_REVIEW_STEPS.hardEasePenalty;
    ensurePhase(section);
    section.suspended = false;
    if (!Number.isFinite(section.ease) || section.ease <= 0) {
      section.ease = startingEase;
    }
    section.ease = Math.max(minimumEase, section.ease);
    section.retired = false;
    const applyReviewInterval = (minutes, { easeDelta = 0 } = {}) => {
      const finalMinutes = scheduleDue(section, minutes, now);
      section.interval = finalMinutes;
      section.pendingInterval = 0;
      section.learningStepIndex = 0;
      section.phase = "review";
      section.ease = Math.max(minimumEase, section.ease + easeDelta);
      section.streak = Math.max(1, (section.streak || 0) + 1);
    };
    const scheduleLearning = (minutes, nextIndex = 0) => {
      section.phase = "learning";
      section.learningStepIndex = nextIndex;
      section.streak = 0;
      scheduleDue(section, minutes, now);
    };
    const scheduleRelearning = (minutes, nextIndex = 0) => {
      section.phase = "relearning";
      section.learningStepIndex = nextIndex;
      section.streak = 0;
      scheduleDue(section, minutes, now);
    };
    const currentInterval = section.interval && Number.isFinite(section.interval) ? Math.max(1, Math.round(section.interval)) : 0;
    if (section.phase === "new" || section.phase === "learning") {
      const index = Math.max(0, section.learningStepIndex || 0);
      if (normalizedRating === "again") {
        scheduleLearning(learningSteps[0] ?? baseAgain, 0);
      } else if (normalizedRating === "hard") {
        const step = learningSteps[Math.min(index, learningSteps.length - 1)] ?? baseHard;
        const extended = Math.max(step, Math.round(step * hardIntervalMultiplier));
        scheduleLearning(extended, index);
      } else if (normalizedRating === "good") {
        const nextIndex = index + 1;
        if (nextIndex < learningSteps.length) {
          scheduleLearning(learningSteps[nextIndex] ?? baseGood, nextIndex);
        } else {
          const graduateInterval = asMinutes(config.graduatingGood ?? baseGood, baseGood) * intervalModifier;
          section.ease = Math.max(minimumEase, startingEase);
          applyReviewInterval(graduateInterval);
        }
      } else if (normalizedRating === "easy") {
        const graduateInterval = asMinutes(config.graduatingEasy ?? baseEasy, baseEasy) * intervalModifier;
        section.ease = Math.max(minimumEase, startingEase + easeBonus);
        applyReviewInterval(graduateInterval);
      }
    } else if (section.phase === "relearning") {
      const index = Math.max(0, section.learningStepIndex || 0);
      if (normalizedRating === "again") {
        scheduleRelearning(relearningSteps[0] ?? baseAgain, 0);
      } else if (normalizedRating === "hard") {
        const step = relearningSteps[Math.min(index, relearningSteps.length - 1)] ?? baseHard;
        const extended = Math.max(step, Math.round(step * hardIntervalMultiplier));
        scheduleRelearning(extended, index);
      } else {
        const nextIndex = index + 1;
        if (nextIndex < relearningSteps.length && normalizedRating !== "easy") {
          scheduleRelearning(relearningSteps[nextIndex] ?? baseGood, nextIndex);
        } else {
          const pending2 = section.pendingInterval && section.pendingInterval > 0 ? section.pendingInterval : Math.max(1, Math.round((currentInterval || baseGood) * lapseIntervalMultiplier));
          const intervalBase = normalizedRating === "easy" ? Math.max(pending2, Math.round(pending2 * easyIntervalBonus)) : pending2;
          const finalInterval = Math.max(1, Math.round(intervalBase * intervalModifier));
          const easeDelta = normalizedRating === "easy" ? easeBonus : 0;
          section.ease = Math.max(minimumEase, section.ease + easeDelta);
          applyReviewInterval(finalInterval, { easeDelta: 0 });
          section.pendingInterval = 0;
        }
      }
    } else {
      if (normalizedRating === "again") {
        section.ease = Math.max(minimumEase, section.ease - easePenalty);
        section.lapses = Math.max(0, (section.lapses || 0) + 1);
        section.interval = 0;
        section.pendingInterval = 0;
        scheduleLearning(learningSteps[0] ?? baseAgain, 0);
      } else if (normalizedRating === "hard") {
        section.ease = Math.max(minimumEase, section.ease - hardEasePenalty);
        section.interval = 0;
        section.pendingInterval = 0;
        const hardIndex = learningSteps.length > 1 ? 1 : 0;
        const hardStep = learningSteps[Math.min(hardIndex, learningSteps.length - 1)] ?? baseHard;
        scheduleLearning(hardStep, Math.min(hardIndex, learningSteps.length - 1));
      } else if (normalizedRating === "good") {
        const base = currentInterval || baseGood;
        const rawInterval = Math.max(base, Math.round(base * section.ease));
        const nextInterval = Math.max(1, Math.round(rawInterval * intervalModifier));
        applyReviewInterval(nextInterval);
      } else if (normalizedRating === "easy") {
        const base = currentInterval || baseEasy;
        section.ease = Math.max(minimumEase, section.ease + easeBonus);
        const rawInterval = Math.max(base, Math.round(base * section.ease * easyIntervalBonus));
        const nextInterval = Math.max(1, Math.round(rawInterval * intervalModifier));
        applyReviewInterval(nextInterval);
      }
    }
    section.lastRating = normalizedRating;
    section.last = now;
    return section;
  }
  function rateSection(item, key, rating, durations, now = Date.now()) {
    if (!item || !key) return null;
    const config = normalizeReviewSteps(durations);
    const section = ensureSectionState(item, key);
    section.contentDigest = computeSectionDigest(item, key);
    section.lectureScope = computeLectureScope(item);
    applyRatingState(section, rating, config, now);
    return section;
  }
  function projectSectionRating(item, key, rating, durations, now = Date.now()) {
    if (!item || !key) return null;
    const snapshot = getSectionStateSnapshot(item, key);
    if (!snapshot) return null;
    const config = normalizeReviewSteps(durations);
    const copy = JSON.parse(JSON.stringify(snapshot));
    applyRatingState(copy, rating, config, now);
    return copy;
  }
  function suspendSection(item, key, now = Date.now()) {
    if (!item || !key) return null;
    const section = ensureSectionState(item, key);
    section.suspended = true;
    section.last = now;
    section.phase = "suspended";
    section.due = Number.MAX_SAFE_INTEGER;
    return section;
  }
  function classifySectionCategory(snapshot) {
    if (!snapshot || typeof snapshot !== "object") return "new";
    const lastRating = typeof snapshot.lastRating === "string" ? snapshot.lastRating : null;
    const phase = snapshot.phase;
    if (phase === "review") return "review";
    if (phase === "relearning") return "learning";
    if (phase === "learning") {
      if (!lastRating || lastRating === "again") return "new";
      return "learning";
    }
    if (lastRating === "again") return "new";
    if (lastRating === "easy" || lastRating === "good" || lastRating === "hard") return "learning";
    return "new";
  }
  function collectReviewEntries(items, { now = Date.now(), predicate } = {}) {
    const results = [];
    if (!Array.isArray(items) || !items.length) return results;
    for (const item of items) {
      const sections = sectionsForItem(item);
      for (const section of sections) {
        const snapshot = getSectionStateSnapshot(item, section.key);
        if (!snapshot || snapshot.retired || snapshot.suspended) continue;
        if (typeof predicate === "function" && !predicate(snapshot, now, item, section)) continue;
        const category = classifySectionCategory(snapshot);
        results.push({
          item,
          itemId: item.id,
          sectionKey: section.key,
          sectionLabel: section.label,
          due: snapshot.due,
          phase: snapshot.phase,
          state: snapshot,
          category
        });
      }
    }
    results.sort((a, b) => a.due - b.due);
    return results;
  }
  function collectDueSections(items, { now = Date.now() } = {}) {
    return collectReviewEntries(items, {
      now,
      predicate: (snapshot, currentNow) => Boolean(snapshot.last) && snapshot.due <= currentNow
    });
  }
  var UNASSIGNED_LECTURE_TOKEN, cachedDurations;
  var init_scheduler2 = __esm({
    "js/review/scheduler.js"() {
      init_storage();
      init_section_utils();
      init_constants();
      init_settings();
      init_sr_data();
      UNASSIGNED_LECTURE_TOKEN = "__unassigned|__none";
      cachedDurations = null;
    }
  });

  // js/review/pool.js
  async function loadReviewSourceItems() {
    const existingCohort = Array.isArray(state.cohort) && state.cohort.length ? state.cohort : null;
    if (existingCohort) {
      return existingCohort;
    }
    const kinds = Array.isArray(state.builder?.types) && state.builder.types.length ? state.builder.types : DEFAULT_KINDS2;
    const seenIds = /* @__PURE__ */ new Set();
    const items = [];
    for (const kind of kinds) {
      try {
        const entries = await listItemsByKind(kind);
        if (!Array.isArray(entries)) continue;
        for (const item of entries) {
          if (!item) continue;
          const id = item.id || `${kind}::${items.length}`;
          if (seenIds.has(id)) continue;
          seenIds.add(id);
          items.push(item);
        }
      } catch (err) {
        console.warn("Failed to load review items for kind", kind, err);
      }
    }
    return items;
  }
  var DEFAULT_KINDS2;
  var init_pool = __esm({
    "js/review/pool.js"() {
      init_state();
      init_storage();
      DEFAULT_KINDS2 = ["disease", "drug", "concept"];
    }
  });

  // js/ui/components/builder.js
  var builder_exports = {};
  __export(builder_exports, {
    renderBuilder: () => renderBuilder
  });
  function snapshotSelection() {
    const types = Array.isArray(state.builder.types) ? [...state.builder.types] : [];
    const blocks = Array.isArray(state.builder.blocks) ? [...state.builder.blocks] : [];
    const lectures = Array.isArray(state.builder.lectures) ? [...state.builder.lectures] : [];
    return {
      types,
      blocks,
      lectures,
      onlyFav: Boolean(state.builder.onlyFav)
    };
  }
  function selectionSignature(selection) {
    if (!selection || typeof selection !== "object") return "";
    const types = Array.isArray(selection.types) ? [...selection.types].sort() : [];
    const blocks = Array.isArray(selection.blocks) ? [...selection.blocks].sort() : [];
    const lectures = Array.isArray(selection.lectures) ? [...selection.lectures].sort() : [];
    const onlyFav = selection.onlyFav ? 1 : 0;
    return JSON.stringify({ types, blocks, lectures, onlyFav });
  }
  function ensureCohortSync({ force = false } = {}) {
    const selection = snapshotSelection();
    const signature = selectionSignature(selection);
    if (!force && signature === lastAppliedSelectionSignature && Array.isArray(state.cohort)) {
      return Promise.resolve(state.cohort);
    }
    if (pendingCohortUpdate && pendingCohortUpdate.signature === signature) {
      return pendingCohortUpdate.promise;
    }
    const promise = gatherItems(selection).then((items) => {
      const currentSignature = selectionSignature(snapshotSelection());
      if (currentSignature !== signature) {
        return ensureCohortSync({ force: true });
      }
      setCohort(items);
      resetBlockMode();
      lastAppliedSelectionSignature = signature;
      return items;
    }).catch((err) => {
      console.warn("Failed to assemble study cohort", err);
      throw err;
    }).finally(() => {
      if (pendingCohortUpdate && pendingCohortUpdate.signature === signature) {
        pendingCohortUpdate = null;
      }
    });
    pendingCohortUpdate = { promise, signature };
    return promise;
  }
  function setLectureSource(map) {
    lectureSource = {};
    for (const [blockId, list] of Object.entries(map || {})) {
      lectureSource[blockId] = Array.isArray(list) ? list.map((lecture) => ({ ...lecture })) : [];
    }
  }
  function lectureListFor(blockId, options = {}) {
    const list = lectureSource[blockId];
    if (!Array.isArray(list)) return [];
    if (options.clone === false) return list;
    return list.map((lecture) => ({ ...lecture }));
  }
  function collectReviewCount(items) {
    try {
      return collectDueSections(items, { now: Date.now() }).length;
    } catch (err) {
      console.warn("Failed to calculate review queue size", err);
      return 0;
    }
  }
  function notifyBuilderChanged({ selectionChanged = false } = {}) {
    removeAllStudySessions().catch((err) => console.warn("Failed to clear saved sessions", err));
    if (selectionChanged) {
      Promise.resolve().then(() => ensureCohortSync({ force: true })).catch((err) => console.warn("Failed to refresh study selection", err));
    }
  }
  async function renderBuilder(root2, redraw) {
    const [blocks] = await Promise.all([
      loadBlocks(),
      hydrateStudySessions().catch((err) => {
        console.error("Unable to load study sessions", err);
        return null;
      })
    ]);
    root2.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.className = "builder";
    root2.appendChild(wrap);
    drawBuilder(wrap, blocks, redraw);
  }
  async function loadBlocks() {
    const catalog = await loadBlockCatalog();
    const lectureLists = { ...catalog.lectureLists };
    catalog.blocks.forEach((block) => {
      if (!Array.isArray(lectureLists[block.blockId])) {
        lectureLists[block.blockId] = [];
      }
    });
    lectureLists.__unlabeled = [];
    setLectureSource(lectureLists);
    const blocks = catalog.blocks.map((block) => ({ ...block }));
    blocks.push({ blockId: "__unlabeled", title: "Unlabeled", weeks: 0 });
    return blocks;
  }
  function drawBuilder(container, blocks, redraw) {
    container.innerHTML = "";
    if (state.builder.weeks.length) {
      setBuilder({ weeks: [] });
    }
    const rerender = () => drawBuilder(container, blocks, redraw);
    const contexts = blocks.map((block) => {
      const blockId = block.blockId;
      const lectures = lectureListFor(blockId);
      lectures.sort((a, b) => {
        const weekDiff = (a.week ?? 0) - (b.week ?? 0);
        if (weekDiff !== 0) return weekDiff;
        return (a.name || "").localeCompare(b.name || "");
      });
      const weeks = groupByWeek(lectures);
      return { block, lectures, weeks };
    });
    builderBlockOrder = contexts.map((ctx) => ctx.block.blockId);
    builderWeekMap = /* @__PURE__ */ new Map();
    contexts.forEach((ctx) => {
      const blockId = ctx.block.blockId;
      const entries = ctx.weeks.map(({ week }) => ({
        key: weekKeyFor(blockId, week),
        week
      }));
      builderWeekMap.set(blockId, entries);
    });
    const activeBlockId = ensureActiveBlock(contexts);
    ensureWeekForBlock(activeBlockId);
    const layout = document.createElement("div");
    layout.className = "builder-layout";
    container.appendChild(layout);
    const blockColumn = document.createElement("div");
    blockColumn.className = "builder-blocks";
    layout.appendChild(blockColumn);
    contexts.forEach((context) => {
      blockColumn.appendChild(renderBlockPanel(context, rerender));
    });
    const controls = renderControls(rerender, redraw);
    layout.appendChild(controls);
  }
  function ensureActiveBlock(contexts) {
    if (!Array.isArray(contexts) || !contexts.length) {
      if (state.builder.activeBlockId || state.builder.collapsedBlocks && state.builder.collapsedBlocks.length || state.builder.activeWeekKey || state.builder.collapsedWeeks && state.builder.collapsedWeeks.length) {
        setBuilder({ activeBlockId: "", collapsedBlocks: [], activeWeekKey: "", collapsedWeeks: [] });
      }
      return "";
    }
    const blockIds = builderBlockOrder;
    let activeBlockId = state.builder.activeBlockId;
    if (!activeBlockId || !blockIds.includes(activeBlockId)) {
      activeBlockId = chooseDefaultBlock(contexts);
    }
    if (!activeBlockId && blockIds.length) {
      activeBlockId = blockIds[0];
    }
    setActiveBlock(activeBlockId);
    return activeBlockId;
  }
  function chooseDefaultBlock(contexts) {
    const lectureSelections = Array.isArray(state.builder.lectures) ? state.builder.lectures : [];
    if (lectureSelections.length) {
      const last = lectureSelections[lectureSelections.length - 1];
      const [blockId] = last.split("|");
      if (blockId && builderBlockOrder.includes(blockId)) return blockId;
    }
    const selectedBlocks = Array.isArray(state.builder.blocks) ? state.builder.blocks : [];
    const blockMatch = selectedBlocks.find((id) => builderBlockOrder.includes(id));
    if (blockMatch) return blockMatch;
    const latestBlockId = resolveLatestBlockId(contexts.map((ctx) => ctx.block));
    if (latestBlockId && builderBlockOrder.includes(latestBlockId)) return latestBlockId;
    const withLectures = contexts.find((ctx) => ctx.block.blockId !== "__unlabeled" && ctx.lectures.length);
    if (withLectures) return withLectures.block.blockId;
    return contexts[0]?.block.blockId || "";
  }
  function ensureWeekForBlock(blockId) {
    if (!blockId) {
      return;
    }
    const entries = builderWeekMap.get(blockId) || [];
    if (!entries.length) {
      clearActiveWeek(blockId);
      return;
    }
    const currentKey = state.builder.activeWeekKey;
    if (currentKey && currentKey.startsWith(`${blockId}|`)) {
      const hasCurrent = entries.some((entry) => entry.key === currentKey);
      if (hasCurrent) {
        applyWeekSelection(blockId, currentKey, entries);
        return;
      }
    }
    applyWeekSelection(blockId, entries[0].key, entries);
  }
  function setActiveBlock(blockId) {
    if (!blockId || !builderBlockOrder.includes(blockId)) return;
    const collapsed = builderBlockOrder.filter((id) => id !== blockId);
    const patch = {};
    if (!arraysEqual(collapsed, state.builder.collapsedBlocks || [])) {
      patch.collapsedBlocks = collapsed;
    }
    if (state.builder.activeBlockId !== blockId) {
      patch.activeBlockId = blockId;
    }
    if (patch.activeBlockId && state.builder.activeWeekKey && !state.builder.activeWeekKey.startsWith(`${blockId}|`)) {
      patch.activeWeekKey = "";
    }
    if (Object.keys(patch).length) {
      setBuilder(patch);
    }
  }
  function setActiveWeek(blockId, week) {
    if (!blockId) return;
    const entries = builderWeekMap.get(blockId) || [];
    if (!entries.length) {
      clearActiveWeek(blockId);
      return;
    }
    const normalizedWeek = week != null ? week : -1;
    const target = entries.find((entry) => entry.week === normalizedWeek) || entries[0];
    applyWeekSelection(blockId, target.key, entries);
  }
  function applyWeekSelection(blockId, key, entries) {
    if (!key || !Array.isArray(entries)) return;
    const collapsed = new Set(state.builder.collapsedWeeks || []);
    const validKeys = entries.map((entry) => entry.key);
    for (const value of Array.from(collapsed)) {
      if (value.startsWith(`${blockId}|`) && !validKeys.includes(value) && value !== key) {
        collapsed.delete(value);
      }
    }
    entries.forEach((entry) => {
      if (entry.key === key) {
        collapsed.delete(entry.key);
      } else {
        collapsed.add(entry.key);
      }
    });
    const patch = {};
    const collapsedArr = Array.from(collapsed);
    if (!arraysEqual(collapsedArr, state.builder.collapsedWeeks || [])) {
      patch.collapsedWeeks = collapsedArr;
    }
    if (state.builder.activeWeekKey !== key) {
      patch.activeWeekKey = key;
    }
    if (Object.keys(patch).length) {
      setBuilder(patch);
    }
  }
  function clearActiveWeek(blockId) {
    if (!blockId) return;
    const prefix = `${blockId}|`;
    const nextCollapsed = (state.builder.collapsedWeeks || []).filter((key) => !key.startsWith(prefix));
    const patch = {};
    if (!arraysEqual(nextCollapsed, state.builder.collapsedWeeks || [])) {
      patch.collapsedWeeks = nextCollapsed;
    }
    if (state.builder.activeWeekKey && state.builder.activeWeekKey.startsWith(prefix)) {
      patch.activeWeekKey = "";
    }
    if (Object.keys(patch).length) {
      setBuilder(patch);
    }
  }
  function findNextBlock(currentId) {
    if (!builderBlockOrder.length) return null;
    const index = builderBlockOrder.indexOf(currentId);
    if (index === -1) return builderBlockOrder[0] || null;
    for (let offset = 1; offset < builderBlockOrder.length; offset += 1) {
      const candidate = builderBlockOrder[(index + offset) % builderBlockOrder.length];
      if (candidate) return candidate;
    }
    return currentId || null;
  }
  function arraysEqual(a = [], b = []) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i += 1) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  function renderBlockPanel(context, rerender) {
    const { block, lectures, weeks } = context;
    const blockId = block.blockId;
    const hasLectureSelection = hasAnyLectureSelected(blockId, lectures);
    const blockFullySelected = isBlockFullySelected(block, lectures);
    const blockCollapsed = isBlockCollapsed(blockId);
    const card = document.createElement("div");
    card.className = "card builder-block-card";
    if (blockFullySelected) card.classList.add("active");
    if (blockCollapsed) card.classList.add("is-collapsed");
    const header = document.createElement("div");
    header.className = "builder-block-header";
    const blockCollapseBtn = createCollapseToggle({
      collapsed: blockCollapsed,
      label: blockCollapsed ? "Show weeks" : "Hide weeks",
      onToggle: () => {
        toggleBlockCollapsed(blockId);
        rerender();
      },
      variant: "block"
    });
    header.appendChild(blockCollapseBtn);
    const title = document.createElement("h3");
    title.textContent = block.title || blockId;
    header.appendChild(title);
    const meta = document.createElement("span");
    meta.className = "builder-block-meta";
    const weekCount = weeks.length;
    const lectureCount = lectures.length;
    const metaParts = [];
    if (weekCount) metaParts.push(`${weekCount} week${weekCount === 1 ? "" : "s"}`);
    if (lectureCount) metaParts.push(`${lectureCount} lecture${lectureCount === 1 ? "" : "s"}`);
    meta.textContent = metaParts.join(" \u2022 ") || "No lectures linked yet";
    header.appendChild(meta);
    const actions = document.createElement("div");
    actions.className = "builder-block-actions";
    if (lectures.length || blockId === "__unlabeled") {
      const label = blockId === "__unlabeled" ? "Include unlabeled cards" : "Select all lectures";
      const allBtn = createAction(label, () => {
        selectEntireBlock(block);
        rerender();
      });
      if (lectures.length && areAllLecturesSelected(blockId, lectures)) {
        allBtn.disabled = true;
      }
      actions.appendChild(allBtn);
    }
    if (hasLectureSelection || blockFullySelected) {
      const clearBtn = createAction("Clear block", () => {
        clearBlock(blockId);
        rerender();
      }, "danger");
      actions.appendChild(clearBtn);
    }
    header.appendChild(actions);
    card.appendChild(header);
    if (blockId === "__unlabeled") {
      const note = document.createElement("div");
      note.className = "builder-unlabeled-note";
      note.textContent = "Include to study cards without block or lecture tags.";
      card.appendChild(note);
      return card;
    }
    const weekList = document.createElement("div");
    weekList.className = "builder-week-list";
    weekList.hidden = blockCollapsed;
    if (!weeks.length) {
      const empty = document.createElement("div");
      empty.className = "builder-empty";
      empty.textContent = "No lectures added yet.";
      weekList.appendChild(empty);
    } else {
      weeks.forEach(({ week, items }) => {
        weekList.appendChild(renderWeek(block, week, items, rerender));
      });
    }
    card.appendChild(weekList);
    return card;
  }
  function renderWeek(block, week, lectures, rerender) {
    const blockId = block.blockId;
    const weekCollapsed = isWeekCollapsed(blockId, week);
    const row = document.createElement("div");
    row.className = "builder-week-card";
    if (hasAnyLectureSelected(blockId, lectures)) row.classList.add("is-active");
    if (weekCollapsed) row.classList.add("is-collapsed");
    const header = document.createElement("div");
    header.className = "builder-week-header";
    const weekCollapseBtn = createCollapseToggle({
      collapsed: weekCollapsed,
      label: weekCollapsed ? "Show lectures" : "Hide lectures",
      onToggle: () => {
        toggleWeekCollapsed(blockId, week);
        rerender();
      }
    });
    header.appendChild(weekCollapseBtn);
    const label = document.createElement("span");
    label.className = "builder-week-title";
    label.textContent = formatWeekLabel2(week);
    header.appendChild(label);
    const meta = document.createElement("span");
    meta.className = "builder-week-meta";
    meta.textContent = `${lectures.length} lecture${lectures.length === 1 ? "" : "s"}`;
    header.appendChild(meta);
    const actions = document.createElement("div");
    actions.className = "builder-week-actions";
    const allBtn = createAction("Select all", () => {
      selectWeek(block, week);
      rerender();
    });
    const clearBtn = createAction("Clear", () => {
      clearWeek(block, week);
      rerender();
    }, "danger");
    if (areAllLecturesSelected(blockId, lectures)) {
      allBtn.disabled = true;
    }
    if (!hasAnyLectureSelected(blockId, lectures)) {
      clearBtn.disabled = true;
    }
    actions.appendChild(allBtn);
    actions.appendChild(clearBtn);
    header.appendChild(actions);
    row.appendChild(header);
    const lectureList = document.createElement("div");
    lectureList.className = "builder-lecture-list";
    lectureList.hidden = weekCollapsed;
    lectures.forEach((lecture) => {
      lectureList.appendChild(renderLecture(block, lecture, rerender));
    });
    row.appendChild(lectureList);
    return row;
  }
  function renderLecture(block, lecture, rerender) {
    const blockId = block.blockId;
    const lectureKey2 = lectureKeyFor(blockId, lecture.id);
    const active = state.builder.lectures.includes(lectureKey2);
    const pill = createPill(active, lecture.name || `Lecture ${lecture.id}`, () => {
      toggleLecture(block, lecture);
      rerender();
    }, "lecture");
    return pill;
  }
  function renderControls(rerender, redraw) {
    const aside = document.createElement("aside");
    aside.className = "builder-controls";
    aside.appendChild(renderFilterCard(rerender));
    aside.appendChild(renderModeCard(rerender, redraw));
    aside.appendChild(renderReviewCard(redraw));
    return aside;
  }
  function renderFilterCard(rerender) {
    const card = document.createElement("div");
    card.className = "card builder-filter-card";
    const title = document.createElement("h3");
    title.textContent = "Filters";
    card.appendChild(title);
    const typeLabel = document.createElement("div");
    typeLabel.className = "builder-section-title";
    typeLabel.textContent = "Card types";
    card.appendChild(typeLabel);
    const pillRow = document.createElement("div");
    pillRow.className = "builder-pill-row";
    const typeMap = { disease: "Disease", drug: "Drug", concept: "Concept" };
    Object.entries(typeMap).forEach(([value, label]) => {
      const active = state.builder.types.includes(value);
      const pill = createPill(active, label, () => {
        toggleType(value);
        rerender();
      }, "small");
      pillRow.appendChild(pill);
    });
    card.appendChild(pillRow);
    const favToggle = createPill(state.builder.onlyFav, "Only favorites", () => {
      setBuilder({ onlyFav: !state.builder.onlyFav });
      notifyBuilderChanged({ selectionChanged: true });
      rerender();
    }, "small outline");
    card.appendChild(favToggle);
    const selectionMeta = document.createElement("div");
    selectionMeta.className = "builder-selection-meta";
    const blockCount = countSelectedBlocks();
    const lectureCount = state.builder.lectures.length;
    selectionMeta.innerHTML = `
    <span>Blocks: ${blockCount}</span>
    <span>Lectures: ${lectureCount}</span>
  `;
    card.appendChild(selectionMeta);
    const actions = document.createElement("div");
    actions.className = "builder-filter-actions";
    const clearBtn = document.createElement("button");
    clearBtn.type = "button";
    clearBtn.className = "btn secondary builder-clear-btn";
    clearBtn.textContent = "Clear selection";
    clearBtn.disabled = !hasAnySelection();
    clearBtn.addEventListener("click", () => {
      setBuilder({ blocks: [], weeks: [], lectures: [] });
      notifyBuilderChanged({ selectionChanged: true });
      rerender();
    });
    actions.appendChild(clearBtn);
    card.appendChild(actions);
    return card;
  }
  function renderModeCard(rerender, redraw) {
    const card = document.createElement("div");
    card.className = "card builder-mode-card";
    const title = document.createElement("h3");
    title.textContent = "Modes";
    card.appendChild(title);
    const layout = document.createElement("div");
    layout.className = "builder-mode-layout";
    card.appendChild(layout);
    const modeColumn = document.createElement("div");
    modeColumn.className = "builder-mode-option-column";
    layout.appendChild(modeColumn);
    const controls = document.createElement("div");
    controls.className = "builder-mode-controls";
    layout.appendChild(controls);
    const modeLabel = document.createElement("div");
    modeLabel.className = "builder-mode-options-title";
    modeLabel.textContent = "Choose a mode";
    modeColumn.appendChild(modeLabel);
    const modeRow = document.createElement("div");
    modeRow.className = "builder-mode-options";
    modeColumn.appendChild(modeRow);
    const status = document.createElement("div");
    status.className = "builder-mode-status";
    controls.appendChild(status);
    const countInfo = document.createElement("div");
    countInfo.className = "builder-mode-count";
    controls.appendChild(countInfo);
    const actions = document.createElement("div");
    actions.className = "builder-mode-actions";
    controls.appendChild(actions);
    const startBtn = document.createElement("button");
    startBtn.type = "button";
    startBtn.className = "btn builder-start-btn";
    startBtn.textContent = "Start";
    actions.appendChild(startBtn);
    const resumeBtn = document.createElement("button");
    resumeBtn.type = "button";
    resumeBtn.className = "btn builder-resume-btn";
    resumeBtn.textContent = "Resume";
    actions.appendChild(resumeBtn);
    const modes = ["Flashcards", "Quiz", "Blocks"];
    const selected = state.study?.selectedMode || "Flashcards";
    modes.forEach((mode2) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "builder-mode-toggle";
      btn.dataset.mode = mode2.toLowerCase();
      const isActive = mode2 === selected;
      if (isActive) btn.classList.add("is-active");
      btn.dataset.active = isActive ? "true" : "false";
      btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      btn.textContent = mode2;
      btn.addEventListener("click", () => {
        setStudySelectedMode(mode2);
        rerender();
      });
      modeRow.appendChild(btn);
    });
    const storageKey = MODE_KEY[selected] || null;
    const savedEntry = storageKey ? getStudySessionEntry(storageKey) : null;
    const hasSaved = !!(savedEntry && savedEntry.session);
    const savedCount = hasSaved && Array.isArray(savedEntry.cohort) ? savedEntry.cohort.length : 0;
    resumeBtn.disabled = !hasSaved;
    resumeBtn.classList.toggle("is-ready", hasSaved);
    const labelTitle = selected.toLowerCase();
    const handleError = (err) => console.warn("Failed to update study session state", err);
    let latestCount = Array.isArray(state.cohort) ? state.cohort.length : 0;
    const updateStatus = (count = latestCount, { error = false } = {}) => {
      status.classList.remove("is-error", "is-warning");
      if (error) {
        status.classList.add("is-error");
        status.textContent = "Unable to load selected cards.";
        return;
      }
      if (hasSaved) {
        status.textContent = `Saved ${labelTitle} session${savedCount ? ` \u2022 ${savedCount} cards` : ""}`;
        return;
      }
      if (!count) {
        status.textContent = selected === "Blocks" ? "Select study cards to open Blocks mode." : "Choose lectures or filters to add study cards.";
        return;
      }
      status.textContent = `Ready to start ${labelTitle}.`;
    };
    const updateCountDisplay = (count, { pending: pending2 = false, error = false } = {}) => {
      latestCount = count;
      countInfo.classList.remove("is-error", "is-loading");
      if (error) {
        countInfo.classList.add("is-error");
        countInfo.textContent = "Unable to load selected cards";
        startBtn.disabled = true;
        startBtn.classList.remove("is-ready");
        updateStatus(count, { error: true });
        return;
      }
      if (pending2) {
        countInfo.classList.add("is-loading");
        countInfo.textContent = "Updating selection\u2026";
        startBtn.disabled = true;
        startBtn.classList.remove("is-ready");
        if (!hasSaved) {
          status.textContent = "Updating selection\u2026";
          status.classList.remove("is-error", "is-warning");
        }
        return;
      }
      const ready = count > 0;
      countInfo.textContent = ready ? `${count} card${count === 1 ? "" : "s"} selected` : "No cards selected";
      startBtn.disabled = !ready;
      startBtn.classList.toggle("is-ready", ready);
      updateStatus(count);
    };
    const selection = snapshotSelection();
    const signature = selectionSignature(selection);
    const needsSync = signature !== lastAppliedSelectionSignature;
    if (!latestCount && needsSync) {
      updateCountDisplay(latestCount, { pending: true });
    } else {
      updateCountDisplay(latestCount);
    }
    ensureCohortSync({ force: needsSync }).then((items) => {
      const currentSignature = selectionSignature(snapshotSelection());
      if (currentSignature === signature) {
        const count = Array.isArray(items) ? items.length : 0;
        updateCountDisplay(count);
      } else {
        const currentCount = Array.isArray(state.cohort) ? state.cohort.length : 0;
        updateCountDisplay(currentCount);
      }
    }).catch(() => {
      const fallbackCount = Array.isArray(state.cohort) ? state.cohort.length : 0;
      updateCountDisplay(fallbackCount, { error: true });
    });
    startBtn.addEventListener("click", async () => {
      if (startBtn.disabled) return;
      const original = startBtn.textContent;
      startBtn.disabled = true;
      startBtn.textContent = "Preparing\u2026";
      status.classList.remove("is-error", "is-warning");
      status.textContent = `Preparing ${labelTitle}\u2026`;
      try {
        const pool = await ensureCohortSync({ force: true });
        const cohortItems = Array.isArray(pool) ? pool : Array.isArray(state.cohort) ? state.cohort : [];
        if (!cohortItems.length) {
          updateCountDisplay(0);
          status.classList.add("is-warning");
          status.textContent = "No cards selected. Adjust the filters above to add cards.";
          return;
        }
        setStudySelectedMode(selected);
        const key = MODE_KEY[selected];
        if (selected === "Blocks") {
          if (key) {
            await removeStudySession(key).catch(handleError);
          }
          resetBlockMode();
          setSubtab("Study", "Blocks");
          setTab("Block Board");
          redraw();
          return;
        }
        if (!key) return;
        await removeStudySession(key).catch(handleError);
        if (selected === "Flashcards") {
          setFlashSession({ idx: 0, pool: cohortItems, ratings: {}, mode: "study" });
        } else if (selected === "Quiz") {
          setQuizSession({ idx: 0, score: 0, pool: cohortItems });
        }
        setSubtab("Study", "Builder");
        setTab("Study");
        redraw();
      } catch (err) {
        handleError(err);
        status.classList.add("is-error");
        status.textContent = "Unable to start. Please try again.";
      } finally {
        startBtn.textContent = original;
        const hasCards = Array.isArray(state.cohort) && state.cohort.length > 0;
        startBtn.disabled = !hasCards;
        startBtn.classList.toggle("is-ready", hasCards);
      }
    });
    resumeBtn.addEventListener("click", async () => {
      if (!hasSaved || !storageKey || !savedEntry) return;
      setStudySelectedMode(selected);
      await removeStudySession(storageKey).catch(handleError);
      const restoredCohort = Array.isArray(savedEntry.cohort) ? savedEntry.cohort : [];
      setCohort(restoredCohort);
      if (selected === "Blocks") {
        resetBlockMode();
        if (savedEntry.session && typeof savedEntry.session === "object") {
          setBlockMode(savedEntry.session);
        }
        setSubtab("Study", "Blocks");
        setTab("Block Board");
        redraw();
        return;
      }
      if (selected === "Flashcards") {
        setFlashSession(savedEntry.session);
      } else if (selected === "Quiz") {
        setQuizSession(savedEntry.session);
      }
      setSubtab("Study", "Builder");
      setTab("Study");
      redraw();
    });
    return card;
  }
  function renderReviewCard(redraw) {
    const card = document.createElement("div");
    card.className = "card builder-review-card";
    const title = document.createElement("h3");
    title.textContent = "Review";
    card.appendChild(title);
    const status = document.createElement("div");
    status.className = "builder-review-status";
    status.textContent = "Loading review queue\u2026";
    card.appendChild(status);
    const actions = document.createElement("div");
    actions.className = "builder-review-actions";
    const openBtn = document.createElement("button");
    openBtn.type = "button";
    openBtn.className = "btn secondary";
    openBtn.textContent = "Open review";
    openBtn.disabled = false;
    openBtn.addEventListener("click", () => {
      setSubtab("Study", "Review");
      redraw();
    });
    actions.appendChild(openBtn);
    const saved = getStudySessionEntry("review");
    if (saved?.session) {
      const resumeBtn = document.createElement("button");
      resumeBtn.type = "button";
      resumeBtn.className = "btn builder-review-resume";
      resumeBtn.textContent = "Resume review";
      resumeBtn.addEventListener("click", async () => {
        await removeStudySession("review").catch((err) => console.warn("Failed to clear review session stub", err));
        const restored = Array.isArray(saved.cohort) ? saved.cohort : null;
        if (restored) {
          setCohort(restored);
        }
        setFlashSession(saved.session);
        setSubtab("Study", "Review");
        redraw();
      });
      actions.appendChild(resumeBtn);
    }
    card.appendChild(actions);
    updateReviewSummary(saved);
    return card;
    async function updateReviewSummary(savedEntry = null) {
      try {
        const items = await loadReviewSourceItems();
        const dueCount = collectReviewCount(items);
        if (items.length) {
          const base = dueCount ? `${dueCount} card${dueCount === 1 ? "" : "s"} due` : "All caught up!";
          if (savedEntry?.session) {
            const savedLabel = savedEntry.metadata?.label ? savedEntry.metadata.label : "Saved review session ready";
            status.textContent = `${base} \u2022 ${savedLabel}`;
          } else {
            status.textContent = base;
          }
        } else {
          status.textContent = "Review queue ready \u2014 no cards due yet.";
        }
      } catch (err) {
        console.warn("Failed to summarize review queue", err);
        status.textContent = "Unable to load review queue.";
      }
    }
  }
  async function gatherItems(selection = snapshotSelection()) {
    const types = Array.isArray(selection.types) && selection.types.length ? selection.types : [];
    if (!types.length) return [];
    const results = await Promise.all(types.map(async (kind) => {
      try {
        const list = await listItemsByKind(kind);
        return Array.isArray(list) ? list : [];
      } catch (err) {
        console.warn("Failed to load cards for kind", kind, err);
        return [];
      }
    }));
    const combined = results.flat();
    const blockSet = new Set(Array.isArray(selection.blocks) ? selection.blocks : []);
    const lectureSet = new Set(Array.isArray(selection.lectures) ? selection.lectures : []);
    const wantUnlabeled = blockSet.has("__unlabeled");
    return combined.filter((item) => {
      if (selection.onlyFav && !item.favorite) return false;
      if (blockSet.size) {
        const blocks = Array.isArray(item.blocks) ? item.blocks : [];
        const hasBlockMatch = blocks.some((b) => blockSet.has(b));
        if (!hasBlockMatch) {
          const isUnlabeled = !blocks.length;
          if (!(wantUnlabeled && isUnlabeled)) return false;
        }
      }
      if (lectureSet.size) {
        const lectures = Array.isArray(item.lectures) ? item.lectures : [];
        const ok = lectures.some((lecture) => {
          const blockId = lecture?.blockId;
          const lectureId = lecture?.id ?? lecture?.lectureId;
          if (blockId == null || lectureId == null) return false;
          const key = lectureKeyFor(blockId, lectureId);
          return lectureSet.has(key);
        });
        if (!ok) return false;
      }
      return true;
    });
  }
  function selectEntireBlock(block) {
    const blockId = block.blockId;
    const blockSet = new Set(state.builder.blocks);
    const lectureSet = new Set(state.builder.lectures);
    const lectures = lectureListFor(blockId, { clone: false });
    if (lectures.length) {
      lectures.forEach((lecture) => {
        lectureSet.add(lectureKeyFor(blockId, lecture.id));
      });
      syncBlockWithLectureSelection(blockSet, lectureSet, block);
    } else {
      blockSet.add(blockId);
    }
    setActiveBlock(blockId);
    ensureWeekForBlock(blockId);
    setBuilder({
      blocks: Array.from(blockSet),
      lectures: Array.from(lectureSet),
      weeks: []
    });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function clearBlock(blockId) {
    const lectureSet = new Set(state.builder.lectures);
    const blockSet = new Set(state.builder.blocks);
    for (const key of Array.from(lectureSet)) {
      if (key.startsWith(`${blockId}|`)) lectureSet.delete(key);
    }
    blockSet.delete(blockId);
    setActiveBlock(blockId);
    ensureWeekForBlock(blockId);
    setBuilder({
      blocks: Array.from(blockSet),
      lectures: Array.from(lectureSet),
      weeks: []
    });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function selectWeek(block, week) {
    const blockId = block.blockId;
    const lectureSet = new Set(state.builder.lectures);
    const blockSet = new Set(state.builder.blocks);
    const lectures = lectureListFor(blockId, { clone: false });
    lectures.forEach((lecture) => {
      if (lecture.week === week) {
        lectureSet.add(lectureKeyFor(blockId, lecture.id));
      }
    });
    syncBlockWithLectureSelection(blockSet, lectureSet, block);
    setActiveBlock(blockId);
    setActiveWeek(blockId, week);
    setBuilder({
      lectures: Array.from(lectureSet),
      blocks: Array.from(blockSet),
      weeks: []
    });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function clearWeek(block, week) {
    const blockId = block.blockId;
    const lectureSet = new Set(state.builder.lectures);
    const blockSet = new Set(state.builder.blocks);
    const lectures = lectureListFor(blockId, { clone: false });
    lectures.forEach((lecture) => {
      if (lecture.week === week) {
        lectureSet.delete(lectureKeyFor(blockId, lecture.id));
      }
    });
    syncBlockWithLectureSelection(blockSet, lectureSet, block);
    setActiveBlock(blockId);
    setActiveWeek(blockId, week);
    setBuilder({
      lectures: Array.from(lectureSet),
      blocks: Array.from(blockSet),
      weeks: []
    });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function toggleLecture(block, lecture) {
    const key = lectureKeyFor(block.blockId, lecture.id);
    const lectureSet = new Set(state.builder.lectures);
    const blockSet = new Set(state.builder.blocks);
    if (lectureSet.has(key)) {
      lectureSet.delete(key);
    } else {
      lectureSet.add(key);
    }
    syncBlockWithLectureSelection(blockSet, lectureSet, block);
    setActiveBlock(block.blockId);
    setActiveWeek(block.blockId, lecture.week != null ? lecture.week : -1);
    setBuilder({
      lectures: Array.from(lectureSet),
      blocks: Array.from(blockSet),
      weeks: []
    });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function toggleType(type) {
    const types = new Set(state.builder.types);
    if (types.has(type)) types.delete(type);
    else types.add(type);
    setBuilder({ types: Array.from(types) });
    notifyBuilderChanged({ selectionChanged: true });
  }
  function isBlockCollapsed(blockId) {
    if (state.builder.activeBlockId) {
      return state.builder.activeBlockId !== blockId;
    }
    return (state.builder.collapsedBlocks || []).includes(blockId);
  }
  function toggleBlockCollapsed(blockId) {
    if (!blockId) return;
    if (isBlockCollapsed(blockId)) {
      setActiveBlock(blockId);
      ensureWeekForBlock(blockId);
      return;
    }
    const fallback = findNextBlock(blockId);
    if (!fallback || fallback === blockId) {
      return;
    }
    setActiveBlock(fallback);
    ensureWeekForBlock(fallback);
  }
  function isWeekCollapsed(blockId, week) {
    const activeBlockId = state.builder.activeBlockId;
    if (!activeBlockId) {
      return (state.builder.collapsedWeeks || []).includes(weekKeyFor(blockId, week));
    }
    if (blockId !== activeBlockId) return true;
    const activeWeekKey = state.builder.activeWeekKey;
    const entries = builderWeekMap.get(blockId) || [];
    if (!entries.length) return true;
    const key = weekKeyFor(blockId, week);
    if (!activeWeekKey) {
      return key !== entries[0].key;
    }
    return activeWeekKey !== key;
  }
  function toggleWeekCollapsed(blockId, week) {
    const normalizedWeek = week;
    if (isWeekCollapsed(blockId, normalizedWeek)) {
      setActiveBlock(blockId);
      setActiveWeek(blockId, normalizedWeek);
      ensureWeekForBlock(blockId);
      return;
    }
    const entries = builderWeekMap.get(blockId) || [];
    const currentKey = weekKeyFor(blockId, normalizedWeek);
    const fallback = entries.find((entry) => entry.key !== currentKey);
    if (!fallback) return;
    setActiveWeek(blockId, fallback.week);
  }
  function isBlockFullySelected(block, lectures) {
    if (!block) return false;
    const blockId = block.blockId;
    if (!state.builder.blocks.includes(blockId)) return false;
    if (!lectures?.length) return true;
    return areAllLecturesSelected(blockId, lectures);
  }
  function hasAnySelection() {
    return state.builder.blocks.length || state.builder.lectures.length;
  }
  function countSelectedBlocks() {
    const blockSet = new Set(state.builder.blocks);
    for (const key of state.builder.lectures) {
      const [blockId] = key.split("|");
      if (blockId) blockSet.add(blockId);
    }
    return blockSet.size;
  }
  function groupByWeek(lectures) {
    const map = /* @__PURE__ */ new Map();
    lectures.forEach((lecture) => {
      const week = lecture.week != null ? lecture.week : -1;
      if (!map.has(week)) map.set(week, []);
      map.get(week).push(lecture);
    });
    return Array.from(map.entries()).sort((a, b) => {
      const [weekA, weekB] = [a[0], b[0]];
      const specialA = weekA == null || weekA < 0;
      const specialB = weekB == null || weekB < 0;
      if (specialA && specialB) return 0;
      if (specialA) return 1;
      if (specialB) return -1;
      return weekB - weekA;
    }).map(([week, items]) => ({ week, items }));
  }
  function weekKeyFor(blockId, week) {
    return `${blockId}|${week}`;
  }
  function lectureKeyFor(blockId, lectureId) {
    return `${blockId}|${lectureId}`;
  }
  function formatWeekLabel2(week) {
    if (week == null || week < 0) return "No week";
    return `Week ${week}`;
  }
  function hasAnyLectureSelected(blockId, lectures) {
    if (!lectures?.length) return false;
    const lectureSet = new Set(state.builder.lectures);
    return lectures.some((lecture) => lectureSet.has(lectureKeyFor(blockId, lecture.id)));
  }
  function areAllLecturesSelected(blockId, lectures) {
    if (!lectures?.length) return false;
    const lectureSet = new Set(state.builder.lectures);
    return lectures.every((lecture) => lectureSet.has(lectureKeyFor(blockId, lecture.id)));
  }
  function syncBlockWithLectureSelection(blockSet, lectureSet, block) {
    if (!block) return;
    const blockId = block.blockId;
    const prefix = `${blockId}|`;
    let hasLecture = false;
    for (const key of lectureSet) {
      if (key.startsWith(prefix)) {
        hasLecture = true;
        break;
      }
    }
    if (!hasLecture) {
      blockSet.delete(blockId);
      return;
    }
    const blockLectures = lectureListFor(blockId, { clone: false });
    if (!blockLectures.length) {
      blockSet.add(blockId);
      return;
    }
    const allSelected = blockLectures.every((lecture) => lectureSet.has(lectureKeyFor(blockId, lecture.id)));
    if (allSelected) {
      blockSet.add(blockId);
    } else {
      blockSet.delete(blockId);
    }
  }
  function createPill(active, label, onClick, variant = "") {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "builder-pill";
    if (variant) {
      const variants = Array.isArray(variant) ? variant : variant.split(" ");
      variants.filter(Boolean).forEach((name) => btn.classList.add(`builder-pill-${name}`));
    }
    setToggleState(btn, active);
    btn.textContent = label;
    btn.addEventListener("click", onClick);
    return btn;
  }
  function createAction(label, onClick, variant = "") {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "builder-action";
    if (variant) {
      const variants = Array.isArray(variant) ? variant : variant.split(" ");
      variants.filter(Boolean).forEach((name) => btn.classList.add(`builder-action-${name}`));
    }
    btn.textContent = label;
    btn.addEventListener("click", onClick);
    return btn;
  }
  function createCollapseToggle({ collapsed, label, onToggle, variant = "week" }) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "builder-collapse-toggle";
    if (variant === "block") btn.classList.add("builder-collapse-toggle-block");
    btn.setAttribute("aria-expanded", String(!collapsed));
    btn.setAttribute("aria-label", label);
    btn.textContent = collapsed ? "\u25B8" : "\u25BE";
    btn.addEventListener("click", onToggle);
    return btn;
  }
  var MODE_KEY, lectureSource, builderBlockOrder, builderWeekMap, pendingCohortUpdate, lastAppliedSelectionSignature;
  var init_builder = __esm({
    "js/ui/components/builder.js"() {
      init_state();
      init_storage();
      init_block_catalog();
      init_utils();
      init_study_sessions();
      init_scheduler2();
      init_pool();
      MODE_KEY = {
        Flashcards: "flashcards",
        Quiz: "quiz",
        Blocks: "blocks"
      };
      lectureSource = {};
      builderBlockOrder = [];
      builderWeekMap = /* @__PURE__ */ new Map();
      pendingCohortUpdate = null;
      lastAppliedSelectionSignature = null;
    }
  });

  // js/storage/transfers.js
  function prom4(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function sanitizeBlock(block) {
    if (!block || typeof block !== "object") return null;
    const copy = deepClone(block);
    return {
      blockId: copy.blockId,
      title: copy.title || "",
      color: copy.color || null,
      weeks: Number.isFinite(copy.weeks) ? copy.weeks : null,
      startDate: null,
      endDate: null
    };
  }
  function sanitizeLecture(lecture) {
    if (!lecture || typeof lecture !== "object") return null;
    const copy = deepClone(lecture);
    return {
      blockId: copy.blockId,
      id: copy.id,
      name: copy.name || "",
      week: copy.week ?? null,
      tags: Array.isArray(copy.tags) ? copy.tags.slice() : [],
      passPlan: copy.passPlan ? deepClone(copy.passPlan) : null,
      plannerDefaults: copy.plannerDefaults ? deepClone(copy.plannerDefaults) : null,
      notes: typeof copy.notes === "string" ? copy.notes : "",
      position: Number.isFinite(copy.position) ? copy.position : null
    };
  }
  function buildLectureKey(blockId, lectureId) {
    if (blockId == null || lectureId == null) return null;
    return `${blockId}|${lectureId}`;
  }
  function readLegacyField(source, key) {
    if (!source || typeof source !== "object") return void 0;
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      return source[key];
    }
    if (source.data && typeof source.data === "object" && Object.prototype.hasOwnProperty.call(source.data, key)) {
      return source.data[key];
    }
    if (source.payload && typeof source.payload === "object" && Object.prototype.hasOwnProperty.call(source.payload, key)) {
      return source.payload[key];
    }
    return void 0;
  }
  function normalizeScopeValue(rawScope, lectures) {
    if (typeof rawScope === "string") {
      const normalized2 = rawScope.trim().toLowerCase();
      if (normalized2 === "block" || normalized2 === "blocks") {
        return "block";
      }
      if (normalized2 === "week" || normalized2 === "weeks") {
        return "week";
      }
      if (normalized2 === "lecture" || normalized2 === "lectures") {
        return "lecture";
      }
      if ((normalized2 === "all" || normalized2 === "full") && Array.isArray(lectures) && lectures.length > 1) {
        return "block";
      }
    }
    return "lecture";
  }
  function collectLectureKeys(lectures) {
    const keys = /* @__PURE__ */ new Set();
    lectures.forEach((lecture) => {
      const key = buildLectureKey(lecture.blockId, lecture.id);
      if (key) keys.add(key);
    });
    return keys;
  }
  function matchItemToScope(item, { blockId, week, lectureKeys, includeLooseBlockItems = false }) {
    if (!item) return false;
    const itemLectures = Array.isArray(item.lectures) ? item.lectures : [];
    for (const ref of itemLectures) {
      const key = buildLectureKey(ref?.blockId, ref?.id);
      if (key && lectureKeys.has(key)) {
        return true;
      }
      if (week != null && ref && ref.blockId === blockId) {
        const refWeek = ref.week == null ? null : ref.week;
        if (refWeek === week) return true;
      }
    }
    if (includeLooseBlockItems) {
      const itemBlocks = Array.isArray(item.blocks) ? item.blocks : [];
      if (itemBlocks.some((id) => id === blockId)) {
        if (week == null) return true;
        const weeks = Array.isArray(item.weeks) ? item.weeks : [];
        if (weeks.some((w) => w === week)) return true;
      }
    }
    return false;
  }
  async function fetchBlockRecord(blockId) {
    if (!blockId) return null;
    const db = await openDB();
    const tx = db.transaction("blocks");
    const store2 = tx.objectStore("blocks");
    const record = await prom4(store2.get(blockId));
    if (!record) return null;
    const { lectures, ...rest } = record;
    return rest;
  }
  async function fetchLectures(blockId) {
    const db = await openDB();
    const tx = db.transaction("lectures");
    const store2 = tx.objectStore("lectures");
    if (!blockId) {
      const all2 = await prom4(store2.getAll());
      return Array.isArray(all2) ? all2 : [];
    }
    const index = typeof store2.index === "function" ? store2.index("by_block") : null;
    if (index && typeof index.getAll === "function") {
      return await prom4(index.getAll(blockId));
    }
    const all = await prom4(store2.getAll());
    return (Array.isArray(all) ? all : []).filter((lecture) => lecture?.blockId === blockId);
  }
  async function fetchAllItems() {
    const db = await openDB();
    const tx = db.transaction("items");
    const store2 = tx.objectStore("items");
    const all = await prom4(store2.getAll());
    return Array.isArray(all) ? all : [];
  }
  function sanitizeItems(items) {
    return items.map((item) => {
      const copy = deepClone(item);
      delete copy.tokens;
      delete copy.searchMeta;
      return copy;
    });
  }
  function buildBundle({ scope, block, lectures, items }) {
    return {
      version: TRANSFER_VERSION,
      scope,
      exportedAt: Date.now(),
      block: block ? sanitizeBlock(block) : null,
      lectures: Array.isArray(lectures) ? lectures.map(sanitizeLecture).filter(Boolean) : [],
      items: sanitizeItems(items || [])
    };
  }
  async function exportBundleForLectures(lectures, options = {}) {
    if (!Array.isArray(lectures) || !lectures.length) {
      throw new Error("No lectures to export");
    }
    const blockId = lectures[0].blockId;
    const block = blockId ? await fetchBlockRecord(blockId) : null;
    const lectureKeys = collectLectureKeys(lectures);
    const allItems = await fetchAllItems();
    const items = allItems.filter(
      (item) => matchItemToScope(item, {
        blockId,
        week: options.week ?? null,
        lectureKeys,
        includeLooseBlockItems: options.includeLooseBlockItems === true
      })
    );
    return buildBundle({ scope: options.scope || "lecture", block, lectures, items });
  }
  async function exportLectureTransfer(blockId, lectureId) {
    if (blockId == null || lectureId == null) {
      throw new Error("Missing lecture identity");
    }
    const lectures = await fetchLectures(blockId);
    const numericId = Number(lectureId);
    const match = lectures.find((lecture) => {
      const id = Number(lecture?.id);
      if (Number.isFinite(id) && Number.isFinite(numericId)) return id === numericId;
      return lecture?.id === lectureId;
    });
    if (!match) {
      throw new Error("Lecture not found");
    }
    return exportBundleForLectures([match], { scope: "lecture", week: match.week ?? null });
  }
  async function exportWeekTransfer(blockId, week) {
    if (blockId == null) {
      throw new Error("Missing block identity");
    }
    const lectures = await fetchLectures(blockId);
    const normalizedWeek = week == null || week === "" ? null : week;
    const filtered = lectures.filter((lecture) => {
      const lectureWeek = lecture.week == null ? null : lecture.week;
      if (normalizedWeek == null) {
        return lectureWeek == null;
      }
      return lectureWeek === normalizedWeek;
    });
    if (!filtered.length) {
      throw new Error("No lectures found for week");
    }
    return exportBundleForLectures(filtered, { scope: "week", week: normalizedWeek });
  }
  async function exportBlockTransfer(blockId) {
    if (!blockId) {
      throw new Error("Missing block identity");
    }
    const lectures = await fetchLectures(blockId);
    if (!lectures.length) {
      throw new Error("No lectures found for block");
    }
    return exportBundleForLectures(lectures, { scope: "block", includeLooseBlockItems: true });
  }
  function ensureLectureDefaults(lecture) {
    const base = sanitizeLecture(lecture) || {};
    base.passes = [];
    base.passPlan = base.passPlan || null;
    base.plannerDefaults = base.plannerDefaults || null;
    base.status = { ...DEFAULT_LECTURE_STATUS, state: "unscheduled", completedPasses: 0, lastCompletedAt: null };
    base.nextDueAt = null;
    base.startAt = null;
    return base;
  }
  function normalizeTransferPayload(bundle) {
    if (!bundle || typeof bundle !== "object") {
      throw new Error("Invalid transfer payload");
    }
    const version = Number(bundle.version);
    if (Number.isFinite(version) && version > TRANSFER_VERSION) {
      throw new Error("Unsupported transfer version");
    }
    const rawLectures = readLegacyField(bundle, "lectures");
    const lectureList = Array.isArray(rawLectures) ? rawLectures : [];
    const lectures = lectureList.map(ensureLectureDefaults).filter(Boolean);
    const rawScope = readLegacyField(bundle, "scope");
    const scope = normalizeScopeValue(rawScope, lectureList);
    const rawBlock = readLegacyField(bundle, "block") ?? readLegacyField(bundle, "blockInfo") ?? {};
    let block = sanitizeBlock(rawBlock) || null;
    if (!block) {
      block = { blockId: null, title: "", color: null, weeks: null, startDate: null, endDate: null };
    }
    if (!block.blockId) {
      const fallbackLecture = lectures.find((lecture) => lecture?.blockId != null) || null;
      if (fallbackLecture && fallbackLecture.blockId != null) {
        block.blockId = fallbackLecture.blockId;
      }
    }
    lectures.forEach((lecture) => {
      if (!lecture.blockId && block.blockId != null) {
        lecture.blockId = block.blockId;
      }
    });
    if (!block.blockId) {
      throw new Error("Transfer missing block information");
    }
    const rawItems = readLegacyField(bundle, "items");
    const items = Array.isArray(rawItems) ? rawItems.map((item) => {
      const cleaned = cleanItem({ ...deepClone(item) });
      delete cleaned.tokens;
      delete cleaned.searchMeta;
      return cleaned;
    }) : [];
    return { scope, block, lectures, items };
  }
  async function deleteExisting(scope, blockId, lectures, strategy) {
    if (strategy !== "replace") return;
    if (!blockId) return;
    if (scope === "block") {
      await deleteBlock(blockId);
      return;
    }
    if (scope === "week") {
      const targetWeek = lectures[0]?.week ?? null;
      const existing = await listLecturesByBlock(blockId);
      const matches = existing.filter((lecture) => {
        const lectureWeek = lecture.week == null ? null : lecture.week;
        if (targetWeek == null) {
          return lectureWeek == null;
        }
        return lectureWeek === targetWeek;
      });
      for (const lecture of matches) {
        await deleteLecture(blockId, lecture.id);
      }
      return;
    }
    if (scope === "lecture") {
      const lecture = lectures[0];
      if (!lecture) return;
      await deleteLecture(blockId, lecture.id);
    }
  }
  function remapLectureIds(blockId, lectures, existingLectures, strategy) {
    const remapped = [];
    const lectureIdMap = /* @__PURE__ */ new Map();
    let maxId = existingLectures.reduce((max, lecture) => {
      const num = Number(lecture?.id);
      if (Number.isFinite(num) && num > max) return num;
      return max;
    }, 0);
    const existingIds = new Set(existingLectures.map((lecture) => lecture.id));
    lectures.forEach((lecture) => {
      const normalized2 = ensureLectureDefaults(lecture);
      normalized2.blockId = blockId;
      const desired = Number.isFinite(Number(lecture.id)) ? Number(lecture.id) : lecture.id;
      let finalId = desired;
      if (strategy === "merge" && existingIds.has(desired)) {
        maxId += 1;
        finalId = maxId;
      }
      normalized2.id = finalId;
      existingIds.add(finalId);
      const key = buildLectureKey(blockId, lecture.id);
      if (key) {
        lectureIdMap.set(key, {
          blockId,
          lectureId: finalId,
          name: normalized2.name,
          week: normalized2.week ?? null
        });
      }
      remapped.push(normalized2);
    });
    return { lectures: remapped, lectureIdMap };
  }
  function remapLectureRefs(refs, lectureIdMap) {
    if (!Array.isArray(refs)) return [];
    return refs.map((ref) => {
      if (!ref || typeof ref !== "object") return ref;
      const key = buildLectureKey(ref.blockId, ref.id);
      if (key && lectureIdMap.has(key)) {
        const mapping = lectureIdMap.get(key);
        return {
          blockId: mapping.blockId,
          id: mapping.lectureId,
          name: mapping.name || ref.name || "",
          week: mapping.week ?? ref.week ?? null
        };
      }
      return ref;
    });
  }
  function remapLinks(links, itemIdMap) {
    if (!Array.isArray(links)) return [];
    return links.map((link) => {
      if (!link || typeof link !== "object") return link;
      const mappedId = itemIdMap.get(link.id);
      if (mappedId) {
        return { ...link, id: mappedId };
      }
      return link;
    });
  }
  async function persistLectures(blockId, lectures, lectureIdMap) {
    for (const lecture of lectures) {
      const payload = {
        blockId,
        id: lecture.id,
        name: lecture.name,
        week: lecture.week,
        passPlan: lecture.passPlan || null,
        startAt: Date.now(),
        tags: Array.isArray(lecture.tags) ? lecture.tags.slice() : [],
        plannerDefaults: lecture.plannerDefaults || null,
        position: lecture.position
      };
      await saveLecture(payload);
      const db = await openDB();
      const tx = db.transaction("lectures", "readwrite");
      const store2 = tx.objectStore("lectures");
      const key = lectureKey(blockId, lecture.id);
      const record = await prom4(store2.get(key));
      if (record) {
        record.passes = [];
        record.status = { ...DEFAULT_LECTURE_STATUS, state: "unscheduled", completedPasses: 0, lastCompletedAt: null };
        record.nextDueAt = null;
        record.startAt = null;
        record.plannerDefaults = lecture.plannerDefaults || null;
        record.updatedAt = Date.now();
        await prom4(store2.put(record));
      }
      await new Promise((resolve, reject) => {
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
      });
      const keyStr = buildLectureKey(blockId, lecture.id);
      if (keyStr) {
        lectureIdMap.set(keyStr, {
          blockId,
          lectureId: lecture.id,
          name: lecture.name,
          week: lecture.week ?? null
        });
      }
    }
  }
  async function persistItems(items, lectureIdMap, strategy) {
    const existingIds = /* @__PURE__ */ new Set();
    const allExisting = await fetchAllItems();
    allExisting.forEach((item) => {
      if (item?.id) existingIds.add(item.id);
    });
    const plans = [];
    const itemIdMap = /* @__PURE__ */ new Map();
    for (const rawItem of items) {
      const originalId = rawItem?.id || null;
      let finalId = originalId;
      if (!originalId) {
        finalId = uid();
      } else if (!existingIds.has(originalId)) {
        finalId = originalId;
      } else if (strategy === "replace") {
        finalId = originalId;
      } else {
        let candidate = `${originalId}-${uid().slice(0, 6)}`;
        while (existingIds.has(candidate)) {
          candidate = `${originalId}-${uid().slice(0, 6)}`;
        }
        finalId = candidate;
        itemIdMap.set(originalId, finalId);
      }
      existingIds.add(finalId);
      plans.push({ raw: rawItem, finalId });
    }
    for (const plan of plans) {
      const item = cleanItem({ ...plan.raw });
      item.id = plan.finalId;
      item.lectures = remapLectureRefs(item.lectures, lectureIdMap);
      item.links = remapLinks(item.links, itemIdMap);
      delete item.tokens;
      delete item.searchMeta;
      item.tokens = buildTokens(item);
      item.searchMeta = buildSearchMeta(item);
      await upsertItem(item);
    }
    return itemIdMap;
  }
  async function importLectureTransfer(bundle, options = {}) {
    const { scope, block, lectures, items } = normalizeTransferPayload(bundle);
    if (!block || !block.blockId) {
      throw new Error("Transfer missing block information");
    }
    const strategy = options.strategy === "replace" ? "replace" : "merge";
    const blockId = block.blockId;
    await deleteExisting(scope, blockId, lectures, strategy);
    const existingBlock = await fetchBlockRecord(blockId);
    if (!existingBlock) {
      await upsertBlock({
        blockId,
        title: block.title,
        color: block.color,
        weeks: block.weeks,
        startDate: null,
        endDate: null,
        lectures: []
      });
    }
    const existingLectures = await listLecturesByBlock(blockId);
    const { lectures: normalizedLectures, lectureIdMap } = remapLectureIds(blockId, lectures, existingLectures, strategy);
    await persistLectures(blockId, normalizedLectures, lectureIdMap);
    const itemIdMap = await persistItems(items, lectureIdMap, strategy);
  }
  var TRANSFER_VERSION;
  var init_transfers = __esm({
    "js/storage/transfers.js"() {
      init_idb();
      init_storage();
      init_search();
      init_validators();
      init_utils();
      TRANSFER_VERSION = 1;
    }
  });

  // js/ui/components/lectures.js
  var lectures_exports = {};
  __export(lectures_exports, {
    renderLectures: () => renderLectures
  });
  function findLectureScrollContainer(element) {
    if (element && typeof element.closest === "function") {
      const main = element.closest("main");
      if (main && typeof main.scrollTop === "number") {
        return main;
      }
    }
    const doc = document.scrollingElement || document.documentElement || document.body;
    return doc;
  }
  function shallowArrayEqual(a, b) {
    const arrA = Array.isArray(a) ? a : [];
    const arrB = Array.isArray(b) ? b : [];
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i = 0; i < arrA.length; i += 1) {
      if (arrA[i] !== arrB[i]) {
        return false;
      }
    }
    return true;
  }
  function ensureLectureState() {
    if (!state.lectures) {
      setLecturesState({});
    }
    return state.lectures;
  }
  function captureLectureViewState() {
    const container = document.querySelector(".lectures-view");
    if (!container) {
      return;
    }
    const openBlocks = Array.from(
      container.querySelectorAll(".lectures-block-group")
    ).filter((details) => {
      if (!details) return false;
      if (typeof details.open === "boolean") return details.open;
      return details.hasAttribute("open");
    }).map((details) => String(details.dataset.blockKey ?? ""));
    const openWeeks = Array.from(container.querySelectorAll(".lectures-week-group")).filter((details) => {
      if (!details) return false;
      if (typeof details.open === "boolean") return details.open;
      return details.hasAttribute("open");
    }).map((details) => {
      const blockEl = details.closest(".lectures-block-group");
      const blockKey = blockEl?.dataset?.blockKey ?? "";
      const weekValue = details.dataset?.weekValue ?? "";
      return `${String(blockKey)}::${String(weekValue)}`;
    });
    const scrollContainer = findLectureScrollContainer(container);
    let rawScrollTop = 0;
    if (scrollContainer && typeof scrollContainer.scrollTop === "number") {
      rawScrollTop = scrollContainer.scrollTop;
    } else if (typeof window !== "undefined") {
      rawScrollTop = window.scrollY ?? window.pageYOffset ?? 0;
    }
    const normalizedScrollTop = Number.isFinite(rawScrollTop) && rawScrollTop > 0 ? Math.max(0, Math.round(rawScrollTop)) : 0;
    const lectureState = ensureLectureState();
    const openBlocksChanged = !shallowArrayEqual(lectureState.openBlocks, openBlocks);
    const openWeeksChanged = !shallowArrayEqual(lectureState.openWeeks, openWeeks);
    const previousScroll = Number(lectureState.scrollTop) || 0;
    const scrollChanged = Math.abs(normalizedScrollTop - previousScroll) > 1;
    if (!openBlocksChanged && !openWeeksChanged && !scrollChanged) {
      return;
    }
    const patch = { openSnapshot: Date.now() };
    if (openBlocksChanged) {
      patch.openBlocks = openBlocks;
    }
    if (openWeeksChanged) {
      patch.openWeeks = openWeeks;
    }
    if (scrollChanged) {
      patch.scrollTop = normalizedScrollTop;
    }
    setLecturesState(patch);
  }
  function collectLectures(catalog) {
    const lists = catalog?.lectureLists || {};
    const result = [];
    for (const list of Object.values(lists)) {
      if (!Array.isArray(list)) continue;
      list.forEach((entry) => {
        if (entry && typeof entry === "object") {
          result.push({ ...entry });
        }
      });
    }
    return result;
  }
  function buildBlockOrderMap(blocks) {
    const order = /* @__PURE__ */ new Map();
    blocks.forEach((block, index) => {
      if (!block || !block.blockId) return;
      order.set(block.blockId, index);
      order.set(String(block.blockId), index);
    });
    return order;
  }
  function slugify(value, fallback = "export") {
    if (value == null) return fallback;
    const text = String(value).toLowerCase();
    const slug = text.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").slice(0, 50);
    return slug || fallback;
  }
  function downloadJson(data, filename) {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  function isElementLike(node) {
    if (!node || typeof node !== "object") return false;
    if (typeof Element !== "undefined" && node instanceof Element) {
      return true;
    }
    return node.nodeType === 1;
  }
  function describeWeekValue(value) {
    if (value == null || value === "") return "No week assigned";
    const numeric = Number(value);
    if (Number.isFinite(numeric)) {
      return `Week ${numeric}`;
    }
    return `Week ${value}`;
  }
  function detectImportConflicts(bundle, catalog) {
    if (!bundle || typeof bundle !== "object") {
      return { hasConflicts: false };
    }
    const scopeRaw = typeof bundle.scope === "string" ? bundle.scope.toLowerCase() : "lecture";
    const scope = scopeRaw === "block" || scopeRaw === "week" ? scopeRaw : "lecture";
    const blockId = bundle.block && bundle.block.blockId != null ? String(bundle.block.blockId) : "";
    const blocks = Array.isArray(catalog?.blocks) ? catalog.blocks : [];
    const lectureLists = catalog?.lectureLists || {};
    const lectureIndex = catalog?.lectureIndex || {};
    const blockInfo = blocks.find((block) => String(block?.blockId) === blockId) || null;
    const blockTitle = blockInfo?.title || bundle?.block?.title || blockId || "Block";
    const blockExists = Boolean(blockInfo);
    const conflicts = {
      scope,
      blockId,
      blockTitle,
      blockExists: scope === "block" && blockExists,
      weeks: [],
      lectures: []
    };
    const existingLectures = lectureIndex[blockId] || {};
    const weekSet = /* @__PURE__ */ new Set();
    if (Array.isArray(bundle?.lectures)) {
      bundle.lectures.forEach((lecture) => {
        const lectureId = lecture?.id;
        const hasLectureConflict = Object.values(existingLectures).some((existing) => {
          if (!existing) return false;
          const existingId = existing.id;
          if (Number.isFinite(Number(existingId)) && Number.isFinite(Number(lectureId))) {
            return Number(existingId) === Number(lectureId);
          }
          return String(existingId) === String(lectureId);
        });
        if (hasLectureConflict) {
          conflicts.lectures.push({
            id: lectureId,
            name: lecture?.name || `Lecture ${lectureId}`
          });
        }
        if (scope !== "lecture") {
          const weekValue = lecture?.week == null ? null : lecture.week;
          if (!weekSet.has(weekValue)) {
            const existingWeek = (lectureLists[blockId] || []).some((entry) => {
              const entryWeek = entry?.week == null ? null : entry.week;
              return entryWeek === weekValue;
            });
            if (existingWeek) {
              conflicts.weeks.push(weekValue);
            }
            weekSet.add(weekValue);
          }
        }
      });
    }
    conflicts.hasConflicts = conflicts.blockExists || conflicts.weeks.length > 0 || conflicts.lectures.length > 0;
    return conflicts;
  }
  function promptImportStrategy(conflicts) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.className = "modal import-conflict-modal";
      const card = document.createElement("div");
      card.className = "card import-conflict-card";
      const title = document.createElement("h3");
      title.textContent = "Content already exists";
      card.appendChild(title);
      const message = document.createElement("p");
      message.textContent = "Choose whether to replace the existing content or merge the new material.";
      card.appendChild(message);
      const list = document.createElement("ul");
      list.className = "import-conflict-list";
      if (conflicts.blockExists) {
        const item = document.createElement("li");
        item.textContent = `Block "${conflicts.blockTitle}" already exists.`;
        list.appendChild(item);
      }
      if (Array.isArray(conflicts.weeks) && conflicts.weeks.length) {
        const item = document.createElement("li");
        const labels = conflicts.weeks.map(describeWeekValue).join(", ");
        item.textContent = `Week assignments already exist: ${labels}.`;
        list.appendChild(item);
      }
      if (Array.isArray(conflicts.lectures) && conflicts.lectures.length) {
        const item = document.createElement("li");
        const names = conflicts.lectures.map((entry) => entry.name || `Lecture ${entry.id}`).join(", ");
        item.textContent = `Lectures already exist: ${names}.`;
        list.appendChild(item);
      }
      if (list.childElementCount) {
        card.appendChild(list);
      }
      const actions = document.createElement("div");
      actions.className = "row import-conflict-actions";
      function cleanup(result) {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
        }
        resolve(result);
      }
      const replaceBtn = document.createElement("button");
      replaceBtn.type = "button";
      replaceBtn.className = "btn";
      replaceBtn.textContent = "Replace";
      replaceBtn.addEventListener("click", () => cleanup("replace"));
      const mergeBtn = document.createElement("button");
      mergeBtn.type = "button";
      mergeBtn.className = "btn secondary";
      mergeBtn.textContent = "Merge";
      mergeBtn.addEventListener("click", () => cleanup("merge"));
      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.className = "btn secondary";
      cancelBtn.textContent = "Cancel";
      cancelBtn.addEventListener("click", () => cleanup(null));
      actions.appendChild(replaceBtn);
      actions.appendChild(mergeBtn);
      actions.appendChild(cancelBtn);
      card.appendChild(actions);
      overlay.appendChild(card);
      overlay.addEventListener("click", (event) => {
        if (event.target === overlay) {
          cleanup(null);
        }
      });
      document.body.appendChild(overlay);
      replaceBtn.focus();
    });
  }
  function normalizeWeekValue(value) {
    if (value == null || value === "") return "";
    return String(value);
  }
  function formatWeekLabel3(week) {
    if (week == null || week === "") return "\u2014";
    const num = Number(week);
    if (!Number.isFinite(num)) return String(week);
    return `Week ${num}`;
  }
  function collectBlockWeekOptions(blockId, blocks = [], lectureLists = {}) {
    if (!blockId) return [];
    const normalizedId = String(blockId);
    const blockInfo = blocks.find((block) => String(block?.blockId) === normalizedId) || null;
    const result = /* @__PURE__ */ new Set();
    const weeksValue = Number(blockInfo?.weeks);
    if (Number.isFinite(weeksValue) && weeksValue > 0) {
      const total = Math.max(1, Math.round(weeksValue));
      for (let i = 1; i <= total; i += 1) {
        result.add(i);
      }
    }
    const list = Array.isArray(lectureLists?.[normalizedId]) ? lectureLists[normalizedId] : [];
    list.forEach((entry) => {
      const weekNum = Number(entry?.week);
      if (Number.isFinite(weekNum) && weekNum >= 0) {
        result.add(weekNum);
      }
    });
    return Array.from(result).sort((a, b) => a - b);
  }
  function populateWeekSelect(select, blockId, blocks, lectureLists, options = {}) {
    if (!select) return;
    const {
      selectedValue = "",
      includeBlank = true,
      blankLabel = "No week"
    } = options;
    const normalizedValue = normalizeWeekValue(selectedValue);
    select.innerHTML = "";
    if (includeBlank) {
      const blank = document.createElement("option");
      blank.value = "";
      blank.textContent = blankLabel;
      select.appendChild(blank);
    }
    const weeks = collectBlockWeekOptions(blockId, blocks, lectureLists);
    weeks.forEach((week) => {
      const option = document.createElement("option");
      option.value = String(week);
      option.textContent = formatWeekLabel3(week);
      select.appendChild(option);
    });
    if (normalizedValue && !weeks.some((week) => String(week) === normalizedValue)) {
      const custom = document.createElement("option");
      custom.value = normalizedValue;
      custom.textContent = formatWeekLabel3(normalizedValue);
      select.appendChild(custom);
    }
    select.value = normalizedValue;
  }
  function formatOffset2(minutes) {
    if (!Number.isFinite(minutes)) return "0m";
    const abs = Math.abs(minutes);
    if (abs < 60) return `${Math.round(minutes)}m`;
    const hours = minutes / 60;
    if (Math.abs(hours) < 24) return `${Math.round(hours)}h`;
    const days = minutes / (60 * 24);
    if (Math.abs(days) < 7) return `${Math.round(days)}d`;
    const weeks = minutes / (60 * 24 * 7);
    if (Math.abs(weeks) < 4) return `${Math.round(weeks)}w`;
    const months = minutes / (60 * 24 * 30);
    return `${Math.round(months)}mo`;
  }
  function normalizeOffsetUnit2(id) {
    const fallback = OFFSET_UNITS2[2];
    if (typeof id !== "string") return fallback.id;
    const match = OFFSET_UNITS2.find((option) => option.id === id);
    return match ? match.id : fallback.id;
  }
  function splitOffsetMinutes2(minutes) {
    const value = Number.isFinite(minutes) ? Math.max(0, Math.round(minutes)) : 0;
    if (value === 0) {
      return { value: 0, unit: "days" };
    }
    const preferred = [...OFFSET_UNITS2].reverse().find((option) => value % option.minutes === 0);
    if (preferred) {
      return { value: Math.round(value / preferred.minutes), unit: preferred.id };
    }
    if (value < 60) {
      return { value, unit: "minutes" };
    }
    if (value < 60 * 24) {
      return { value: Math.round(value / 60), unit: "hours" };
    }
    return { value: Math.round(value / (60 * 24)), unit: "days" };
  }
  function combineOffsetValueUnit2(value, unitId) {
    const normalizedUnit = normalizeOffsetUnit2(unitId);
    const option = OFFSET_UNITS2.find((entry) => entry.id === normalizedUnit) || OFFSET_UNITS2[2];
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) {
      return 0;
    }
    return Math.max(0, Math.round(numeric * option.minutes));
  }
  function formatDateForInput(timestamp = Date.now()) {
    if (!Number.isFinite(timestamp)) return "";
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  function parseDateInputValue(value) {
    if (typeof value !== "string" || !value) return null;
    const [yearStr, monthStr, dayStr] = value.split("-");
    const year = Number(yearStr);
    const month = Number(monthStr) - 1;
    const day = Number(dayStr);
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return null;
    }
    const date = new Date(year, month, day, 0, 0, 0, 0);
    if (Number.isNaN(date.getTime())) return null;
    return date.getTime();
  }
  function passAccent(order = 1) {
    return passColorForOrder(order);
  }
  function formatPassDueTimestamp(due) {
    if (!Number.isFinite(due)) return "";
    const date = new Date(due);
    return `${PASS_DUE_FORMAT.format(date)} \u2022 ${PASS_TIME_FORMAT.format(date)}`;
  }
  function describePassCountdown(due, now = Date.now()) {
    if (!Number.isFinite(due)) return "Unscheduled";
    const diffMs = due - now;
    const dayMs = 24 * 60 * 60 * 1e3;
    if (Math.abs(diffMs) < dayMs) {
      return diffMs >= 0 ? "Due today" : "Overdue today";
    }
    if (diffMs > 0) {
      const days = Math.ceil(diffMs / dayMs);
      return days === 1 ? "In 1 day" : `In ${days} days`;
    }
    const overdueDays = Math.ceil(Math.abs(diffMs) / dayMs);
    return overdueDays === 1 ? "1 day overdue" : `${overdueDays} days overdue`;
  }
  function buildPassDisplayList(lecture) {
    const scheduleList = Array.isArray(lecture?.passPlan?.schedule) ? lecture.passPlan.schedule : [];
    const scheduleByOrder = /* @__PURE__ */ new Map();
    scheduleList.forEach((step, index) => {
      const order = Number.isFinite(step?.order) ? step.order : index + 1;
      scheduleByOrder.set(order, { ...step, order });
    });
    const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
    const passByOrder = /* @__PURE__ */ new Map();
    passes.forEach((pass) => {
      const order = Number(pass?.order);
      if (Number.isFinite(order)) {
        passByOrder.set(order, pass);
      }
    });
    const orders = /* @__PURE__ */ new Set([
      ...scheduleByOrder.keys(),
      ...passByOrder.keys()
    ]);
    if (!orders.size) {
      const planLength = scheduleList.length;
      for (let i = 1; i <= planLength; i += 1) {
        orders.add(i);
      }
    }
    return Array.from(orders).filter((order) => Number.isFinite(order)).sort((a, b) => a - b).map((order) => {
      const schedule2 = scheduleByOrder.get(order) || {};
      const pass = passByOrder.get(order) || {};
      return {
        order,
        label: schedule2.label || pass.label || `Pass ${order}`,
        action: schedule2.action || pass.action || "",
        due: Number.isFinite(pass?.due) ? pass.due : null,
        completedAt: Number.isFinite(pass?.completedAt) ? pass.completedAt : null,
        offsetMinutes: Number.isFinite(schedule2?.offsetMinutes) ? schedule2.offsetMinutes : null,
        anchor: schedule2.anchor || pass.anchor || null
      };
    });
  }
  function createPassChipDisplay(info, now = Date.now(), options = {}) {
    const { onOpen, onToggle } = options || {};
    const chip = document.createElement("div");
    chip.className = "lecture-pass-chip";
    chip.style.setProperty("--chip-accent", passAccent(info?.order));
    chip.dataset.passOrder = String(info?.order ?? "");
    chip.setAttribute("role", "button");
    chip.tabIndex = 0;
    const passTitle = info?.action || info?.label || `Pass ${info?.order ?? ""}`;
    const statusWrap = document.createElement("div");
    statusWrap.className = "lecture-pass-chip-status";
    const toggleButton = document.createElement("button");
    toggleButton.type = "button";
    toggleButton.className = "lecture-pass-chip-toggle";
    toggleButton.setAttribute("aria-label", `Mark ${passTitle} as complete`);
    toggleButton.setAttribute("aria-pressed", "false");
    const toggleIcon = document.createElement("span");
    toggleIcon.className = "lecture-pass-chip-toggle-icon";
    toggleIcon.setAttribute("aria-hidden", "true");
    toggleIcon.textContent = "\u2713";
    toggleButton.append(toggleIcon);
    statusWrap.appendChild(toggleButton);
    chip.appendChild(statusWrap);
    const body = document.createElement("div");
    body.className = "lecture-pass-chip-body";
    chip.appendChild(body);
    const header = document.createElement("div");
    header.className = "lecture-pass-chip-header";
    const badge = document.createElement("span");
    badge.className = "lecture-pass-chip-order";
    badge.textContent = `P${info?.order ?? ""}`;
    header.appendChild(badge);
    const defaultLabel = `Pass ${info?.order ?? ""}`.trim();
    const primaryText = (info?.action || "").trim();
    const fallbackText = (info?.label || "").trim();
    const functionText = primaryText || (fallbackText && fallbackText !== defaultLabel ? fallbackText : "");
    if (functionText) {
      const functionEl = document.createElement("span");
      functionEl.className = "lecture-pass-chip-function";
      functionEl.textContent = functionText;
      header.appendChild(functionEl);
    }
    body.appendChild(header);
    const timing = document.createElement("div");
    timing.className = "lecture-pass-chip-due";
    timing.textContent = Number.isFinite(info?.due) ? formatPassDueTimestamp(info.due) : "No scheduled date";
    body.appendChild(timing);
    const countdown = document.createElement("div");
    countdown.className = "lecture-pass-chip-countdown";
    countdown.textContent = describePassCountdown(info?.due, now);
    body.appendChild(countdown);
    const isInitiallyComplete = Number.isFinite(info?.completedAt);
    const dueTimestamp = Number.isFinite(info?.due) ? info.due : null;
    function applyCompletionState(complete) {
      chip.classList.toggle("is-complete", complete);
      const overdue = !complete && Number.isFinite(dueTimestamp) && dueTimestamp < now;
      chip.classList.toggle("is-overdue", overdue);
      toggleButton.classList.toggle("is-active", complete);
      toggleButton.setAttribute("aria-pressed", complete ? "true" : "false");
      toggleButton.setAttribute(
        "aria-label",
        complete ? `Mark ${passTitle} as incomplete` : `Mark ${passTitle} as complete`
      );
    }
    applyCompletionState(isInitiallyComplete);
    let busy = false;
    toggleButton.addEventListener("click", async (event) => {
      if (event && typeof event.stopPropagation === "function") {
        event.stopPropagation();
      }
      if (typeof onToggle !== "function") return;
      if (busy) return;
      const desired = !toggleButton.classList.contains("is-active");
      busy = true;
      chip.classList.add("is-pending");
      toggleButton.disabled = true;
      try {
        await onToggle(desired);
        applyCompletionState(desired);
      } catch (err) {
        console.error(err);
      }
      chip.classList.remove("is-pending");
      toggleButton.disabled = false;
      busy = false;
    });
    chip.addEventListener("click", (event) => {
      const target = event?.target || null;
      const toggleTarget = (isElementLike(target) && typeof target.closest === "function" ? target.closest(".lecture-pass-chip-toggle") : null) || (isElementLike(target?.parentElement) && typeof target.parentElement.closest === "function" ? target.parentElement.closest(".lecture-pass-chip-toggle") : null);
      if (toggleTarget) {
        return;
      }
      if (typeof onOpen === "function") {
        onOpen();
      }
    });
    chip.addEventListener("keydown", (event) => {
      if (event.target !== chip) return;
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        if (typeof onOpen === "function") onOpen();
      }
    });
    return chip;
  }
  function defaultActionForIndex2(index) {
    if (!Array.isArray(LECTURE_PASS_ACTIONS) || !LECTURE_PASS_ACTIONS.length) return "";
    const normalized2 = index % LECTURE_PASS_ACTIONS.length;
    return LECTURE_PASS_ACTIONS[Math.max(0, normalized2)];
  }
  function baseSchedule2(plan) {
    if (plan && Array.isArray(plan.schedule)) {
      return plan.schedule;
    }
    return DEFAULT_PASS_PLAN.schedule;
  }
  function computeDefaultGap2(schedule2) {
    if (!Array.isArray(schedule2) || schedule2.length < 2) return DAY_MINUTES3;
    const deltas = [];
    for (let i = 1; i < schedule2.length; i += 1) {
      const prev = Number(schedule2[i - 1]?.offsetMinutes);
      const current = Number(schedule2[i]?.offsetMinutes);
      if (Number.isFinite(prev) && Number.isFinite(current)) {
        const delta = current - prev;
        if (delta > 0) deltas.push(delta);
      }
    }
    return deltas.length ? deltas[deltas.length - 1] : DAY_MINUTES3;
  }
  function fallbackAnchor2(index) {
    if (index === 0) return "today";
    if (index === 1) return "tomorrow";
    return "upcoming";
  }
  function buildScheduleTemplate2(plan, count) {
    const template = baseSchedule2(plan);
    const numericCount = Number(count);
    const safeCount = Math.max(0, Number.isFinite(numericCount) ? Math.round(numericCount) : 0);
    const defaultGap = computeDefaultGap2(template);
    const schedule2 = [];
    for (let i = 0; i < safeCount; i += 1) {
      const source = template[i] || {};
      const previous = schedule2[i - 1] || null;
      const order = i + 1;
      const offset = Number.isFinite(source.offsetMinutes) ? source.offsetMinutes : previous ? previous.offsetMinutes + defaultGap : i === 0 ? 0 : defaultGap * i;
      const anchor = typeof source.anchor === "string" && source.anchor.trim() ? source.anchor.trim() : previous?.anchor || fallbackAnchor2(i);
      const label = typeof source.label === "string" && source.label.trim() ? source.label.trim() : `Pass ${order}`;
      const action = typeof source.action === "string" && source.action.trim() ? source.action.trim() : defaultActionForIndex2(i);
      schedule2.push({
        order,
        offsetMinutes: offset,
        anchor,
        label,
        action
      });
    }
    return schedule2;
  }
  function adjustPassConfigs2(current, count, plan) {
    const template = buildScheduleTemplate2(plan || { schedule: current }, count);
    const byOrder = /* @__PURE__ */ new Map();
    (Array.isArray(current) ? current : []).forEach((entry) => {
      const order = Number(entry?.order);
      if (Number.isFinite(order) && !byOrder.has(order)) {
        byOrder.set(order, entry);
      }
    });
    return template.map((step, index) => {
      const existing = byOrder.get(step.order) || current[index] || {};
      const action = typeof existing?.action === "string" && existing.action.trim() ? existing.action.trim() : step.action;
      const offsetMinutes = Number.isFinite(existing?.offsetMinutes) ? Math.max(0, Math.round(existing.offsetMinutes)) : step.offsetMinutes;
      const anchor = typeof existing?.anchor === "string" && existing.anchor.trim() ? existing.anchor.trim() : step.anchor;
      const label = typeof existing?.label === "string" && existing.label.trim() ? existing.label.trim() : step.label;
      return { ...step, action, offsetMinutes, anchor, label };
    });
  }
  function clampPassCount2(value) {
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) return 0;
    return Math.min(MAX_PASS_COUNT2, Math.max(0, Math.round(parsed)));
  }
  function buildPassPlanPayload2(passConfigs, existingPlan) {
    const planId = existingPlan && typeof existingPlan.id === "string" && existingPlan.id.trim() ? existingPlan.id.trim() : "custom";
    return {
      id: planId,
      schedule: passConfigs.map((config, index) => {
        const order = index + 1;
        const label = typeof config.label === "string" && config.label.trim() ? config.label.trim() : `Pass ${order}`;
        const offset = Number.isFinite(config.offsetMinutes) ? Math.max(0, Math.round(config.offsetMinutes)) : index === 0 ? 0 : (passConfigs[index - 1]?.offsetMinutes ?? 0) + DAY_MINUTES3;
        const anchor = typeof config.anchor === "string" && config.anchor.trim() ? config.anchor.trim() : fallbackAnchor2(index);
        const action = typeof config.action === "string" && config.action.trim() ? config.action.trim() : defaultActionForIndex2(index);
        return {
          order,
          label,
          offsetMinutes: offset,
          anchor,
          action
        };
      })
    };
  }
  function formatPassPlan2(plan) {
    if (!plan || !Array.isArray(plan.schedule) || !plan.schedule.length) {
      return "No passes scheduled";
    }
    const steps = plan.schedule.slice().sort((a, b) => (a?.order ?? 0) - (b?.order ?? 0)).map((step) => {
      const action = typeof step?.action === "string" && step.action.trim() ? step.action.trim() : `Pass ${step?.order ?? ""}`;
      const offset = formatOffset2(step?.offsetMinutes ?? 0);
      return `${action} \u2022 ${offset}`;
    });
    return `Plan: ${steps.join(", ")}`;
  }
  function formatOverdue(due, now) {
    const diffMs = Math.max(0, now - due);
    if (diffMs < 60 * 1e3) return "due now";
    const minutes = Math.round(diffMs / (60 * 1e3));
    if (minutes < 60) return `${minutes} min overdue`;
    const hours = Math.round(minutes / 60);
    if (hours < 24) return `${hours} hr overdue`;
    const days = Math.round(hours / 24);
    return `${days} day${days === 1 ? "" : "s"} overdue`;
  }
  function formatTimeUntil(due, now) {
    const diffMs = Math.max(0, due - now);
    if (diffMs < 60 * 1e3) return "due in under a minute";
    const minutes = Math.round(diffMs / (60 * 1e3));
    if (minutes < 60) return `due in ${minutes} min`;
    const hours = Math.round(minutes / 60);
    if (hours < 24) return `due in ${hours} hr`;
    const days = Math.round(hours / 24);
    return `due in ${days} day${days === 1 ? "" : "s"}`;
  }
  function formatNextDueDescriptor(nextDueAt, now = Date.now()) {
    if (nextDueAt == null || !Number.isFinite(nextDueAt)) return "Not scheduled";
    const date = new Date(nextDueAt);
    const dateLabel = new Intl.DateTimeFormat(void 0, {
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit"
    }).format(date);
    const relative = nextDueAt <= now ? formatOverdue(nextDueAt, now) : formatTimeUntil(nextDueAt, now);
    return `${dateLabel} \u2022 ${relative}`;
  }
  function renderEmptyState() {
    const empty = document.createElement("div");
    empty.className = "lectures-empty";
    empty.textContent = "No lectures found. Use \u201CAdd Lecture\u201D to create one.";
    return empty;
  }
  function computeLecturePassStats(lecture) {
    const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
    const scheduled = Array.isArray(lecture?.passPlan?.schedule) ? lecture.passPlan.schedule.length : 0;
    const statusTotal = Number.isFinite(lecture?.status?.totalPasses) ? lecture.status.totalPasses : 0;
    let planned = Math.max(scheduled, passes.length, statusTotal);
    const completedFromPasses = passes.filter((pass) => Number.isFinite(pass?.completedAt)).length;
    const completedFromStatus = Number.isFinite(lecture?.status?.completedPasses) ? lecture.status.completedPasses : 0;
    const completed = Math.max(completedFromPasses, completedFromStatus);
    planned = Math.max(planned, completed);
    const remaining = Math.max(0, planned - completed);
    return { planned, completed, remaining };
  }
  function summarizeLectures(lectures) {
    return (Array.isArray(lectures) ? lectures : []).reduce(
      (acc, lecture) => {
        const stats = computeLecturePassStats(lecture);
        acc.totalPasses += stats.planned;
        acc.completed += stats.completed;
        return acc;
      },
      { totalPasses: 0, completed: 0 }
    );
  }
  function formatPassTotals(summary) {
    if (!summary || summary.totalPasses === 0) return "0 passes planned";
    return `${summary.completed}/${summary.totalPasses} passes complete`;
  }
  function labelForWeekKey(weekKey) {
    if (weekKey === "__no-week") return "No week assigned";
    return formatWeekLabel3(weekKey);
  }
  function normalizeLectureSort(value) {
    if (!value) return { ...DEFAULT_LECTURE_SORT };
    let field = DEFAULT_LECTURE_SORT.field;
    let direction = DEFAULT_LECTURE_SORT.direction;
    if (typeof value === "string") {
      const parts = value.split("-");
      if (parts.length === 1) {
        field = parts[0];
      } else if (parts.length >= 2) {
        [field, direction] = parts;
      }
    } else if (typeof value === "object") {
      if (typeof value.field === "string") field = value.field;
      if (value.direction === "asc" || value.direction === "desc") direction = value.direction;
    }
    if (!LECTURE_SORT_FIELDS.includes(field)) {
      field = DEFAULT_LECTURE_SORT.field;
    }
    direction = direction === "desc" ? "desc" : "asc";
    return { field, direction };
  }
  function formatLectureSortValue(sort) {
    const normalized2 = normalizeLectureSort(sort);
    return `${normalized2.field}-${normalized2.direction}`;
  }
  function describeSortDirectionLabel(field, direction) {
    if (field === "created") {
      return direction === "desc" ? "Newest first" : "Oldest first";
    }
    if (field === "nextDue") {
      return direction === "asc" ? "Soonest due" : "Latest due";
    }
    return direction === "desc" ? "High \u2192 Low" : "Low \u2192 High";
  }
  function describeSortDirectionAria(field, direction) {
    if (field === "created") {
      return `Toggle sort order (currently ${direction === "desc" ? "newest first" : "oldest first"})`;
    }
    if (field === "nextDue") {
      return `Toggle sort order (currently ${direction === "asc" ? "soonest due first" : "latest due first"})`;
    }
    return `Toggle sort order (currently ${direction === "asc" ? "ascending" : "descending"})`;
  }
  function sortLecturesForDisplay(lectures, sort) {
    const { field, direction } = normalizeLectureSort(sort);
    const multiplier = direction === "desc" ? -1 : 1;
    const list = Array.isArray(lectures) ? lectures.slice() : [];
    return list.sort((a, b) => {
      let comparison = 0;
      if (field === "created") {
        const aValue = Number(a?.createdAt);
        const bValue = Number(b?.createdAt);
        const aRank = Number.isFinite(aValue) ? aValue : direction === "desc" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        const bRank = Number.isFinite(bValue) ? bValue : direction === "desc" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        if (aRank !== bRank) {
          comparison = aRank < bRank ? -1 : 1;
        }
      } else if (field === "nextDue") {
        const aDue = resolveNextDueAt(a);
        const bDue = resolveNextDueAt(b);
        const aRank = Number.isFinite(aDue) ? aDue : direction === "desc" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        const bRank = Number.isFinite(bDue) ? bDue : direction === "desc" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        if (aRank !== bRank) {
          comparison = aRank < bRank ? -1 : 1;
        }
      } else {
        const posA = Number(a?.position);
        const posB = Number(b?.position);
        const posAValid = Number.isFinite(posA);
        const posBValid = Number.isFinite(posB);
        if (posAValid && posBValid && posA !== posB) {
          comparison = posA < posB ? -1 : 1;
        } else if (posAValid && !posBValid) {
          comparison = -1;
        } else if (!posAValid && posBValid) {
          comparison = 1;
        }
      }
      if (comparison !== 0) {
        return comparison * multiplier;
      }
      const nameA = (a?.name || "").toLowerCase();
      const nameB = (b?.name || "").toLowerCase();
      if (nameA && nameB && nameA !== nameB) return nameA.localeCompare(nameB);
      const idA = Number(a?.id);
      const idB = Number(b?.id);
      if (Number.isFinite(idA) && Number.isFinite(idB) && idA !== idB) return idA - idB;
      return 0;
    });
  }
  function resolveNextDueAt(lecture) {
    if (Number.isFinite(lecture?.nextDueAt)) return lecture.nextDueAt;
    const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
    for (const pass of passes) {
      if (!pass || Number.isFinite(pass?.completedAt)) continue;
      if (Number.isFinite(pass?.due)) return pass.due;
    }
    return null;
  }
  function getLectureState(lecture, stats) {
    if (lecture?.status?.state) return lecture.status.state;
    const counts = stats || computeLecturePassStats(lecture);
    if (!counts.planned) return "unscheduled";
    if (counts.completed >= counts.planned) return "complete";
    if (counts.completed > 0) return "in-progress";
    return "pending";
  }
  function renderLectureWeekRow(lecture, onEdit, onDelete, onEditPass, onTogglePass, onExport, now = Date.now()) {
    const row = document.createElement("div");
    row.className = "lecture-row";
    row.dataset.lectureRow = "true";
    row.dataset.lectureId = String(lecture.id);
    row.dataset.blockId = String(lecture.blockId ?? "");
    const stats = computeLecturePassStats(lecture);
    const stateLabel = getLectureState(lecture, stats);
    const overviewCell = document.createElement("div");
    overviewCell.className = "lecture-col lecture-overview lecture-col-lecture";
    const header = document.createElement("div");
    header.className = "lecture-overview-header";
    const name = document.createElement("span");
    name.className = "lecture-name";
    name.textContent = lecture.name || `Lecture ${lecture.id}`;
    header.appendChild(name);
    const status = document.createElement("span");
    status.className = "lecture-status-pill";
    status.dataset.status = stateLabel;
    status.textContent = stateLabel;
    header.appendChild(status);
    overviewCell.appendChild(header);
    const nextDueLine = document.createElement("div");
    nextDueLine.className = "lecture-next-indicator";
    nextDueLine.textContent = formatNextDueDescriptor(resolveNextDueAt(lecture), now);
    overviewCell.appendChild(nextDueLine);
    if (lecture.position != null) {
      const position = document.createElement("div");
      position.className = "lecture-overview-position";
      position.textContent = `Position: ${lecture.position}`;
      overviewCell.appendChild(position);
    }
    const tags = Array.isArray(lecture.tags) ? lecture.tags.filter(Boolean) : [];
    if (tags.length) {
      const tagList = document.createElement("div");
      tagList.className = "lecture-tags";
      tags.forEach((tag) => {
        const chip = document.createElement("span");
        chip.className = "lecture-tag";
        chip.textContent = tag;
        tagList.appendChild(chip);
      });
      overviewCell.appendChild(tagList);
    }
    const metrics = document.createElement("div");
    metrics.className = "lecture-overview-metrics";
    const completedMetric = document.createElement("span");
    completedMetric.className = "lecture-metric lecture-metric-complete";
    completedMetric.textContent = `${stats.completed} complete`;
    metrics.appendChild(completedMetric);
    const remainingMetric = document.createElement("span");
    remainingMetric.className = "lecture-metric lecture-metric-remaining";
    remainingMetric.textContent = `${stats.remaining} remaining`;
    metrics.appendChild(remainingMetric);
    overviewCell.appendChild(metrics);
    row.appendChild(overviewCell);
    const passesCell = document.createElement("div");
    passesCell.className = "lecture-col lecture-passes-cell lecture-col-passes";
    const passScroller = document.createElement("div");
    passScroller.className = "lecture-pass-scroller";
    const passList = buildPassDisplayList(lecture);
    if (!passList.length) {
      const empty = document.createElement("div");
      empty.className = "lecture-pass-empty";
      empty.textContent = "No passes planned";
      passScroller.appendChild(empty);
    } else {
      passList.forEach((info) => {
        const chip = createPassChipDisplay(info, now, {
          onOpen: () => onEditPass(lecture, info),
          onToggle: (checked) => onTogglePass?.(lecture, info, checked)
        });
        passScroller.appendChild(chip);
      });
    }
    passesCell.appendChild(passScroller);
    row.appendChild(passesCell);
    const actions = document.createElement("div");
    actions.className = "lecture-col lecture-actions lecture-col-actions";
    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "btn secondary";
    editBtn.dataset.action = "edit-lecture";
    editBtn.textContent = "Edit";
    editBtn.addEventListener("click", () => onEdit(lecture));
    actions.appendChild(editBtn);
    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.className = "btn secondary";
    deleteBtn.dataset.action = "delete-lecture";
    deleteBtn.textContent = "Delete";
    deleteBtn.addEventListener("click", () => onDelete(lecture));
    actions.appendChild(deleteBtn);
    if (typeof onExport === "function") {
      const exportBtn = document.createElement("button");
      exportBtn.type = "button";
      exportBtn.className = "btn secondary";
      exportBtn.dataset.action = "export-lecture";
      exportBtn.textContent = "Export";
      exportBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        onExport(lecture);
      });
      actions.appendChild(exportBtn);
    }
    row.appendChild(actions);
    return row;
  }
  function renderLectureTable(blocks, lectures, filters, onEdit, onDelete, onEditPass, onTogglePass, onExportLecture, onExportWeek, onExportBlock) {
    const card = document.createElement("section");
    card.className = "card lectures-card";
    const title = document.createElement("h2");
    title.textContent = "Lectures";
    card.appendChild(title);
    if (!lectures.length) {
      card.appendChild(renderEmptyState());
      return card;
    }
    const blockMap = /* @__PURE__ */ new Map();
    blocks.forEach((block) => {
      if (!block || block.blockId == null) return;
      blockMap.set(String(block.blockId), block);
    });
    const orderMap = buildBlockOrderMap(blocks);
    const blockFilter = String(filters?.blockId || "").trim();
    const weekFilter = String(filters?.week || "").trim();
    const now = Date.now();
    const sortConfig = normalizeLectureSort(filters?.sort);
    const openSnapshot = Number(filters?.openSnapshot) || 0;
    const storedBlockKeys = new Set(
      Array.isArray(filters?.openBlocks) ? filters.openBlocks.map((value) => String(value ?? "")) : []
    );
    const storedWeekKeys = new Set(
      Array.isArray(filters?.openWeeks) ? filters.openWeeks.map((value) => String(value ?? "")) : []
    );
    const useStoredExpansion = openSnapshot > 0;
    function composeWeekKey(blockKey, weekValue) {
      return `${String(blockKey)}::${String(weekValue)}`;
    }
    function recordBlockOpen(blockKey, isOpen) {
      const key = String(blockKey ?? "");
      const lectureState = ensureLectureState();
      const openBlocks = new Set(
        Array.isArray(lectureState.openBlocks) ? lectureState.openBlocks.map((value) => String(value ?? "")) : []
      );
      const openWeeks = new Set(
        Array.isArray(lectureState.openWeeks) ? lectureState.openWeeks.map((value) => String(value ?? "")) : []
      );
      if (isOpen) {
        openBlocks.add(key);
      } else {
        openBlocks.delete(key);
        Array.from(openWeeks).forEach((entry) => {
          if (entry.startsWith(`${key}::`)) {
            openWeeks.delete(entry);
          }
        });
      }
      setLecturesState({
        openBlocks: Array.from(openBlocks),
        openWeeks: Array.from(openWeeks),
        openSnapshot: Date.now()
      });
    }
    function recordWeekOpen(blockKey, weekValue, isOpen) {
      const composite = composeWeekKey(blockKey, weekValue);
      const lectureState = ensureLectureState();
      const openWeeks = new Set(
        Array.isArray(lectureState.openWeeks) ? lectureState.openWeeks.map((value) => String(value ?? "")) : []
      );
      if (isOpen) {
        openWeeks.add(composite);
      } else {
        openWeeks.delete(composite);
      }
      setLecturesState({
        openWeeks: Array.from(openWeeks),
        openSnapshot: Date.now()
      });
    }
    const blockGroups = /* @__PURE__ */ new Map();
    lectures.forEach((lecture) => {
      if (!lecture) return;
      const rawBlockId = lecture.blockId == null || lecture.blockId === "" ? "" : lecture.blockId;
      const key = rawBlockId === "" ? "__no-block" : String(rawBlockId);
      if (!blockGroups.has(key)) {
        const blockInfo = blockMap.get(String(rawBlockId));
        const fallbackTitle = rawBlockId === "" ? "No block assigned" : `Block ${rawBlockId}`;
        blockGroups.set(key, {
          key,
          blockId: rawBlockId,
          block: blockInfo || { blockId: rawBlockId, title: blockInfo?.title || fallbackTitle, color: blockInfo?.color || null },
          lectures: [],
          weeks: /* @__PURE__ */ new Map()
        });
      }
      const group = blockGroups.get(key);
      group.lectures.push(lecture);
      const weekKey = lecture.week == null || lecture.week === "" ? "__no-week" : String(lecture.week);
      if (!group.weeks.has(weekKey)) {
        group.weeks.set(weekKey, []);
      }
      group.weeks.get(weekKey).push(lecture);
    });
    const groupsContainer = document.createElement("div");
    groupsContainer.className = "lectures-groups";
    const blockFragment = document.createDocumentFragment();
    const sortedGroups = Array.from(blockGroups.values()).sort((a, b) => {
      const ao = orderMap.has(a.blockId) ? orderMap.get(a.blockId) : orderMap.get(String(a.blockId)) ?? Number.POSITIVE_INFINITY;
      const bo = orderMap.has(b.blockId) ? orderMap.get(b.blockId) : orderMap.get(String(b.blockId)) ?? Number.POSITIVE_INFINITY;
      if (ao !== bo) return ao - bo;
      const nameA = (a.block?.title || a.block?.name || String(a.blockId || "") || "").toLowerCase();
      const nameB = (b.block?.title || b.block?.name || String(b.blockId || "") || "").toLowerCase();
      return nameA.localeCompare(nameB);
    });
    const activeBlockId = findActiveBlockId(blocks);
    const latestBlockId = resolveLatestBlockId(blocks);
    const defaultBlockId = (() => {
      if (blockFilter) return blockFilter;
      if (latestBlockId) return latestBlockId;
      if (activeBlockId) return activeBlockId;
      const firstWithId = sortedGroups.find((group) => {
        const id = String(group.blockId ?? "");
        return id !== "";
      });
      if (firstWithId) return String(firstWithId.blockId ?? "");
      return String(sortedGroups[0]?.blockId ?? "");
    })();
    sortedGroups.forEach((group) => {
      const blockDetails = document.createElement("details");
      blockDetails.className = "lectures-block-group";
      const normalizedGroupId = String(group.blockId ?? "");
      const blockKey = String(group.key ?? normalizedGroupId);
      blockDetails.dataset.blockId = normalizedGroupId;
      blockDetails.dataset.blockKey = blockKey;
      const blockInfo = group.block || {};
      if (blockInfo.color) {
        blockDetails.style.setProperty("--block-accent", blockInfo.color);
        blockDetails.classList.add("has-accent");
      }
      const blockSummary = document.createElement("summary");
      blockSummary.className = "lectures-block-summary";
      const blockTitle = document.createElement("span");
      blockTitle.className = "lectures-block-name";
      blockTitle.textContent = blockInfo.title || blockInfo.name || (group.blockId ? `Block ${group.blockId}` : "No block assigned");
      blockSummary.appendChild(blockTitle);
      const blockStats = summarizeLectures(group.lectures);
      const blockCounts = document.createElement("span");
      blockCounts.className = "lectures-block-counts";
      const lectureCount = group.lectures.length;
      const lectureLabel = `${lectureCount} lecture${lectureCount === 1 ? "" : "s"}`;
      blockCounts.textContent = `${lectureLabel} \u2022 ${formatPassTotals(blockStats)}`;
      blockSummary.appendChild(blockCounts);
      if (typeof onExportBlock === "function") {
        const blockExportBtn = document.createElement("button");
        blockExportBtn.type = "button";
        blockExportBtn.className = "btn secondary lectures-block-export";
        blockExportBtn.textContent = "Export block";
        blockExportBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          onExportBlock(group.block);
        });
        blockSummary.appendChild(blockExportBtn);
      }
      blockDetails.appendChild(blockSummary);
      const weekWrapper = document.createElement("div");
      weekWrapper.className = "lectures-week-groups";
      const weekFragment = document.createDocumentFragment();
      const sortedWeeks = Array.from(group.weeks.entries()).sort((aEntry, bEntry) => {
        const [aKey] = aEntry;
        const [bKey] = bEntry;
        if (aKey === "__no-week" && bKey === "__no-week") return 0;
        if (aKey === "__no-week") return 1;
        if (bKey === "__no-week") return -1;
        const aNum = Number(aKey);
        const bNum = Number(bKey);
        if (Number.isFinite(aNum) && Number.isFinite(bNum) && aNum !== bNum) return bNum - aNum;
        if (Number.isFinite(aNum) && !Number.isFinite(bNum)) return -1;
        if (!Number.isFinite(aNum) && Number.isFinite(bNum)) return 1;
        return String(bKey).localeCompare(String(aKey));
      });
      const matchesWeekFilter = weekFilter ? sortedWeeks.some(([weekKey]) => {
        const normalized2 = weekKey === "__no-week" ? "" : String(weekKey);
        return normalized2 === weekFilter;
      }) : false;
      let shouldOpenBlock;
      if (blockFilter) {
        shouldOpenBlock = blockFilter === normalizedGroupId;
      } else if (matchesWeekFilter) {
        shouldOpenBlock = true;
      } else if (useStoredExpansion) {
        shouldOpenBlock = storedBlockKeys.has(blockKey);
      } else {
        shouldOpenBlock = defaultBlockId === normalizedGroupId;
      }
      blockDetails.open = shouldOpenBlock;
      blockDetails.addEventListener("toggle", () => {
        recordBlockOpen(blockKey, blockDetails.open);
      });
      sortedWeeks.forEach(([weekKey, weekLectures], index) => {
        const weekDetails = document.createElement("details");
        weekDetails.className = "lectures-week-group";
        const normalizedWeek = weekKey === "__no-week" ? "" : String(weekKey);
        weekDetails.dataset.week = normalizedWeek;
        weekDetails.dataset.weekValue = normalizedWeek;
        weekDetails.dataset.weekKey = String(weekKey ?? "");
        const compositeKey = composeWeekKey(blockKey, normalizedWeek);
        let shouldOpenWeek;
        if (weekFilter) {
          shouldOpenWeek = weekFilter === normalizedWeek;
        } else if (useStoredExpansion) {
          shouldOpenWeek = storedWeekKeys.has(compositeKey);
        } else {
          shouldOpenWeek = blockDetails.open && index === 0;
        }
        weekDetails.open = blockDetails.open && shouldOpenWeek;
        weekDetails.addEventListener("toggle", () => {
          recordWeekOpen(blockKey, normalizedWeek, weekDetails.open);
        });
        const weekSummary = document.createElement("summary");
        weekSummary.className = "lectures-week-summary";
        const weekTitle = document.createElement("span");
        weekTitle.className = "lectures-week-title";
        weekTitle.textContent = labelForWeekKey(weekKey);
        weekSummary.appendChild(weekTitle);
        const weekStats = summarizeLectures(weekLectures);
        const weekCounts = document.createElement("span");
        weekCounts.className = "lectures-week-counts";
        const weekLectureCount = weekLectures.length;
        const weekLectureLabel = `${weekLectureCount} lecture${weekLectureCount === 1 ? "" : "s"}`;
        weekCounts.textContent = `${weekLectureLabel} \u2022 ${formatPassTotals(weekStats)}`;
        weekSummary.appendChild(weekCounts);
        if (typeof onExportWeek === "function") {
          const weekExportBtn = document.createElement("button");
          weekExportBtn.type = "button";
          weekExportBtn.className = "btn secondary lectures-week-export";
          weekExportBtn.textContent = "Export week";
          weekExportBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            const targetWeek = weekLectures[0]?.week == null ? null : weekLectures[0].week;
            onExportWeek(group.block, targetWeek);
          });
          weekSummary.appendChild(weekExportBtn);
        }
        weekDetails.appendChild(weekSummary);
        const weekBody = document.createElement("div");
        weekBody.className = "lectures-week-body";
        const list = document.createElement("div");
        list.className = "lectures-week-list";
        const rowsFragment = document.createDocumentFragment();
        const headerRow = document.createElement("div");
        headerRow.className = "lecture-row lecture-row-header";
        [
          { label: "Lecture", className: "lecture-col-lecture" },
          { label: "Passes", className: "lecture-col-passes" },
          { label: "Actions", className: "lecture-col-actions" }
        ].forEach((column) => {
          const cell = document.createElement("div");
          cell.className = `lecture-col ${column.className}`;
          cell.textContent = column.label;
          headerRow.appendChild(cell);
        });
        rowsFragment.appendChild(headerRow);
        sortLecturesForDisplay(weekLectures, sortConfig).forEach((entry) => {
          const row = renderLectureWeekRow(
            entry,
            onEdit,
            onDelete,
            onEditPass,
            onTogglePass,
            (lecture) => onExportLecture?.(lecture, group.block),
            now
          );
          rowsFragment.appendChild(row);
        });
        list.appendChild(rowsFragment);
        weekBody.appendChild(list);
        weekDetails.appendChild(weekBody);
        weekFragment.appendChild(weekDetails);
      });
      weekWrapper.appendChild(weekFragment);
      blockDetails.appendChild(weekWrapper);
      blockFragment.appendChild(blockDetails);
    });
    groupsContainer.appendChild(blockFragment);
    card.appendChild(groupsContainer);
    return card;
  }
  function uniqueStatusValues(lectures) {
    const set = /* @__PURE__ */ new Set();
    lectures.forEach((lecture) => {
      const state2 = lecture?.status?.state;
      if (state2) set.add(state2);
    });
    return Array.from(set);
  }
  function uniqueWeeks(lectures) {
    const set = /* @__PURE__ */ new Set();
    lectures.forEach((lecture) => {
      if (lecture.week == null) {
        set.add("");
      } else {
        set.add(String(lecture.week));
      }
    });
    return Array.from(set).filter((value) => value !== "").map((value) => Number(value)).filter((value) => Number.isFinite(value)).sort((a, b) => a - b);
  }
  function applyFilters(lectures, filters) {
    const query = (filters.query || "").trim().toLowerCase();
    const blockId = (filters.blockId || "").trim();
    const weekFilter = (filters.week || "").trim();
    const statusFilter = (filters.status || "").trim();
    const tagFilter = (filters.tag || "").trim().toLowerCase();
    return lectures.filter((lecture) => {
      if (blockId && String(lecture.blockId) !== blockId) return false;
      if (weekFilter) {
        const week = lecture.week == null ? "" : String(lecture.week);
        if (week !== weekFilter) return false;
      }
      if (statusFilter && statusFilter !== "all") {
        const statusState = lecture?.status?.state || "";
        if (statusState !== statusFilter) return false;
      }
      if (query) {
        const actionTerms = Array.isArray(lecture?.passPlan?.schedule) ? lecture.passPlan.schedule.map((step) => step?.action || "") : [];
        const haystacks = [lecture.name, lecture.id != null ? String(lecture.id) : "", lecture.blockId, ...actionTerms];
        if (!haystacks.some((value) => String(value || "").toLowerCase().includes(query))) {
          return false;
        }
      }
      if (tagFilter) {
        const tags = Array.isArray(lecture.tags) ? lecture.tags : [];
        if (!tags.some((tag) => String(tag).toLowerCase().includes(tagFilter))) {
          return false;
        }
      }
      return true;
    });
  }
  function buildToolbar(blocks, lectures, lectureLists, redraw, defaultPassPlan, onImport) {
    const filters = ensureLectureState();
    const toolbar = document.createElement("div");
    toolbar.className = "lectures-toolbar";
    toolbar.setAttribute("role", "toolbar");
    toolbar.setAttribute("aria-label", "Lecture filters");
    const filterGroup = document.createElement("div");
    filterGroup.className = "lectures-toolbar-filters";
    toolbar.appendChild(filterGroup);
    const actionsGroup = document.createElement("div");
    actionsGroup.className = "lectures-toolbar-actions";
    toolbar.appendChild(actionsGroup);
    if (typeof onImport === "function") {
      const importInput = document.createElement("input");
      importInput.type = "file";
      importInput.accept = "application/json";
      importInput.style.display = "none";
      const importBtn = document.createElement("button");
      importBtn.type = "button";
      importBtn.className = "btn secondary lectures-import-btn";
      importBtn.textContent = "Import bundle";
      importBtn.addEventListener("click", () => importInput.click());
      importInput.addEventListener("change", async () => {
        const file = importInput.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          await onImport(json);
        } catch (err) {
          console.error("Failed to import lecture bundle", err);
          alert("Import failed.");
        } finally {
          importInput.value = "";
        }
      });
      actionsGroup.appendChild(importBtn);
      toolbar.appendChild(importInput);
    }
    const search = document.createElement("input");
    search.type = "search";
    search.className = "input lectures-search";
    search.placeholder = "Search lectures";
    search.value = filters.query || "";
    const debouncedSearch = debounce((value) => {
      setLecturesState({ query: value });
      redraw();
    }, 150);
    search.addEventListener("input", (e) => {
      debouncedSearch(e.target.value);
    });
    filterGroup.appendChild(search);
    const sortState = normalizeLectureSort(filters.sort);
    const sortControls = document.createElement("div");
    sortControls.className = "lectures-sort-controls";
    const sortSelect = document.createElement("select");
    sortSelect.className = "input lectures-sort-field";
    sortSelect.setAttribute("aria-label", "Sort lectures");
    [
      { value: "position", label: "Manual order" },
      { value: "created", label: "Date added" },
      { value: "nextDue", label: "Next pass due" }
    ].forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = option.label;
      sortSelect.appendChild(opt);
    });
    sortSelect.value = sortState.field;
    sortSelect.addEventListener("change", () => {
      sortState.field = sortSelect.value;
      syncDirectionControl();
      setLecturesState({ sort: formatLectureSortValue(sortState) });
      redraw();
    });
    sortControls.appendChild(sortSelect);
    const directionBtn = document.createElement("button");
    directionBtn.type = "button";
    directionBtn.className = "btn secondary lectures-sort-direction";
    directionBtn.addEventListener("click", () => {
      sortState.direction = sortState.direction === "asc" ? "desc" : "asc";
      syncDirectionControl();
      setLecturesState({ sort: formatLectureSortValue(sortState) });
      redraw();
    });
    function syncDirectionControl() {
      directionBtn.dataset.direction = sortState.direction;
      directionBtn.textContent = describeSortDirectionLabel(sortState.field, sortState.direction);
      directionBtn.setAttribute("aria-label", describeSortDirectionAria(sortState.field, sortState.direction));
    }
    syncDirectionControl();
    sortControls.appendChild(directionBtn);
    filterGroup.appendChild(sortControls);
    const blockSelect = document.createElement("select");
    blockSelect.className = "input lectures-filter";
    blockSelect.setAttribute("aria-label", "Filter by block");
    const allBlocksOption = document.createElement("option");
    allBlocksOption.value = "";
    allBlocksOption.textContent = "All blocks";
    blockSelect.appendChild(allBlocksOption);
    blocks.forEach((block) => {
      if (!block || !block.blockId) return;
      const option = document.createElement("option");
      option.value = block.blockId;
      option.textContent = block.title || block.blockId;
      blockSelect.appendChild(option);
    });
    blockSelect.value = filters.blockId || "";
    blockSelect.addEventListener("change", () => {
      setLecturesState({ blockId: blockSelect.value });
      redraw();
    });
    filterGroup.appendChild(blockSelect);
    const weekSelect = document.createElement("select");
    weekSelect.className = "input lectures-filter";
    weekSelect.setAttribute("aria-label", "Filter by week");
    const allWeeksOption = document.createElement("option");
    allWeeksOption.value = "";
    allWeeksOption.textContent = "All weeks";
    weekSelect.appendChild(allWeeksOption);
    uniqueWeeks(lectures).forEach((week) => {
      const option = document.createElement("option");
      option.value = String(week);
      option.textContent = `Week ${week}`;
      weekSelect.appendChild(option);
    });
    weekSelect.value = normalizeWeekValue(filters.week);
    weekSelect.addEventListener("change", () => {
      setLecturesState({ week: weekSelect.value });
      redraw();
    });
    filterGroup.appendChild(weekSelect);
    const statuses = uniqueStatusValues(lectures);
    if (statuses.length) {
      const statusSelect = document.createElement("select");
      statusSelect.className = "input lectures-filter";
      statusSelect.setAttribute("aria-label", "Filter by status");
      const allStatusOption = document.createElement("option");
      allStatusOption.value = "all";
      allStatusOption.textContent = "All statuses";
      statusSelect.appendChild(allStatusOption);
      statuses.sort().forEach((status) => {
        const option = document.createElement("option");
        option.value = status;
        option.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        statusSelect.appendChild(option);
      });
      statusSelect.value = filters.status || "all";
      statusSelect.addEventListener("change", () => {
        setLecturesState({ status: statusSelect.value });
        redraw();
      });
      filterGroup.appendChild(statusSelect);
    }
    const tagSearch = document.createElement("input");
    tagSearch.type = "search";
    tagSearch.className = "input lectures-tag-search";
    tagSearch.placeholder = "Filter tags";
    tagSearch.value = filters.tag || "";
    const debouncedTag = debounce((value) => {
      setLecturesState({ tag: value });
      redraw();
    }, 150);
    tagSearch.addEventListener("input", (e) => {
      debouncedTag(e.target.value);
    });
    filterGroup.appendChild(tagSearch);
    const addBlockSelect = document.createElement("select");
    addBlockSelect.className = "input lectures-add-select";
    addBlockSelect.setAttribute("aria-label", "Select block for new lecture");
    const addBlockPlaceholder = document.createElement("option");
    addBlockPlaceholder.value = "";
    addBlockPlaceholder.textContent = "Select block";
    addBlockSelect.appendChild(addBlockPlaceholder);
    blocks.forEach((block) => {
      if (!block || !block.blockId) return;
      const option = document.createElement("option");
      option.value = block.blockId;
      option.textContent = block.title || block.blockId;
      addBlockSelect.appendChild(option);
    });
    const defaultAddBlock = blocks.find((block) => block.blockId === filters.blockId)?.blockId || (blocks[0]?.blockId ?? "");
    if (defaultAddBlock) {
      addBlockSelect.value = defaultAddBlock;
    }
    actionsGroup.appendChild(addBlockSelect);
    const addWeekSelect = document.createElement("select");
    addWeekSelect.className = "input lectures-add-select";
    addWeekSelect.setAttribute("aria-label", "Select week for new lecture");
    actionsGroup.appendChild(addWeekSelect);
    let addWeekValue = normalizeWeekValue(filters.week);
    const updateAddWeekSelect = () => {
      const blockId = addBlockSelect.value;
      const blankLabel = blockId ? "No week" : "Select block first";
      populateWeekSelect(addWeekSelect, blockId, blocks, lectureLists, {
        selectedValue: addWeekValue,
        blankLabel
      });
      addWeekSelect.disabled = !blockId;
      addWeekValue = addWeekSelect.value;
    };
    updateAddWeekSelect();
    addBlockSelect.addEventListener("change", () => {
      if (filters.blockId && filters.blockId === addBlockSelect.value) {
        addWeekValue = normalizeWeekValue(filters.week);
      } else {
        addWeekValue = "";
      }
      updateAddWeekSelect();
      syncAddButtonState();
    });
    addWeekSelect.addEventListener("change", () => {
      addWeekValue = addWeekSelect.value;
    });
    const addBtn = document.createElement("button");
    addBtn.type = "button";
    addBtn.className = "btn primary add-lecture-btn";
    addBtn.dataset.action = "add-lecture";
    const addIcon = document.createElement("span");
    addIcon.className = "add-lecture-btn-icon";
    addIcon.setAttribute("aria-hidden", "true");
    addIcon.innerHTML = '<svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" focusable="false" aria-hidden="true"><path d="M8 3v10M3 8h10"/></svg>';
    const addLabel = document.createElement("span");
    addLabel.className = "add-lecture-btn-label";
    addLabel.textContent = "Add lecture";
    addBtn.append(addIcon, addLabel);
    actionsGroup.appendChild(addBtn);
    const syncAddButtonState = () => {
      addBtn.disabled = !blocks.length || !addBlockSelect.value;
    };
    syncAddButtonState();
    addBtn.addEventListener("click", () => {
      const selectedBlockId = addBlockSelect.value || (blocks[0]?.blockId || "");
      if (!selectedBlockId) return;
      const passPlanTemplate = clonePassPlan(
        defaultPassPlan && Array.isArray(defaultPassPlan.schedule) ? defaultPassPlan : void 0
      );
      const rawWeek = addWeekSelect.disabled ? "" : addWeekSelect.value;
      const numericWeek = rawWeek === "" ? "" : Number(rawWeek);
      const selectedWeek = rawWeek === "" || Number.isNaN(numericWeek) ? "" : numericWeek;
      openLectureDialog({
        mode: "create",
        blocks,
        lectureLists,
        defaults: {
          blockId: selectedBlockId,
          name: "",
          week: selectedWeek === "" ? "" : selectedWeek,
          passPlan: passPlanTemplate,
          startAt: Date.now()
        },
        onSubmit: async (payload) => {
          await saveLecture(payload);
          await invalidateBlockCatalog();
          await redraw();
        }
      });
    });
    return toolbar;
  }
  function openLectureDialog(options) {
    const { mode: mode2, blocks, defaults = {}, lectureLists = {}, onSubmit } = options;
    const overlay = document.createElement("div");
    overlay.className = "modal lecture-dialog";
    const card = document.createElement("div");
    card.className = "card";
    const title = document.createElement("h2");
    title.textContent = mode2 === "edit" ? "Edit lecture" : "Add lecture";
    card.appendChild(title);
    const form = document.createElement("form");
    form.className = "lecture-form";
    const basicsSection = document.createElement("section");
    basicsSection.className = "lecture-form-section";
    const basicsTitle = document.createElement("h3");
    basicsTitle.className = "lecture-form-section-title";
    basicsTitle.textContent = "Lecture details";
    basicsSection.appendChild(basicsTitle);
    const basicsGrid = document.createElement("div");
    basicsGrid.className = "lecture-form-grid";
    basicsSection.appendChild(basicsGrid);
    const blockField = document.createElement("label");
    blockField.className = "lecture-form-field";
    blockField.textContent = "Block";
    const blockSelect = document.createElement("select");
    blockSelect.className = "input";
    blockSelect.dataset.field = "blockId";
    blocks.forEach((block) => {
      if (!block || !block.blockId) return;
      const option = document.createElement("option");
      option.value = block.blockId;
      option.textContent = block.title || block.blockId;
      blockSelect.appendChild(option);
    });
    blockSelect.value = defaults.blockId || (blocks[0]?.blockId || "");
    if (mode2 === "edit") {
      blockSelect.disabled = true;
    }
    blockField.appendChild(blockSelect);
    basicsGrid.appendChild(blockField);
    const nameField = document.createElement("label");
    nameField.className = "lecture-form-field";
    nameField.dataset.span = "full";
    nameField.textContent = "Name";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.required = true;
    nameInput.placeholder = "Lecture name";
    nameInput.className = "input";
    nameInput.dataset.field = "name";
    nameInput.value = defaults.name ?? "";
    nameField.appendChild(nameInput);
    basicsGrid.appendChild(nameField);
    const weekField = document.createElement("label");
    weekField.className = "lecture-form-field";
    weekField.textContent = "Week";
    const weekSelect = document.createElement("select");
    weekSelect.className = "input";
    weekSelect.dataset.field = "week";
    weekField.appendChild(weekSelect);
    basicsGrid.appendChild(weekField);
    const defaultStartAt = Number.isFinite(defaults.startAt) ? defaults.startAt : Date.now();
    const startField = document.createElement("label");
    startField.className = "lecture-form-field";
    startField.textContent = "First pass date";
    const startInput = document.createElement("input");
    startInput.type = "date";
    startInput.required = true;
    startInput.className = "input";
    const startValue = formatDateForInput(defaultStartAt);
    startInput.value = startValue || formatDateForInput(Date.now());
    startField.appendChild(startInput);
    const startHint = document.createElement("span");
    startHint.className = "lecture-field-hint";
    startHint.textContent = "Controls when pass 1 begins.";
    startField.appendChild(startHint);
    basicsGrid.appendChild(startField);
    form.appendChild(basicsSection);
    let dialogWeekValue = normalizeWeekValue(defaults.week);
    const updateDialogWeekOptions = () => {
      const blockId = blockSelect.value;
      populateWeekSelect(weekSelect, blockId, blocks, lectureLists, {
        selectedValue: dialogWeekValue,
        blankLabel: "No week"
      });
      dialogWeekValue = weekSelect.value;
    };
    updateDialogWeekOptions();
    weekSelect.addEventListener("change", () => {
      dialogWeekValue = weekSelect.value;
    });
    const planTemplate = defaults.passPlan && Array.isArray(defaults.passPlan.schedule) ? defaults.passPlan : clonePassPlan();
    const initialSchedule = Array.isArray(planTemplate.schedule) ? planTemplate.schedule : [];
    const defaultFallbackCount = Array.isArray(DEFAULT_PASS_PLAN.schedule) ? DEFAULT_PASS_PLAN.schedule.length : 0;
    const initialCount = clampPassCount2(
      initialSchedule.length > 0 ? initialSchedule.length : defaults.passPlan ? 0 : defaultFallbackCount
    );
    let passConfigs = adjustPassConfigs2(initialSchedule, initialCount, planTemplate);
    const planningSection = document.createElement("section");
    planningSection.className = "lecture-form-section";
    const planningTitle = document.createElement("h3");
    planningTitle.className = "lecture-form-section-title";
    planningTitle.textContent = "Pass planning";
    planningSection.appendChild(planningTitle);
    const passCountField = document.createElement("label");
    passCountField.className = "lecture-pass-count";
    passCountField.textContent = "Planned passes";
    const passCountInput = document.createElement("input");
    passCountInput.type = "number";
    passCountInput.min = "0";
    passCountInput.max = String(MAX_PASS_COUNT2);
    passCountInput.className = "input";
    passCountInput.value = String(passConfigs.length);
    passCountField.appendChild(passCountInput);
    const passHelp = document.createElement("span");
    passHelp.className = "lecture-pass-help";
    passHelp.textContent = "Set how many times you want to revisit this lecture.";
    passCountField.appendChild(passHelp);
    planningSection.appendChild(passCountField);
    const passSummary = document.createElement("div");
    passSummary.className = "lecture-pass-summary-line";
    planningSection.appendChild(passSummary);
    const advanced = document.createElement("details");
    advanced.className = "lecture-pass-advanced";
    if (mode2 === "edit") {
      advanced.open = true;
    }
    const advancedSummary = document.createElement("summary");
    advancedSummary.textContent = `Advanced pass settings (${passConfigs.length})`;
    advanced.appendChild(advancedSummary);
    const advancedHint = document.createElement("p");
    advancedHint.className = "lecture-pass-advanced-hint";
    advancedHint.textContent = "Tune the pass function and timing for each pass.";
    advanced.appendChild(advancedHint);
    const passList = document.createElement("div");
    passList.className = "lecture-pass-editor";
    advanced.appendChild(passList);
    planningSection.appendChild(advanced);
    form.appendChild(planningSection);
    function updatePassSummary() {
      if (!passConfigs.length) {
        passSummary.textContent = "No passes scheduled for this lecture.";
      } else {
        const planPreview = buildPassPlanPayload2(passConfigs, planTemplate);
        const previewText = formatPassPlan2(planPreview);
        const cleaned = previewText.startsWith("Plan: ") ? previewText.slice(6) : previewText;
        passSummary.textContent = `${passConfigs.length} pass${passConfigs.length === 1 ? "" : "es"} \u2022 ${cleaned}`;
      }
      advancedSummary.textContent = `Advanced pass settings (${passConfigs.length})`;
    }
    function renderPassEditor() {
      passList.innerHTML = "";
      if (!passConfigs.length) {
        const empty = document.createElement("div");
        empty.className = "lecture-pass-empty";
        empty.textContent = "No passes planned. Increase the pass count to build a schedule.";
        passList.appendChild(empty);
        updatePassSummary();
        return;
      }
      passConfigs.forEach((config, index) => {
        const row = document.createElement("div");
        row.className = "lecture-pass-row";
        const label = document.createElement("div");
        label.className = "lecture-pass-label";
        label.textContent = `Pass ${index + 1}`;
        row.appendChild(label);
        const controls = document.createElement("div");
        controls.className = "lecture-pass-controls";
        const actionField = document.createElement("div");
        actionField.className = "lecture-pass-field";
        const actionLabel = document.createElement("span");
        actionLabel.className = "lecture-pass-field-label";
        actionLabel.textContent = "Pass function";
        actionField.appendChild(actionLabel);
        const select = document.createElement("select");
        select.className = "input lecture-pass-action";
        LECTURE_PASS_ACTIONS.forEach((action) => {
          const option = document.createElement("option");
          option.value = action;
          option.textContent = action;
          select.appendChild(option);
        });
        if (config.action && !LECTURE_PASS_ACTIONS.includes(config.action)) {
          const custom = document.createElement("option");
          custom.value = config.action;
          custom.textContent = config.action;
          select.appendChild(custom);
        }
        select.value = config.action || "";
        select.addEventListener("change", (event) => {
          const value = event.target.value;
          passConfigs[index] = { ...passConfigs[index], action: value };
          updatePassSummary();
        });
        actionField.appendChild(select);
        controls.appendChild(actionField);
        const offsetField = document.createElement("div");
        offsetField.className = "lecture-pass-field lecture-pass-offset-field";
        const offsetLabel = document.createElement("span");
        offsetLabel.className = "lecture-pass-field-label";
        offsetLabel.textContent = "Timing";
        offsetField.appendChild(offsetLabel);
        const offsetInputs = document.createElement("div");
        offsetInputs.className = "lecture-pass-offset-inputs";
        const split = splitOffsetMinutes2(config.offsetMinutes ?? 0);
        const offsetInput = document.createElement("input");
        offsetInput.type = "number";
        offsetInput.min = "0";
        offsetInput.step = "1";
        offsetInput.className = "input lecture-pass-offset-value";
        offsetInput.value = String(split.value);
        const unitSelect = document.createElement("select");
        unitSelect.className = "input lecture-pass-offset-unit";
        OFFSET_UNITS2.forEach((option) => {
          const opt = document.createElement("option");
          opt.value = option.id;
          opt.textContent = option.label;
          unitSelect.appendChild(opt);
        });
        unitSelect.value = split.unit;
        offsetInputs.appendChild(offsetInput);
        offsetInputs.appendChild(unitSelect);
        offsetField.appendChild(offsetInputs);
        const preview = document.createElement("span");
        preview.className = "lecture-pass-offset-preview";
        preview.textContent = formatOffset2(config.offsetMinutes ?? 0);
        offsetField.appendChild(preview);
        function commitOffset() {
          const minutes = combineOffsetValueUnit2(offsetInput.value, unitSelect.value);
          passConfigs[index] = {
            ...passConfigs[index],
            offsetMinutes: minutes
          };
          preview.textContent = formatOffset2(passConfigs[index].offsetMinutes ?? 0);
          updatePassSummary();
        }
        offsetInput.addEventListener("change", () => {
          const numeric = Number(offsetInput.value);
          if (!Number.isFinite(numeric) || numeric < 0) {
            offsetInput.value = "0";
          }
          commitOffset();
        });
        offsetInput.addEventListener("blur", () => {
          const numeric = Math.max(0, Math.round(Number(offsetInput.value) || 0));
          offsetInput.value = String(numeric);
          commitOffset();
        });
        unitSelect.addEventListener("change", commitOffset);
        controls.appendChild(offsetField);
        row.appendChild(controls);
        passList.appendChild(row);
      });
      updatePassSummary();
    }
    renderPassEditor();
    passCountInput.addEventListener("change", () => {
      const next = clampPassCount2(passCountInput.value);
      passCountInput.value = String(next);
      passConfigs = adjustPassConfigs2(passConfigs, next, planTemplate);
      renderPassEditor();
    });
    if (mode2 !== "edit") {
      blockSelect.addEventListener("change", () => {
        dialogWeekValue = "";
        updateDialogWeekOptions();
      });
    }
    const actions = document.createElement("div");
    actions.className = "row lecture-dialog-actions";
    const submitBtn = document.createElement("button");
    submitBtn.type = "submit";
    submitBtn.className = "btn";
    submitBtn.textContent = mode2 === "edit" ? "Save changes" : "Add lecture";
    actions.appendChild(submitBtn);
    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.className = "btn secondary";
    cancelBtn.textContent = "Cancel";
    cancelBtn.addEventListener("click", () => {
      document.body.removeChild(overlay);
    });
    actions.appendChild(cancelBtn);
    form.appendChild(actions);
    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const blockId = blockSelect.value.trim();
      const name = nameInput.value.trim();
      const weekValue = weekSelect.value;
      const week = weekValue === "" ? null : Number(weekValue);
      let startAt = parseDateInputValue(startInput.value);
      if (!Number.isFinite(startAt)) {
        startAt = Date.now();
      }
      if (!blockId || !name || weekValue !== "" && Number.isNaN(week)) {
        return;
      }
      const passPlan = buildPassPlanPayload2(passConfigs, defaults.passPlan);
      const payload = {
        blockId,
        name,
        week,
        passPlan,
        startAt
      };
      if (mode2 === "edit") {
        payload.id = defaults.id;
      }
      await onSubmit(payload);
      if (document.body.contains(overlay)) {
        document.body.removeChild(overlay);
      }
    });
    card.appendChild(form);
    overlay.appendChild(card);
    overlay.addEventListener("click", (event) => {
      if (event.target === overlay) {
        document.body.removeChild(overlay);
      }
    });
    document.body.appendChild(overlay);
    nameInput.focus();
  }
  function handleEdit(lecture, blocks, lectureLists, redraw) {
    openLectureDialog({
      mode: "edit",
      blocks,
      lectureLists,
      defaults: {
        blockId: lecture.blockId,
        id: lecture.id,
        name: lecture.name || "",
        week: lecture.week ?? "",
        passPlan: lecture.passPlan,
        startAt: lecture.startAt
      },
      onSubmit: async (payload) => {
        await saveLecture({
          blockId: lecture.blockId,
          id: lecture.id,
          name: payload.name,
          week: payload.week,
          passPlan: payload.passPlan,
          startAt: payload.startAt
        });
        await invalidateBlockCatalog();
        await redraw();
      }
    });
  }
  function handleDelete(lecture, redraw) {
    (async () => {
      if (!await confirmModal("Delete lecture?")) return;
      await deleteLecture(lecture.blockId, lecture.id);
      await invalidateBlockCatalog();
      await redraw();
    })();
  }
  function passScopeModal(mode2) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.className = "modal lecture-pass-scope-modal";
      const card = document.createElement("div");
      card.className = "card lecture-pass-scope-card";
      const title = document.createElement("h3");
      title.textContent = mode2 === "push" ? "Push pass timing" : "Pull pass timing";
      card.appendChild(title);
      const message = document.createElement("p");
      message.textContent = mode2 === "push" ? "Choose how far the push should ripple." : "Choose how far the pull should ripple.";
      card.appendChild(message);
      const buttons = document.createElement("div");
      buttons.className = "row lecture-pass-scope-buttons";
      const single = document.createElement("button");
      single.className = "btn secondary";
      single.textContent = "Only this pass";
      single.addEventListener("click", () => {
        cleanup("single");
      });
      const cascade = document.createElement("button");
      cascade.className = "btn";
      cascade.textContent = mode2 === "push" ? "This & following" : "This & preceding";
      cascade.addEventListener("click", () => {
        cleanup(mode2 === "push" ? "chain-after" : "chain-before");
      });
      const cancel2 = document.createElement("button");
      cancel2.className = "btn secondary";
      cancel2.textContent = "Cancel";
      cancel2.addEventListener("click", () => {
        cleanup(null);
      });
      buttons.appendChild(single);
      buttons.appendChild(cascade);
      buttons.appendChild(cancel2);
      card.appendChild(buttons);
      overlay.appendChild(card);
      function cleanup(result) {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
        }
        resolve(result);
      }
      overlay.addEventListener("click", (event) => {
        if (event.target === overlay) {
          cleanup(null);
        }
      });
      document.body.appendChild(overlay);
      single.focus();
    });
  }
  function clampOffsetMinutes(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) return 0;
    return Math.max(0, Math.round(numeric));
  }
  function cloneLecturePasses(lecture) {
    return Array.isArray(lecture?.passes) ? lecture.passes.map((pass) => ({ ...pass })) : [];
  }
  async function togglePassCompletion(lecture, order, completed, redraw) {
    if (!lecture || lecture.blockId == null || lecture.id == null) return;
    const targetOrder = Number(order);
    if (!Number.isFinite(targetOrder)) return;
    const passes = cloneLecturePasses(lecture);
    const index = passes.findIndex((pass) => Number(pass?.order) === targetOrder);
    if (index < 0) return;
    const next = { ...passes[index] };
    if (completed) {
      next.completedAt = Number.isFinite(next.completedAt) ? next.completedAt : Date.now();
    } else {
      next.completedAt = null;
    }
    passes[index] = next;
    const status = deriveLectureStatus(passes, lecture.status);
    const nextDueAt = calculateNextDue(passes);
    await saveLecture({
      blockId: lecture.blockId,
      id: lecture.id,
      passes,
      status,
      nextDueAt
    });
    await invalidateBlockCatalog();
    await redraw();
  }
  function normalizeSchedule(plan) {
    return Array.isArray(plan?.schedule) ? plan.schedule.map((step) => ({ ...step })) : [];
  }
  async function updatePassFunction(lecture, order, action, redraw) {
    if (!lecture || lecture.blockId == null || lecture.id == null) return;
    const plan = clonePassPlan(lecture.passPlan || {});
    const schedule2 = normalizeSchedule(plan);
    const step = schedule2.find((entry) => Number(entry?.order) === Number(order));
    if (!step) return;
    step.action = action;
    const passes = cloneLecturePasses(lecture);
    const pass = passes.find((entry) => Number(entry?.order) === Number(order));
    if (pass) {
      pass.action = action;
    }
    plan.schedule = schedule2;
    await saveLecture({
      blockId: lecture.blockId,
      id: lecture.id,
      passPlan: plan,
      passes
    });
    await invalidateBlockCatalog();
    await redraw();
  }
  async function shiftPassTiming(lecture, order, deltaMinutes, scope, redraw) {
    if (!lecture || lecture.blockId == null || lecture.id == null) return;
    if (!Number.isFinite(deltaMinutes) || deltaMinutes === 0) return;
    const plan = clonePassPlan(lecture.passPlan || {});
    const schedule2 = normalizeSchedule(plan);
    if (!schedule2.length) return;
    const targetOrder = Number(order);
    if (!Number.isFinite(targetOrder)) return;
    const affectedOrders = /* @__PURE__ */ new Set();
    schedule2.forEach((step) => {
      const currentOrder = Number(step?.order);
      if (!Number.isFinite(currentOrder)) return;
      if (scope === "chain-after" && currentOrder >= targetOrder) {
        affectedOrders.add(currentOrder);
      } else if (scope === "chain-before" && currentOrder <= targetOrder) {
        affectedOrders.add(currentOrder);
      } else if (!scope || scope === "single") {
        if (currentOrder === targetOrder) affectedOrders.add(currentOrder);
      }
    });
    if (!affectedOrders.size) affectedOrders.add(targetOrder);
    schedule2.forEach((step) => {
      const currentOrder = Number(step?.order);
      if (!Number.isFinite(currentOrder)) return;
      const offset = clampOffsetMinutes(step.offsetMinutes);
      if (affectedOrders.has(currentOrder)) {
        step.offsetMinutes = Math.max(0, offset + deltaMinutes);
      } else {
        step.offsetMinutes = offset;
      }
    });
    const minuteMs = 60 * 1e3;
    const passMap = /* @__PURE__ */ new Map();
    cloneLecturePasses(lecture).forEach((pass) => {
      const orderKey = Number(pass?.order);
      if (Number.isFinite(orderKey) && !passMap.has(orderKey)) {
        passMap.set(orderKey, { ...pass });
      }
    });
    affectedOrders.forEach((orderKey) => {
      const pass = passMap.get(orderKey);
      if (pass && Number.isFinite(pass.due)) {
        const nextDue = Math.max(0, Math.round(pass.due + deltaMinutes * minuteMs));
        pass.due = nextDue;
        passMap.set(orderKey, pass);
      }
    });
    const decorated = schedule2.map((step, index) => ({
      ...step,
      originalOrder: Number(step?.order) || index + 1,
      offsetMinutes: clampOffsetMinutes(step.offsetMinutes)
    }));
    decorated.sort((a, b) => {
      if (a.offsetMinutes !== b.offsetMinutes) return a.offsetMinutes - b.offsetMinutes;
      return a.originalOrder - b.originalOrder;
    });
    const newSchedule = [];
    const reassignedPasses = [];
    decorated.forEach((entry, index) => {
      const newOrder = index + 1;
      const base = { ...entry };
      delete base.originalOrder;
      base.order = newOrder;
      newSchedule.push(base);
      const pass = passMap.get(entry.originalOrder);
      if (pass) {
        pass.order = newOrder;
        reassignedPasses.push(pass);
        passMap.delete(entry.originalOrder);
      }
    });
    passMap.forEach((pass) => {
      reassignedPasses.push(pass);
    });
    reassignedPasses.sort((a, b) => {
      const ao = Number(a?.order) || 0;
      const bo = Number(b?.order) || 0;
      return ao - bo;
    });
    plan.schedule = newSchedule;
    await saveLecture({
      blockId: lecture.blockId,
      id: lecture.id,
      passPlan: plan,
      passes: reassignedPasses
    });
    await invalidateBlockCatalog();
    await redraw();
  }
  function openPassEditDialog({ lecture, passInfo, onUpdateAction, onShift }) {
    const overlay = document.createElement("div");
    overlay.className = "modal lecture-pass-modal";
    const card = document.createElement("div");
    card.className = "card lecture-pass-card";
    const title = document.createElement("h2");
    const passLabel = passInfo?.label || `Pass ${passInfo?.order ?? ""}`;
    title.textContent = `Edit ${passLabel}`;
    card.appendChild(title);
    const meta = document.createElement("div");
    meta.className = "lecture-pass-meta";
    const dateLine = document.createElement("div");
    dateLine.className = "lecture-pass-meta-line";
    dateLine.textContent = Number.isFinite(passInfo?.due) ? formatPassDueTimestamp(passInfo.due) : "No scheduled date";
    meta.appendChild(dateLine);
    const countdownLine = document.createElement("div");
    countdownLine.className = "lecture-pass-meta-line";
    countdownLine.textContent = describePassCountdown(passInfo?.due);
    meta.appendChild(countdownLine);
    card.appendChild(meta);
    const actionField = document.createElement("label");
    actionField.className = "lecture-pass-modal-field";
    actionField.textContent = "Pass function";
    const actionInput = document.createElement("input");
    actionInput.type = "text";
    actionInput.className = "input";
    actionInput.value = passInfo?.action || passInfo?.label || "";
    const actionListId = `pass-action-${lecture.blockId}-${lecture.id}-${passInfo?.order}`.replace(/[^a-zA-Z0-9_-]/g, "-");
    const actionDatalist = document.createElement("datalist");
    actionDatalist.id = actionListId;
    LECTURE_PASS_ACTIONS.forEach((action) => {
      const option = document.createElement("option");
      option.value = action;
      actionDatalist.appendChild(option);
    });
    actionInput.setAttribute("list", actionListId);
    actionField.appendChild(actionInput);
    actionField.appendChild(actionDatalist);
    card.appendChild(actionField);
    const adjustSection = document.createElement("section");
    adjustSection.className = "lecture-pass-adjust";
    const adjustTitle = document.createElement("h3");
    adjustTitle.textContent = "Adjust timing";
    adjustSection.appendChild(adjustTitle);
    const adjustControls = document.createElement("div");
    adjustControls.className = "lecture-pass-adjust-controls";
    const amountInput = document.createElement("input");
    amountInput.type = "number";
    amountInput.className = "input lecture-pass-adjust-value";
    amountInput.min = "0";
    amountInput.step = "1";
    amountInput.value = "1";
    const unitSelect = document.createElement("select");
    unitSelect.className = "input lecture-pass-adjust-unit";
    OFFSET_UNITS2.forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.id;
      opt.textContent = option.label;
      unitSelect.appendChild(opt);
    });
    unitSelect.value = "days";
    adjustControls.appendChild(amountInput);
    adjustControls.appendChild(unitSelect);
    adjustSection.appendChild(adjustControls);
    const adjustButtons = document.createElement("div");
    adjustButtons.className = "lecture-pass-adjust-buttons";
    const pushBtn = document.createElement("button");
    pushBtn.type = "button";
    pushBtn.className = "btn";
    pushBtn.textContent = "Push later";
    const pullBtn = document.createElement("button");
    pullBtn.type = "button";
    pullBtn.className = "btn secondary";
    pullBtn.textContent = "Pull earlier";
    adjustButtons.appendChild(pushBtn);
    adjustButtons.appendChild(pullBtn);
    adjustSection.appendChild(adjustButtons);
    card.appendChild(adjustSection);
    const feedback = document.createElement("div");
    feedback.className = "lecture-pass-feedback";
    card.appendChild(feedback);
    const actions = document.createElement("div");
    actions.className = "row lecture-pass-actions";
    const saveBtn = document.createElement("button");
    saveBtn.type = "button";
    saveBtn.className = "btn";
    saveBtn.textContent = "Save function";
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "btn secondary";
    closeBtn.textContent = "Close";
    actions.appendChild(saveBtn);
    actions.appendChild(closeBtn);
    card.appendChild(actions);
    overlay.appendChild(card);
    function showMessage(message) {
      feedback.textContent = message || "";
      if (message) {
        feedback.classList.add("is-visible");
      } else {
        feedback.classList.remove("is-visible");
      }
    }
    let busy = false;
    function setBusy(value) {
      busy = Boolean(value);
      saveBtn.disabled = busy;
      pushBtn.disabled = busy;
      pullBtn.disabled = busy;
    }
    function close() {
      if (document.body.contains(overlay)) {
        document.body.removeChild(overlay);
      }
    }
    async function handleSave() {
      if (busy) return;
      const value = actionInput.value.trim();
      if (!value) {
        showMessage("Enter a function for this pass.");
        return;
      }
      setBusy(true);
      try {
        await onUpdateAction(value);
        close();
      } catch (err) {
        console.error(err);
        showMessage("Failed to update pass. Please try again.");
        setBusy(false);
      }
    }
    async function handleShift(mode2) {
      if (busy) return;
      const amount = Number(amountInput.value);
      if (!Number.isFinite(amount) || amount <= 0) {
        showMessage("Enter how much to adjust the pass by.");
        return;
      }
      const minutes = combineOffsetValueUnit2(amount, unitSelect.value);
      if (!Number.isFinite(minutes) || minutes <= 0) {
        showMessage("Pick a timing greater than zero.");
        return;
      }
      const scope = await passScopeModal(mode2);
      if (!scope) return;
      const delta = mode2 === "push" ? minutes : -minutes;
      setBusy(true);
      try {
        await onShift(delta, scope);
        close();
      } catch (err) {
        console.error(err);
        showMessage("Failed to adjust timing. Please try again.");
        setBusy(false);
      }
    }
    saveBtn.addEventListener("click", handleSave);
    pushBtn.addEventListener("click", () => handleShift("push"));
    pullBtn.addEventListener("click", () => handleShift("pull"));
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", (event) => {
      if (event.target === overlay) {
        close();
      }
    });
    document.body.appendChild(overlay);
    actionInput.focus();
  }
  function handlePassEdit(lecture, passInfo, redraw) {
    if (!lecture || !passInfo) return;
    openPassEditDialog({
      lecture,
      passInfo,
      onUpdateAction: (action) => updatePassFunction(lecture, passInfo.order, action, redraw),
      onShift: (delta, scope) => shiftPassTiming(lecture, passInfo.order, delta, scope, redraw)
    });
  }
  async function handlePassToggle(lecture, passInfo, checked, redraw) {
    if (!lecture || !passInfo) return;
    await togglePassCompletion(lecture, passInfo.order, checked, redraw);
  }
  async function renderLectures(root2, redraw) {
    const [catalog, settings] = await Promise.all([
      loadBlockCatalog(),
      getSettings()
    ]);
    setPassColorPalette(settings?.plannerDefaults?.passColors);
    const filters = ensureLectureState();
    const blocks = (catalog.blocks || []).map((block) => ({ ...block }));
    const allLectures = collectLectures(catalog);
    const lectureLists = catalog.lectureLists || {};
    const filtered = applyFilters(allLectures, filters);
    const totalPasses = filtered.reduce((sum, lecture) => {
      const passes = Array.isArray(lecture?.passPlan?.passes) ? lecture.passPlan.passes.length : Array.isArray(lecture?.passes) ? lecture.passes.length : 0;
      return sum + passes;
    }, 0);
    reportListComplexity("lectures", { items: filtered.length, extras: Math.round(totalPasses * 0.75) });
    const defaultPassPlan = plannerDefaultsToPassPlan(settings?.plannerDefaults);
    const requestRedraw = () => {
      captureLectureViewState();
      return redraw();
    };
    const resolveBlockLabel = (blockInfo) => {
      if (!blockInfo) return "block";
      return blockInfo.title || blockInfo.name || blockInfo.blockId || "block";
    };
    async function handleExportLectureBundle(lecture, blockInfo) {
      if (!lecture || lecture.id == null) {
        alert("Lecture information is incomplete.");
        return;
      }
      const normalizedBlockId = String(lecture.blockId ?? "").trim();
      if (!normalizedBlockId) {
        alert("Assign this lecture to a block before exporting.");
        return;
      }
      try {
        const bundle = await exportLectureTransfer(normalizedBlockId, lecture.id);
        const blockLabel = resolveBlockLabel(blockInfo) || lecture.blockId || "block";
        const lectureLabel = lecture.name || `lecture-${lecture.id}`;
        const filename = `lecture-${slugify(blockLabel)}-${slugify(lectureLabel)}.json`;
        downloadJson(bundle, filename);
      } catch (err) {
        console.error("Failed to export lecture bundle", err);
        alert("Failed to export lecture.");
      }
    }
    async function handleExportWeekBundle(blockInfo, weekValue) {
      const blockId = blockInfo?.blockId;
      if (!blockId) {
        alert("Assign the lectures to a block before exporting a week.");
        return;
      }
      try {
        const bundle = await exportWeekTransfer(blockId, weekValue == null ? null : weekValue);
        const blockLabel = resolveBlockLabel(blockInfo);
        const weekSlug = weekValue == null ? "no-week" : `week-${weekValue}`;
        const filename = `week-${slugify(blockLabel)}-${slugify(weekSlug)}.json`;
        downloadJson(bundle, filename);
      } catch (err) {
        console.error("Failed to export week bundle", err);
        alert("Failed to export week.");
      }
    }
    async function handleExportBlockBundle(blockInfo) {
      const blockId = blockInfo?.blockId;
      if (!blockId) {
        alert("Select a block to export.");
        return;
      }
      try {
        const bundle = await exportBlockTransfer(blockId);
        const filename = `block-${slugify(resolveBlockLabel(blockInfo))}.json`;
        downloadJson(bundle, filename);
      } catch (err) {
        console.error("Failed to export block bundle", err);
        alert("Failed to export block.");
      }
    }
    async function handleImportBundle(payload) {
      try {
        const conflicts = detectImportConflicts(payload, catalog);
        let strategy = "merge";
        if (conflicts.hasConflicts) {
          const choice = await promptImportStrategy(conflicts);
          if (!choice) {
            return;
          }
          strategy = choice;
        }
        await importLectureTransfer(payload, { strategy });
        await invalidateBlockCatalog();
        await requestRedraw();
        alert("Import complete.");
      } catch (err) {
        console.error("Failed to import lecture bundle", err);
        alert("Import failed.");
      }
    }
    const layout = document.createElement("div");
    layout.className = "lectures-view";
    const toolbar = buildToolbar(
      blocks,
      allLectures,
      lectureLists,
      requestRedraw,
      defaultPassPlan,
      handleImportBundle
    );
    const table = renderLectureTable(
      blocks,
      filtered,
      filters,
      (lecture) => handleEdit(lecture, blocks, lectureLists, requestRedraw),
      (lecture) => handleDelete(lecture, requestRedraw),
      (lecture, pass) => handlePassEdit(lecture, pass, requestRedraw),
      (lecture, pass, checked) => handlePassToggle(lecture, pass, checked, requestRedraw),
      (lecture, blockInfo) => handleExportLectureBundle(lecture, blockInfo || blocks.find((block) => block.blockId === lecture.blockId)),
      (blockInfo, weekValue) => handleExportWeekBundle(blockInfo, weekValue),
      (blockInfo) => handleExportBlockBundle(blockInfo)
    );
    const layoutFragment = document.createDocumentFragment();
    layoutFragment.appendChild(toolbar);
    layoutFragment.appendChild(table);
    layout.appendChild(layoutFragment);
    if (typeof root2.replaceChildren === "function") {
      root2.replaceChildren(layout);
    } else {
      root2.innerHTML = "";
      root2.appendChild(layout);
    }
    const scroller = findLectureScrollContainer(layout);
    requestAnimationFrame(() => {
      const target = Number(filters?.scrollTop);
      if (Number.isFinite(target) && target > 0) {
        if (scroller && typeof scroller.scrollTo === "function") {
          scroller.scrollTo({ top: target, left: 0, behavior: "auto" });
        } else if (scroller && "scrollTop" in scroller) {
          scroller.scrollTop = target;
        } else {
          window.scrollTo({ top: target, left: 0, behavior: "auto" });
        }
      }
    });
  }
  var OFFSET_UNITS2, PASS_DUE_FORMAT, PASS_TIME_FORMAT, MAX_PASS_COUNT2, DAY_MINUTES3, LECTURE_SORT_FIELDS, DEFAULT_LECTURE_SORT;
  var init_lectures2 = __esm({
    "js/ui/components/lectures.js"() {
      init_state();
      init_block_catalog();
      init_storage();
      init_transfers();
      init_confirm();
      init_utils();
      init_scheduler();
      init_actions();
      init_pass_colors();
      init_performance();
      OFFSET_UNITS2 = [
        { id: "minutes", label: "minutes", minutes: 1 },
        { id: "hours", label: "hours", minutes: 60 },
        { id: "days", label: "days", minutes: 60 * 24 },
        { id: "weeks", label: "weeks", minutes: 60 * 24 * 7 }
      ];
      PASS_DUE_FORMAT = new Intl.DateTimeFormat(void 0, {
        month: "short",
        day: "numeric"
      });
      PASS_TIME_FORMAT = new Intl.DateTimeFormat(void 0, {
        hour: "numeric",
        minute: "2-digit"
      });
      MAX_PASS_COUNT2 = 20;
      DAY_MINUTES3 = 24 * 60;
      LECTURE_SORT_FIELDS = ["position", "created", "nextDue"];
      DEFAULT_LECTURE_SORT = { field: "position", direction: "asc" };
    }
  });

  // js/review/order.js
  function normalizeReviewCategory(value) {
    if (value === "review" || value === "learning") {
      return value;
    }
    if (value === "new") return "new";
    return "new";
  }
  function normalizeReviewOrdering(raw) {
    if (!raw || typeof raw !== "object") {
      return { ...DEFAULT_REVIEW_ORDERING };
    }
    const mode2 = raw.mode === "mixed" ? "mixed" : "prioritized";
    let priorities = Array.isArray(raw.priorities) ? raw.priorities : [];
    priorities = priorities.map((value) => typeof value === "string" ? value.trim().toLowerCase() : "").filter((value) => REVIEW_ORDER_CATEGORIES.includes(value));
    const unique = [];
    priorities.forEach((value) => {
      if (!unique.includes(value)) unique.push(value);
    });
    if (!unique.length) {
      unique.push(...DEFAULT_REVIEW_ORDERING.priorities);
    }
    return {
      mode: mode2,
      priorities: unique
    };
  }
  function shuffleEntries(entries) {
    const copy = Array.from(entries);
    for (let i = copy.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      const tmp = copy[i];
      copy[i] = copy[j];
      copy[j] = tmp;
    }
    return copy;
  }
  function orderReviewEntries(entries, ordering = DEFAULT_REVIEW_ORDERING) {
    if (!Array.isArray(entries) || !entries.length) return Array.isArray(entries) ? Array.from(entries) : [];
    const normalized2 = normalizeReviewOrdering(ordering);
    if (normalized2.mode === "mixed") {
      return shuffleEntries(entries);
    }
    const priorities = normalized2.priorities;
    const categoryOrder = [...priorities];
    REVIEW_ORDER_CATEGORIES.forEach((category) => {
      if (!categoryOrder.includes(category)) categoryOrder.push(category);
    });
    const buckets = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const rawCategory = entry && typeof entry === "object" ? entry.category : null;
      const normalizedCategory = normalizeReviewCategory(rawCategory);
      if (!buckets.has(normalizedCategory)) {
        buckets.set(normalizedCategory, []);
      }
      buckets.get(normalizedCategory).push(entry);
    });
    const ordered = [];
    categoryOrder.forEach((category) => {
      const list = buckets.get(category);
      if (list && list.length) {
        ordered.push(...list);
        buckets.delete(category);
      }
    });
    buckets.forEach((list) => {
      ordered.push(...list);
    });
    return ordered;
  }
  function ensureReviewOrdering(raw) {
    return normalizeReviewOrdering(raw);
  }
  var REVIEW_ORDER_CATEGORIES, DEFAULT_REVIEW_ORDERING;
  var init_order = __esm({
    "js/review/order.js"() {
      REVIEW_ORDER_CATEGORIES = ["review", "learning", "new"];
      DEFAULT_REVIEW_ORDERING = Object.freeze({
        mode: "prioritized",
        priorities: ["review", "learning", "new"]
      });
    }
  });

  // js/ui/components/review.js
  var review_exports = {};
  __export(review_exports, {
    buildReviewHierarchy: () => buildReviewHierarchy,
    ensureBlockAccentMap: () => ensureBlockAccentMap,
    ensureBlockTitleMap: () => ensureBlockTitleMap,
    openEntryManager: () => openEntryManager,
    renderReview: () => renderReview
  });
  function ensureBlockTitleMap(blocks) {
    if (blockTitleCache) return blockTitleCache;
    const map = /* @__PURE__ */ new Map();
    blocks.forEach((block) => {
      if (!block || !block.blockId) return;
      map.set(block.blockId, block.title || block.blockId);
    });
    blockTitleCache = map;
    return map;
  }
  function ensureBlockAccentMap(blocks = []) {
    const map = /* @__PURE__ */ new Map();
    let fallbackIndex = 0;
    blocks.forEach((block) => {
      if (!block || !block.blockId) return;
      const raw = typeof block.color === "string" && block.color.trim() ? block.color.trim() : DEFAULT_BLOCK_ACCENTS[fallbackIndex % DEFAULT_BLOCK_ACCENTS.length];
      fallbackIndex += 1;
      map.set(block.blockId, raw);
    });
    map.set("__unassigned", map.get("__unassigned") || "#64748b");
    return map;
  }
  function titleOf2(item) {
    return item?.name || item?.concept || "Untitled";
  }
  function formatOverdue2(due, now) {
    const diffMs = Math.max(0, now - due);
    if (diffMs < 60 * 1e3) return "due now";
    const minutes = Math.round(diffMs / (60 * 1e3));
    if (minutes < 60) return `${minutes} min overdue`;
    const hours = Math.round(minutes / 60);
    if (hours < 24) return `${hours} hr overdue`;
    const days = Math.round(hours / 24);
    return `${days} day${days === 1 ? "" : "s"} overdue`;
  }
  function formatIntervalMinutes(minutes) {
    if (!Number.isFinite(minutes) || minutes <= 0) return "\u2014";
    if (minutes < 60) return `${minutes} min`;
    const hours = Math.round(minutes / 60);
    if (hours < 24) return `${hours} hr`;
    const days = Math.round(hours / 24);
    if (days < 30) return `${days} day${days === 1 ? "" : "s"}`;
    const months = Math.round(days / 30);
    if (months < 12) return `${months} mo`;
    const years = Math.round(months / 12);
    return `${years} yr`;
  }
  function createEmptyCounts() {
    return { new: 0, learning: 0, review: 0 };
  }
  function ensureBucketCounts(bucket) {
    if (!bucket.counts) {
      bucket.counts = createEmptyCounts();
    }
    return bucket.counts;
  }
  function addToCounts(counts, category, amount = 1) {
    const key = COUNT_ORDER.includes(category) ? category : "new";
    counts[key] = (counts[key] || 0) + amount;
    return counts;
  }
  function totalCount(counts = {}) {
    return COUNT_ORDER.reduce((sum, key) => {
      const value = Number.isFinite(counts[key]) ? counts[key] : 0;
      return sum + value;
    }, 0);
  }
  function summarizeEntryCounts(entries = []) {
    const totals = createEmptyCounts();
    entries.forEach((entry) => {
      addToCounts(totals, entry?.category, 1);
    });
    return totals;
  }
  function groupEntriesByCategory(entries = []) {
    const groups = /* @__PURE__ */ new Map();
    COUNT_ORDER.forEach((key) => {
      groups.set(key, []);
    });
    entries.forEach((entry) => {
      const key = COUNT_ORDER.includes(entry?.category) ? entry.category : "new";
      groups.get(key).push(entry);
    });
    return groups;
  }
  function createCountPills(counts = {}, { variant = "inline" } = {}) {
    const wrapper = document.createElement("div");
    wrapper.className = `review-counts review-counts-${variant}`;
    COUNT_ORDER.forEach((key) => {
      const config = COUNT_CONFIG[key];
      const pill = document.createElement("span");
      pill.className = `review-count-pill ${config.className}`;
      const value = Number.isFinite(counts[key]) ? counts[key] : 0;
      if (!value) pill.classList.add("is-empty");
      const valueEl = document.createElement("span");
      valueEl.className = "review-count-value";
      valueEl.textContent = value;
      const labelEl = document.createElement("span");
      labelEl.className = "review-count-label";
      labelEl.textContent = config.label;
      pill.appendChild(valueEl);
      pill.appendChild(labelEl);
      wrapper.appendChild(pill);
    });
    return wrapper;
  }
  function entryKey(entry) {
    if (!entry) return null;
    const itemId = entry.itemId || entry.item?.id || entry.item?.slug || entry.item?.name || "item";
    return `${itemId}::${entry.sectionKey}`;
  }
  function describePhase(phase) {
    switch (phase) {
      case "learning":
        return "Learning";
      case "relearning":
        return "Relearning";
      case "review":
        return "Review";
      case "new":
        return "New";
      default:
        return "";
    }
  }
  function buildSessionPayload(entries) {
    return entries.map((entry) => ({
      item: entry.item,
      sections: [entry.sectionKey],
      category: normalizeReviewCategory(entry?.category)
    }));
  }
  function renderEmptyState2(container) {
    const empty = document.createElement("div");
    empty.className = "review-empty";
    empty.textContent = "No cards are due right now. Nice work!";
    container.appendChild(empty);
  }
  function registerEntry(bucket, entry) {
    if (!bucket || !entry) return;
    if (!bucket.entryMap) bucket.entryMap = /* @__PURE__ */ new Map();
    const key = entryKey(entry);
    if (!key || bucket.entryMap.has(key)) return;
    bucket.entryMap.set(key, entry);
    const counts = ensureBucketCounts(bucket);
    addToCounts(counts, entry?.category, 1);
  }
  function finalizeEntries(bucket) {
    if (!bucket) return;
    const entries = bucket.entryMap ? Array.from(bucket.entryMap.values()) : [];
    bucket.entries = entries;
    delete bucket.entryMap;
    ensureBucketCounts(bucket);
  }
  function createBlockOrder(blocks = []) {
    const order = /* @__PURE__ */ new Map();
    if (!Array.isArray(blocks)) return order;
    blocks.forEach((block, index) => {
      if (!block || !block.blockId) return;
      order.set(block.blockId, index);
    });
    return order;
  }
  function resolveEntryRefs(entry, blockTitles, blockAccents) {
    const item = entry?.item || {};
    const lectures = Array.isArray(item.lectures) ? item.lectures.filter(Boolean) : [];
    const blocks = Array.isArray(item.blocks) && item.blocks.length ? item.blocks : [];
    const weeks = Array.isArray(item.weeks) ? item.weeks : [];
    const results = [];
    if (lectures.length) {
      const seen = /* @__PURE__ */ new Set();
      lectures.forEach((lec) => {
        if (!lec) return;
        const blockId = lec.blockId || blocks[0] || UNASSIGNED_BLOCK;
        const lectureId = lec.id != null ? lec.id : UNASSIGNED_LECTURE;
        const rawWeek = lec.week;
        const weekNumber = Number.isFinite(Number(rawWeek)) ? Number(rawWeek) : null;
        const weekId = weekNumber != null ? String(weekNumber) : UNASSIGNED_WEEK;
        const blockTitle = blockTitles.get(blockId) || (blockId === UNASSIGNED_BLOCK ? "Unassigned block" : blockId || "Unassigned block");
        const accent = blockAccents?.get(blockId) || blockAccents?.get(UNASSIGNED_BLOCK) || null;
        const lectureLabel = lec.name ? lec.name : lectureId !== UNASSIGNED_LECTURE ? `Lecture ${lectureId}` : "Unassigned lecture";
        const weekLabel = weekNumber != null ? `Week ${weekNumber}` : "Unassigned week";
        const lectureKey2 = `${blockId || UNASSIGNED_BLOCK}::${lectureId}`;
        const dedupKey = `${blockId || UNASSIGNED_BLOCK}::${weekId}::${lectureKey2}`;
        if (seen.has(dedupKey)) return;
        seen.add(dedupKey);
        results.push({
          blockId: blockId || UNASSIGNED_BLOCK,
          blockTitle,
          accent,
          weekId,
          weekNumber,
          weekLabel,
          lectureKey: lectureKey2,
          lectureId,
          lectureLabel
        });
      });
    } else {
      const blockIds = blocks.length ? blocks : [UNASSIGNED_BLOCK];
      const weekValues = weeks.length ? weeks : [null];
      const seen = /* @__PURE__ */ new Set();
      blockIds.forEach((blockRaw) => {
        const blockId = blockRaw || UNASSIGNED_BLOCK;
        const blockTitle = blockTitles.get(blockId) || (blockId === UNASSIGNED_BLOCK ? "Unassigned block" : blockId || "Unassigned block");
        const accent = blockAccents?.get(blockId) || blockAccents?.get(UNASSIGNED_BLOCK) || null;
        weekValues.forEach((weekValue) => {
          const weekNumber = Number.isFinite(Number(weekValue)) ? Number(weekValue) : null;
          const weekId = weekNumber != null ? String(weekNumber) : UNASSIGNED_WEEK;
          const weekLabel = weekNumber != null ? `Week ${weekNumber}` : "Unassigned week";
          const dedupKey = `${blockId}::${weekId}`;
          if (seen.has(dedupKey)) return;
          seen.add(dedupKey);
          results.push({
            blockId,
            blockTitle,
            accent,
            weekId,
            weekNumber,
            weekLabel,
            lectureKey: `${blockId}::${UNASSIGNED_LECTURE}`,
            lectureId: UNASSIGNED_LECTURE,
            lectureLabel: "Unassigned lecture"
          });
        });
      });
      if (!results.length) {
        results.push({
          blockId: UNASSIGNED_BLOCK,
          blockTitle: "Unassigned block",
          accent: blockAccents?.get(UNASSIGNED_BLOCK) || null,
          weekId: UNASSIGNED_WEEK,
          weekNumber: null,
          weekLabel: "Unassigned week",
          lectureKey: `${UNASSIGNED_BLOCK}::${UNASSIGNED_LECTURE}`,
          lectureId: UNASSIGNED_LECTURE,
          lectureLabel: "Unassigned lecture"
        });
      }
    }
    return results;
  }
  function buildReviewHierarchy(entries, blocks, blockTitles, blockAccents = ensureBlockAccentMap(blocks)) {
    const order = createBlockOrder(blocks);
    const root2 = {
      id: "all",
      title: "All cards",
      blocks: /* @__PURE__ */ new Map(),
      entryMap: /* @__PURE__ */ new Map(),
      counts: createEmptyCounts()
    };
    const blockMap = root2.blocks;
    const contexts = /* @__PURE__ */ new Map();
    const registerContext = (entry, context) => {
      const key = entryKey(entry);
      if (!key) return;
      if (!contexts.has(key)) {
        contexts.set(key, []);
      }
      const list = contexts.get(key);
      const exists = list.some((existing) => existing.blockId === context.blockId && existing.weekId === context.weekId && existing.lectureKey === context.lectureKey);
      if (!exists) {
        list.push(context);
      }
    };
    entries.forEach((entry) => {
      registerEntry(root2, entry);
      const refs = resolveEntryRefs(entry, blockTitles, blockAccents);
      refs.forEach((ref) => {
        const blockId = ref.blockId || UNASSIGNED_BLOCK;
        let blockNode = blockMap.get(blockId);
        if (!blockNode) {
          blockNode = {
            id: blockId,
            title: ref.blockTitle,
            order: order.has(blockId) ? order.get(blockId) : Number.MAX_SAFE_INTEGER,
            weeks: /* @__PURE__ */ new Map(),
            entryMap: /* @__PURE__ */ new Map(),
            accent: blockAccents?.get(blockId) || blockAccents?.get(UNASSIGNED_BLOCK) || null,
            counts: createEmptyCounts()
          };
          blockMap.set(blockId, blockNode);
        }
        registerEntry(blockNode, entry);
        const weekKey = ref.weekId || UNASSIGNED_WEEK;
        let weekNode = blockNode.weeks.get(weekKey);
        if (!weekNode) {
          weekNode = {
            id: weekKey,
            blockId,
            label: ref.weekLabel,
            weekNumber: ref.weekNumber,
            lectures: /* @__PURE__ */ new Map(),
            entryMap: /* @__PURE__ */ new Map(),
            accent: blockNode.accent,
            counts: createEmptyCounts()
          };
          blockNode.weeks.set(weekKey, weekNode);
        }
        registerEntry(weekNode, entry);
        const lectureKey2 = ref.lectureKey || `${blockId}::${UNASSIGNED_LECTURE}`;
        let lectureNode = weekNode.lectures.get(lectureKey2);
        if (!lectureNode) {
          lectureNode = {
            id: lectureKey2,
            blockId,
            weekId: weekKey,
            weekNumber: ref.weekNumber,
            title: ref.lectureLabel,
            lectureId: ref.lectureId,
            entryMap: /* @__PURE__ */ new Map(),
            accent: weekNode.accent,
            counts: createEmptyCounts()
          };
          weekNode.lectures.set(lectureKey2, lectureNode);
        }
        registerEntry(lectureNode, entry);
        registerContext(entry, {
          blockId,
          blockTitle: blockNode.title,
          weekId: weekKey,
          weekLabel: weekNode.label,
          lectureKey: lectureKey2,
          lectureTitle: lectureNode.title,
          accent: lectureNode.accent
        });
      });
    });
    const blocksList = Array.from(blockMap.values());
    blocksList.forEach((blockNode) => {
      const weekList = Array.from(blockNode.weeks.values());
      weekList.forEach((weekNode) => {
        const lectureList = Array.from(weekNode.lectures.values());
        lectureList.forEach((lectureNode) => finalizeEntries(lectureNode));
        lectureList.sort((a, b) => a.title.localeCompare(b.title, void 0, { sensitivity: "base" }));
        weekNode.lectures = lectureList;
        finalizeEntries(weekNode);
      });
      weekList.sort((a, b) => {
        const aNum = a.weekNumber;
        const bNum = b.weekNumber;
        if (Number.isFinite(aNum) && Number.isFinite(bNum)) {
          if (aNum !== bNum) return aNum - bNum;
        } else if (Number.isFinite(aNum)) {
          return -1;
        } else if (Number.isFinite(bNum)) {
          return 1;
        }
        return a.label.localeCompare(b.label, void 0, { sensitivity: "base" });
      });
      blockNode.weeks = weekList;
      finalizeEntries(blockNode);
    });
    blocksList.sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.title.localeCompare(b.title, void 0, { sensitivity: "base" });
    });
    finalizeEntries(root2);
    return {
      root: root2,
      blocks: blocksList,
      contexts,
      accents: blockAccents
    };
  }
  function createNodeActions({
    counts = createEmptyCounts(),
    reviewLabel = "Review",
    onReview,
    onMenu,
    preventToggle = false
  }) {
    const actions = document.createElement("div");
    actions.className = "review-node-actions";
    const total = totalCount(counts);
    const reviewBtn = document.createElement("button");
    reviewBtn.type = "button";
    reviewBtn.className = "btn tertiary review-node-action";
    reviewBtn.textContent = `${reviewLabel}${total ? ` (${total})` : ""}`;
    reviewBtn.disabled = !total;
    reviewBtn.addEventListener("click", (event) => {
      if (preventToggle) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (!total) return;
      if (typeof onReview === "function") onReview();
    });
    actions.appendChild(reviewBtn);
    const menuBtn = document.createElement("button");
    menuBtn.type = "button";
    menuBtn.className = "icon-button review-node-gear";
    menuBtn.innerHTML = "\u2699";
    menuBtn.title = "View entries";
    menuBtn.disabled = !total;
    menuBtn.addEventListener("click", (event) => {
      if (preventToggle) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (typeof onMenu === "function") onMenu();
    });
    actions.appendChild(menuBtn);
    return actions;
  }
  function createCollapsibleNode({
    level = 0,
    title,
    counts = createEmptyCounts(),
    reviewLabel,
    onReview,
    onMenu,
    defaultOpen = false,
    accent = null
  }) {
    const details = document.createElement("details");
    details.className = `review-node review-node-level-${level}`;
    if (defaultOpen) details.open = true;
    if (accent) {
      details.classList.add("has-accent");
      details.style.setProperty("--review-accent", accent);
    }
    const summary = document.createElement("summary");
    summary.className = "review-node-summary";
    const header = document.createElement("div");
    header.className = "review-node-header";
    const titleWrap = document.createElement("div");
    titleWrap.className = "review-node-title-wrap";
    const accentDot = document.createElement("span");
    accentDot.className = "review-node-accent-dot";
    if (accent) {
      accentDot.style.setProperty("--review-accent", accent);
    } else {
      accentDot.hidden = true;
    }
    const titleEl = document.createElement("div");
    titleEl.className = "review-node-title";
    titleEl.textContent = title;
    titleWrap.appendChild(accentDot);
    titleWrap.appendChild(titleEl);
    header.appendChild(titleWrap);
    const meta = document.createElement("div");
    meta.className = "review-node-meta";
    const total = totalCount(counts);
    const countEl = document.createElement("span");
    countEl.className = "review-node-count";
    countEl.textContent = `${total} due`;
    meta.appendChild(countEl);
    const stats = createCountPills(counts, { variant: "compact" });
    stats.classList.add("review-node-stats");
    meta.appendChild(stats);
    header.appendChild(meta);
    summary.appendChild(header);
    const actions = createNodeActions({
      counts,
      reviewLabel,
      onReview,
      onMenu,
      preventToggle: true
    });
    summary.appendChild(actions);
    details.appendChild(summary);
    const content = document.createElement("div");
    content.className = "review-node-content";
    details.appendChild(content);
    return { element: details, content, actions };
  }
  function openEntryManager(hierarchy, {
    title = "Entries",
    now = Date.now(),
    startSession,
    metadata = {},
    focus = {},
    highlightEntryKey = null,
    onChange
  } = {}) {
    const floating = createFloatingWindow({ title, width: 920 });
    const body = floating.body;
    const element = floating.element;
    if (element) element.classList.add("review-entry-window");
    if (!body) {
      console.error("Entry manager window missing body element");
      return floating;
    }
    body.classList.add("review-popup");
    body.classList.add("review-entry-body");
    body.innerHTML = "";
    const contextsMap = hierarchy?.contexts instanceof Map ? hierarchy.contexts : /* @__PURE__ */ new Map();
    const allEntries = Array.isArray(hierarchy?.root?.entries) ? hierarchy.root.entries.slice() : [];
    const sorted = allEntries.slice().sort((a, b) => (a.due || 0) - (b.due || 0));
    const entriesByKey = /* @__PURE__ */ new Map();
    const remainingKeys = /* @__PURE__ */ new Set();
    sorted.forEach((entry) => {
      const key = entryKey(entry);
      if (!key) return;
      entriesByKey.set(key, entry);
      remainingKeys.add(key);
    });
    const status = document.createElement("div");
    status.className = "review-popup-status";
    const updateStatus = (message = "", variant = "") => {
      status.textContent = message;
      status.classList.remove("is-error", "is-success");
      if (variant) {
        status.classList.add(variant === "error" ? "is-error" : "is-success");
      }
    };
    const emptyState = document.createElement("div");
    emptyState.className = "review-popup-empty";
    emptyState.textContent = "No entries available.";
    emptyState.hidden = true;
    const layout = document.createElement("div");
    layout.className = "review-entry-layout";
    body.appendChild(layout);
    const nav = document.createElement("nav");
    nav.className = "review-entry-nav";
    layout.appendChild(nav);
    const navHeader = document.createElement("div");
    navHeader.className = "review-entry-nav-header";
    navHeader.textContent = "Quick nav";
    nav.appendChild(navHeader);
    const navList = document.createElement("div");
    navList.className = "review-entry-nav-tree";
    nav.appendChild(navList);
    const content = document.createElement("div");
    content.className = "review-entry-content";
    layout.appendChild(content);
    const controls = document.createElement("div");
    controls.className = "review-popup-controls review-entry-controls";
    content.appendChild(controls);
    const filterLabel = document.createElement("div");
    filterLabel.className = "review-entry-filter-label";
    controls.appendChild(filterLabel);
    const reviewFilteredBtn = document.createElement("button");
    reviewFilteredBtn.type = "button";
    reviewFilteredBtn.className = "btn";
    controls.appendChild(reviewFilteredBtn);
    const selectAllBtn = document.createElement("button");
    selectAllBtn.type = "button";
    selectAllBtn.className = "btn tertiary";
    selectAllBtn.textContent = "Select all";
    controls.appendChild(selectAllBtn);
    const clearSelectionBtn = document.createElement("button");
    clearSelectionBtn.type = "button";
    clearSelectionBtn.className = "btn tertiary";
    clearSelectionBtn.textContent = "Clear selection";
    controls.appendChild(clearSelectionBtn);
    const table = document.createElement("table");
    table.className = "review-entry-table modern";
    const head = document.createElement("thead");
    const headRow = document.createElement("tr");
    ["Select", "Card", "Part", "Block", "Week", "Lecture", "Stage", "Due", "Time", "Actions"].forEach((label) => {
      const th = document.createElement("th");
      th.textContent = label;
      headRow.appendChild(th);
    });
    head.appendChild(headRow);
    table.appendChild(head);
    const bodyRows = document.createElement("tbody");
    table.appendChild(bodyRows);
    const tableWrap = document.createElement("div");
    tableWrap.className = "review-entry-table-wrap";
    tableWrap.appendChild(table);
    content.appendChild(tableWrap);
    content.appendChild(emptyState);
    content.appendChild(status);
    const selectionBar = document.createElement("div");
    selectionBar.className = "review-selection-bar";
    selectionBar.hidden = true;
    const selectionInfo = document.createElement("div");
    selectionInfo.className = "review-selection-info";
    selectionBar.appendChild(selectionInfo);
    const selectionControls = document.createElement("div");
    selectionControls.className = "review-selection-actions";
    const suspendSelectedBtn = document.createElement("button");
    suspendSelectedBtn.type = "button";
    suspendSelectedBtn.className = "btn secondary";
    suspendSelectedBtn.textContent = "Suspend selected";
    selectionControls.appendChild(suspendSelectedBtn);
    const retireSelectedBtn = document.createElement("button");
    retireSelectedBtn.type = "button";
    retireSelectedBtn.className = "btn danger";
    retireSelectedBtn.textContent = "Retire selected";
    selectionControls.appendChild(retireSelectedBtn);
    selectionBar.appendChild(selectionControls);
    const selectionStatus = document.createElement("div");
    selectionStatus.className = "review-selection-status";
    selectionBar.appendChild(selectionStatus);
    content.appendChild(selectionBar);
    const nodeCounts = /* @__PURE__ */ new Map();
    const navCountElements = /* @__PURE__ */ new Map();
    const navMetadata = /* @__PURE__ */ new Map();
    const navGroupStates = /* @__PURE__ */ new Map();
    const rootNodeKey = "root";
    const blockNodeKey = (blockId) => `block:${blockId}`;
    const weekNodeKey = (blockId, weekId) => `week:${blockId}::${weekId}`;
    const lectureNodeKey = (lectureKey2) => `lecture:${lectureKey2}`;
    const setGroupExpanded = (nodeKey, expanded2 = true) => {
      const state2 = navGroupStates.get(nodeKey);
      if (!state2) return;
      state2.setExpanded(expanded2);
    };
    const openGroup = (nodeKey) => setGroupExpanded(nodeKey, true);
    const clearGroupHighlights = () => {
      navGroupStates.forEach((state2) => {
        state2.group.classList.remove("has-active");
      });
    };
    const markGroupActive = (nodeKey) => {
      const state2 = navGroupStates.get(nodeKey);
      if (!state2) return;
      state2.group.classList.add("has-active");
    };
    const adjustCount = (nodeKey, delta) => {
      const current = nodeCounts.get(nodeKey) || 0;
      const next = Math.max(0, current + delta);
      nodeCounts.set(nodeKey, next);
      const badge = navCountElements.get(nodeKey);
      if (badge) badge.textContent = String(next);
    };
    const getEntryContexts = (entry) => {
      const key = entryKey(entry);
      if (!key) return [];
      const ctx = contextsMap.get(key);
      if (Array.isArray(ctx) && ctx.length) return ctx;
      return [{
        blockId: UNASSIGNED_BLOCK,
        blockTitle: "Unassigned block",
        weekId: UNASSIGNED_WEEK,
        weekLabel: "Unassigned week",
        lectureKey: `${UNASSIGNED_BLOCK}::${UNASSIGNED_LECTURE}`,
        lectureTitle: "Unassigned lecture"
      }];
    };
    sorted.forEach((entry) => {
      const key = entryKey(entry);
      if (!key) return;
      adjustCount(rootNodeKey, 1);
      const contexts = getEntryContexts(entry);
      contexts.forEach((ctx) => {
        adjustCount(blockNodeKey(ctx.blockId), 1);
        adjustCount(weekNodeKey(ctx.blockId, ctx.weekId), 1);
        adjustCount(lectureNodeKey(ctx.lectureKey), 1);
      });
    });
    const rootMeta = { scope: "all", label: "All due cards" };
    navMetadata.set(rootNodeKey, rootMeta);
    const selectedKeys = /* @__PURE__ */ new Set();
    const rowsByKey = /* @__PURE__ */ new Map();
    let cachedDurations2 = null;
    const ensureDurations = async () => {
      if (cachedDurations2) return cachedDurations2;
      cachedDurations2 = await getReviewDurations();
      return cachedDurations2;
    };
    const handleEntryChange = async () => {
      if (typeof onChange === "function") {
        try {
          await onChange();
        } catch (err) {
          console.error(err);
        }
      }
    };
    const matchesFilter = (entry, filter) => {
      if (!filter || filter.scope === "all") return true;
      const contexts = getEntryContexts(entry);
      if (!contexts.length) return filter.scope === "all";
      return contexts.some((ctx) => {
        if (filter.scope === "block") {
          return ctx.blockId === filter.blockId;
        }
        if (filter.scope === "week") {
          return ctx.blockId === filter.blockId && ctx.weekId === filter.weekId;
        }
        if (filter.scope === "lecture") {
          return ctx.lectureKey === filter.lectureKey;
        }
        return true;
      });
    };
    const listFilteredEntries = (filter) => sorted.filter((entry) => {
      const key = entryKey(entry);
      if (!key || !remainingKeys.has(key)) return false;
      return matchesFilter(entry, filter);
    });
    const normalizeFilter2 = (input = {}) => {
      const scope = ["block", "week", "lecture"].includes(input.scope) ? input.scope : "all";
      if (scope === "block") {
        return { scope, blockId: input.blockId ?? UNASSIGNED_BLOCK };
      }
      if (scope === "week") {
        const blockId = input.blockId ?? UNASSIGNED_BLOCK;
        const weekId = input.weekId ?? (input.week != null ? String(input.week) : UNASSIGNED_WEEK);
        return { scope, blockId, weekId };
      }
      if (scope === "lecture") {
        const lectureKey2 = input.lectureKey || input.lectureId || input.lecture || `${UNASSIGNED_BLOCK}::${UNASSIGNED_LECTURE}`;
        return { scope, lectureKey: lectureKey2, blockId: input.blockId ?? UNASSIGNED_BLOCK, weekId: input.weekId ?? (input.week != null ? String(input.week) : UNASSIGNED_WEEK) };
      }
      return { scope: "all" };
    };
    const nodeKeyForFilter = (filter) => {
      if (!filter) return rootNodeKey;
      switch (filter.scope) {
        case "block":
          return blockNodeKey(filter.blockId ?? UNASSIGNED_BLOCK);
        case "week":
          return weekNodeKey(filter.blockId ?? UNASSIGNED_BLOCK, filter.weekId ?? UNASSIGNED_WEEK);
        case "lecture":
          return lectureNodeKey(filter.lectureKey ?? `${UNASSIGNED_BLOCK}::${UNASSIGNED_LECTURE}`);
        default:
          return rootNodeKey;
      }
    };
    const initialFilter = (() => {
      if (focus && focus.scope) {
        return normalizeFilter2(focus);
      }
      if (highlightEntryKey && entriesByKey.has(highlightEntryKey)) {
        const entry = entriesByKey.get(highlightEntryKey);
        const contexts = getEntryContexts(entry);
        if (contexts.length) {
          const ctx = contexts[0];
          return { scope: "lecture", lectureKey: ctx.lectureKey, blockId: ctx.blockId, weekId: ctx.weekId };
        }
      }
      return { scope: "all" };
    })();
    let currentFilter = initialFilter;
    let activeNodeKey = nodeKeyForFilter(currentFilter);
    let currentMetadata = navMetadata.get(activeNodeKey) || metadata || { scope: "all", label: "All due cards" };
    const setActiveNav = (nodeKey) => {
      const prev = navList.querySelector(".review-entry-nav-btn.is-active");
      if (prev) prev.classList.remove("is-active");
      const next = navList.querySelector(`.review-entry-nav-btn[data-node-key="${nodeKey}"]`);
      if (next) next.classList.add("is-active");
      clearGroupHighlights();
      const meta = navMetadata.get(nodeKey);
      if (meta && meta.blockId) {
        const blockKey = blockNodeKey(meta.blockId);
        openGroup(blockKey);
        markGroupActive(blockKey);
        if (meta.weekId) {
          const weekKey = weekNodeKey(meta.blockId, meta.weekId);
          openGroup(weekKey);
          markGroupActive(weekKey);
        }
      }
      if (next) {
        const parentGroup = next.closest(".review-entry-nav-group");
        if (parentGroup) parentGroup.classList.add("has-active");
      }
    };
    const updateFilterLabel = () => {
      filterLabel.textContent = currentMetadata?.label || "All due cards";
    };
    const updateReviewButton = () => {
      const filtered = listFilteredEntries(currentFilter);
      reviewFilteredBtn.textContent = filtered.length ? `Start review (${filtered.length})` : "Start review";
      reviewFilteredBtn.disabled = filtered.length === 0;
      selectAllBtn.disabled = filtered.length === 0;
    };
    const updateSelectionBar = () => {
      const count = selectedKeys.size;
      selectionBar.hidden = count === 0;
      selectionInfo.textContent = `${count} selected`;
      suspendSelectedBtn.disabled = count === 0;
      retireSelectedBtn.disabled = count === 0;
      if (count === 0) {
        selectionStatus.textContent = "";
        selectionStatus.classList.remove("is-error", "is-success");
      }
    };
    const setSelectionStatus = (message = "", variant = "") => {
      selectionStatus.textContent = message;
      selectionStatus.classList.remove("is-error", "is-success");
      if (variant) {
        selectionStatus.classList.add(variant === "error" ? "is-error" : "is-success");
      }
    };
    const clearSelection = () => {
      selectedKeys.clear();
      rowsByKey.forEach((row) => row.classList.remove("is-selected"));
      rowsByKey.forEach((row) => {
        const checkbox = row.querySelector(".review-entry-checkbox");
        if (checkbox) checkbox.checked = false;
      });
      updateSelectionBar();
    };
    const removeEntry = (entry) => {
      const key = entryKey(entry);
      if (!key || !remainingKeys.has(key)) return;
      remainingKeys.delete(key);
      if (selectedKeys.has(key)) selectedKeys.delete(key);
      adjustCount(rootNodeKey, -1);
      const contexts = getEntryContexts(entry);
      contexts.forEach((ctx) => {
        adjustCount(blockNodeKey(ctx.blockId), -1);
        adjustCount(weekNodeKey(ctx.blockId, ctx.weekId), -1);
        adjustCount(lectureNodeKey(ctx.lectureKey), -1);
      });
      rowsByKey.delete(key);
      updateSelectionBar();
    };
    let pendingHighlight = highlightEntryKey;
    const renderTable = () => {
      const filtered = listFilteredEntries(currentFilter);
      bodyRows.innerHTML = "";
      rowsByKey.clear();
      if (!filtered.length) {
        table.hidden = true;
        tableWrap.hidden = true;
        emptyState.hidden = false;
        return;
      }
      table.hidden = false;
      tableWrap.hidden = false;
      emptyState.hidden = true;
      filtered.forEach((entry) => {
        const key = entryKey(entry);
        if (!key) return;
        const row = document.createElement("tr");
        row.className = "review-entry-table-row";
        row.dataset.entryKey = key;
        const contexts = getEntryContexts(entry);
        const blockNames = Array.from(new Set(contexts.map((ctx) => ctx.blockTitle))).join(", ");
        const weekNames = Array.from(new Set(contexts.map((ctx) => ctx.weekLabel))).join(", ");
        const lectureNames = Array.from(new Set(contexts.map((ctx) => ctx.lectureTitle))).join(", ");
        const accent = contexts.length ? contexts[0]?.accent || null : null;
        if (accent) {
          row.classList.add("has-accent");
          row.style.setProperty("--entry-accent", accent);
        }
        const selectCell = document.createElement("td");
        selectCell.className = "review-entry-cell select";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "review-entry-checkbox";
        checkbox.checked = selectedKeys.has(key);
        checkbox.addEventListener("change", (event) => {
          if (event.target.checked) {
            selectedKeys.add(key);
            row.classList.add("is-selected");
          } else {
            selectedKeys.delete(key);
            row.classList.remove("is-selected");
          }
          updateSelectionBar();
        });
        selectCell.appendChild(checkbox);
        row.appendChild(selectCell);
        const titleCell = document.createElement("td");
        titleCell.className = "review-entry-cell title";
        titleCell.textContent = titleOf2(entry.item);
        row.appendChild(titleCell);
        const partCell = document.createElement("td");
        partCell.className = "review-entry-cell part";
        partCell.textContent = getSectionLabel(entry.item, entry.sectionKey);
        row.appendChild(partCell);
        const blockCell = document.createElement("td");
        blockCell.className = "review-entry-cell block";
        blockCell.textContent = blockNames || "\u2014";
        row.appendChild(blockCell);
        const weekCell = document.createElement("td");
        weekCell.className = "review-entry-cell week";
        weekCell.textContent = weekNames || "\u2014";
        row.appendChild(weekCell);
        const lectureCell = document.createElement("td");
        lectureCell.className = "review-entry-cell lecture";
        lectureCell.textContent = lectureNames || "\u2014";
        row.appendChild(lectureCell);
        const phaseCell = document.createElement("td");
        phaseCell.className = "review-entry-cell phase";
        const phaseLabel = describePhase(entry.phase);
        const interval = entry?.state?.interval;
        const intervalText = Number.isFinite(interval) && interval > 0 ? `Last interval \u2022 ${formatIntervalMinutes(interval)}` : "";
        let hasPhaseContent = false;
        if (phaseLabel) {
          const phaseChip = document.createElement("span");
          phaseChip.className = "review-entry-chip is-inline";
          phaseChip.dataset.chip = "phase";
          if (entry.phase) phaseChip.dataset.phase = entry.phase;
          phaseChip.textContent = phaseLabel;
          phaseCell.appendChild(phaseChip);
          hasPhaseContent = true;
        }
        if (intervalText) {
          const intervalEl = document.createElement("span");
          intervalEl.className = "review-entry-subtext";
          intervalEl.textContent = intervalText;
          phaseCell.appendChild(intervalEl);
          hasPhaseContent = true;
        }
        if (!hasPhaseContent) {
          phaseCell.textContent = "\u2014";
        }
        row.appendChild(phaseCell);
        const dueCell = document.createElement("td");
        dueCell.className = "review-entry-cell due";
        dueCell.textContent = formatOverdue2(entry.due, now);
        row.appendChild(dueCell);
        const timeCell = document.createElement("td");
        timeCell.className = "review-entry-cell timestamp";
        timeCell.textContent = entry.due ? new Date(entry.due).toLocaleString() : "\u2014";
        row.appendChild(timeCell);
        const actionsCell = document.createElement("td");
        actionsCell.className = "review-entry-cell actions";
        const actionGroup = document.createElement("div");
        actionGroup.className = "review-entry-actions";
        const reviewBtn = document.createElement("button");
        reviewBtn.type = "button";
        reviewBtn.className = "btn tertiary";
        reviewBtn.textContent = "Review";
        reviewBtn.addEventListener("click", () => {
          if (typeof startSession === "function") {
            startSession(buildSessionPayload([entry]), {
              scope: "single",
              label: `Focused review \u2013 ${titleOf2(entry.item)}`
            });
          }
        });
        actionGroup.appendChild(reviewBtn);
        const suspendBtn = document.createElement("button");
        suspendBtn.type = "button";
        suspendBtn.className = "btn tertiary";
        suspendBtn.textContent = "Suspend";
        suspendBtn.addEventListener("click", async () => {
          if (suspendBtn.disabled) return;
          suspendBtn.disabled = true;
          retireBtn.disabled = true;
          updateStatus("Suspending\u2026");
          try {
            suspendSection(entry.item, entry.sectionKey, Date.now());
            await upsertItem(entry.item);
            updateStatus("Card suspended.", "success");
            removeEntry(entry);
            renderTable();
            updateReviewButton();
            await handleEntryChange();
          } catch (err) {
            console.error("Failed to suspend entry", err);
            updateStatus("Failed to suspend card.", "error");
            suspendBtn.disabled = false;
            retireBtn.disabled = false;
          }
        });
        actionGroup.appendChild(suspendBtn);
        const retireBtn = document.createElement("button");
        retireBtn.type = "button";
        retireBtn.className = "btn tertiary danger";
        retireBtn.textContent = "Retire";
        retireBtn.addEventListener("click", async () => {
          if (retireBtn.disabled) return;
          retireBtn.disabled = true;
          suspendBtn.disabled = true;
          updateStatus("Retiring\u2026");
          try {
            const steps = await ensureDurations();
            const nowTs = Date.now();
            rateSection(entry.item, entry.sectionKey, RETIRE_RATING, steps, nowTs);
            await upsertItem(entry.item);
            updateStatus("Card retired.", "success");
            removeEntry(entry);
            renderTable();
            updateReviewButton();
            await handleEntryChange();
          } catch (err) {
            console.error("Failed to retire entry", err);
            updateStatus("Failed to retire card.", "error");
            retireBtn.disabled = false;
            suspendBtn.disabled = false;
          }
        });
        actionGroup.appendChild(retireBtn);
        actionsCell.appendChild(actionGroup);
        row.appendChild(actionsCell);
        const toggleSelection = () => {
          if (selectedKeys.has(key)) {
            selectedKeys.delete(key);
            row.classList.remove("is-selected");
            checkbox.checked = false;
          } else {
            selectedKeys.add(key);
            row.classList.add("is-selected");
            checkbox.checked = true;
          }
          updateSelectionBar();
        };
        row.addEventListener("click", (event) => {
          if (event.target instanceof HTMLElement) {
            if (event.target.closest("button")) return;
            if (event.target.closest("input")) return;
          }
          toggleSelection();
        });
        let dragMode = null;
        const stopDrag = () => {
          dragMode = null;
          document.removeEventListener("pointerup", stopDrag);
        };
        row.addEventListener("pointerdown", (event) => {
          if (event.button !== 0) return;
          if (event.target instanceof HTMLElement && event.target.closest("button")) return;
          if (event.target instanceof HTMLElement && event.target.closest("input")) return;
          dragMode = selectedKeys.has(key) ? "deselect" : "select";
          if (dragMode === "select") {
            selectedKeys.add(key);
            row.classList.add("is-selected");
            checkbox.checked = true;
          } else {
            selectedKeys.delete(key);
            row.classList.remove("is-selected");
            checkbox.checked = false;
          }
          updateSelectionBar();
          document.addEventListener("pointerup", stopDrag);
        });
        row.addEventListener("pointerenter", () => {
          if (!dragMode) return;
          if (dragMode === "select") {
            selectedKeys.add(key);
            row.classList.add("is-selected");
            checkbox.checked = true;
          } else {
            selectedKeys.delete(key);
            row.classList.remove("is-selected");
            checkbox.checked = false;
          }
          updateSelectionBar();
        });
        if (selectedKeys.has(key)) {
          row.classList.add("is-selected");
        }
        if (pendingHighlight && pendingHighlight === key) {
          row.classList.add("is-highlighted");
          if (!selectedKeys.has(key)) {
            selectedKeys.add(key);
            row.classList.add("is-selected");
            checkbox.checked = true;
          }
          queueMicrotask(() => {
            row.scrollIntoView({ block: "nearest" });
            updateSelectionBar();
          });
          pendingHighlight = null;
        }
        rowsByKey.set(key, row);
        bodyRows.appendChild(row);
      });
      updateSelectionBar();
    };
    const openPathForFilter = (filter) => {
      if (!filter) return;
      if (filter.scope === "block") {
        const blockId = filter.blockId ?? UNASSIGNED_BLOCK;
        openGroup(blockNodeKey(blockId));
      } else if (filter.scope === "week" || filter.scope === "lecture") {
        const blockId = filter.blockId ?? UNASSIGNED_BLOCK;
        const weekId = filter.weekId ?? UNASSIGNED_WEEK;
        openGroup(blockNodeKey(blockId));
        openGroup(weekNodeKey(blockId, weekId));
      }
    };
    const setFilter = (filter, nodeKey) => {
      currentFilter = filter;
      activeNodeKey = nodeKey;
      currentMetadata = navMetadata.get(nodeKey) || metadata || { scope: "all", label: "All due cards" };
      openPathForFilter(filter);
      setActiveNav(nodeKey);
      updateFilterLabel();
      renderTable();
      updateReviewButton();
    };
    const createNavButton = ({ label, nodeKey, depth, filter, count, meta, accent, variant = "leaf" }) => {
      const button = document.createElement("button");
      button.type = "button";
      button.className = `review-entry-nav-btn depth-${depth}`;
      button.dataset.nodeKey = nodeKey;
      if (variant === "group") {
        button.classList.add("is-group");
      }
      if (accent) {
        button.dataset.accent = accent;
        button.style.setProperty("--nav-accent", accent);
      }
      const text = document.createElement("span");
      text.className = "review-entry-nav-label";
      text.textContent = label;
      const badge = document.createElement("span");
      badge.className = "review-entry-nav-count";
      badge.textContent = String(count || 0);
      navCountElements.set(nodeKey, badge);
      navMetadata.set(nodeKey, meta);
      button.appendChild(text);
      button.appendChild(badge);
      button.addEventListener("click", () => {
        if (variant === "group") {
          openGroup(nodeKey);
        }
        setFilter(filter, nodeKey);
      });
      return button;
    };
    const createNavGroup = ({ label, nodeKey, depth, filter, count, meta, accent, defaultOpen = false }) => {
      const group = document.createElement("div");
      group.className = `review-entry-nav-group depth-${depth}`;
      if (accent) {
        group.style.setProperty("--nav-accent", accent);
      }
      const header = document.createElement("div");
      header.className = "review-entry-nav-group-header";
      group.appendChild(header);
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "review-entry-nav-toggle";
      toggle.setAttribute("aria-label", `Toggle ${label}`);
      header.appendChild(toggle);
      const button = createNavButton({
        label,
        nodeKey,
        depth,
        filter,
        count,
        meta,
        accent,
        variant: "group"
      });
      header.appendChild(button);
      const children = document.createElement("div");
      children.className = "review-entry-nav-children";
      group.appendChild(children);
      const setExpanded = (expanded2) => {
        if (expanded2) {
          group.classList.add("is-open");
          children.hidden = false;
          toggle.setAttribute("aria-expanded", "true");
          toggle.innerHTML = '<span aria-hidden="true">\u25BE</span>';
        } else {
          group.classList.remove("is-open");
          children.hidden = true;
          toggle.setAttribute("aria-expanded", "false");
          toggle.innerHTML = '<span aria-hidden="true">\u25B8</span>';
        }
      };
      setExpanded(defaultOpen);
      toggle.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        setExpanded(!group.classList.contains("is-open"));
      });
      navGroupStates.set(nodeKey, { group, children, toggle, setExpanded });
      return { group, children, button };
    };
    navList.appendChild(createNavButton({
      label: "All cards",
      nodeKey: rootNodeKey,
      depth: 0,
      filter: { scope: "all" },
      count: nodeCounts.get(rootNodeKey) || 0,
      meta: navMetadata.get(rootNodeKey)
    }));
    hierarchy.blocks.forEach((blockNode, blockIndex) => {
      const blockKey = blockNodeKey(blockNode.id);
      const blockMeta = { scope: "block", label: `Block \u2013 ${blockNode.title}`, blockId: blockNode.id };
      const shouldOpenBlock = (() => {
        if (!initialFilter || initialFilter.scope === "all") return blockIndex === 0;
        if (!["block", "week", "lecture"].includes(initialFilter.scope)) return blockIndex === 0;
        return (initialFilter.blockId ?? UNASSIGNED_BLOCK) === blockNode.id;
      })();
      const blockGroup = createNavGroup({
        label: blockNode.title,
        nodeKey: blockKey,
        depth: 1,
        filter: { scope: "block", blockId: blockNode.id },
        count: nodeCounts.get(blockKey) || 0,
        meta: blockMeta,
        accent: blockNode.accent,
        defaultOpen: shouldOpenBlock
      });
      navList.appendChild(blockGroup.group);
      blockNode.weeks.forEach((weekNode) => {
        const weekKey = weekNodeKey(blockNode.id, weekNode.id);
        const weekLabel = weekNode.weekNumber != null ? `Week ${weekNode.weekNumber}` : weekNode.label;
        const weekMeta = {
          scope: "week",
          label: `${weekLabel} \u2013 ${blockNode.title}`,
          blockId: blockNode.id,
          weekId: weekNode.id
        };
        const shouldOpenWeek = (() => {
          if (!initialFilter) return false;
          if (!["week", "lecture"].includes(initialFilter.scope)) return false;
          const blockMatch = (initialFilter.blockId ?? UNASSIGNED_BLOCK) === blockNode.id;
          const weekMatch = (initialFilter.weekId ?? UNASSIGNED_WEEK) === weekNode.id;
          return blockMatch && weekMatch;
        })();
        const weekGroup = createNavGroup({
          label: weekLabel,
          nodeKey: weekKey,
          depth: 2,
          filter: { scope: "week", blockId: blockNode.id, weekId: weekNode.id },
          count: nodeCounts.get(weekKey) || 0,
          meta: weekMeta,
          accent: weekNode.accent,
          defaultOpen: shouldOpenWeek
        });
        blockGroup.children.appendChild(weekGroup.group);
        const lectureList = document.createElement("div");
        lectureList.className = "review-entry-nav-leaves";
        weekGroup.children.appendChild(lectureList);
        weekNode.lectures.forEach((lectureNode) => {
          const lectureKey2 = lectureNodeKey(lectureNode.id);
          const lectureMeta = {
            scope: "lecture",
            label: `${lectureNode.title} \u2013 ${blockNode.title}`,
            lectureKey: lectureNode.id,
            blockId: blockNode.id,
            weekId: weekNode.id
          };
          lectureList.appendChild(createNavButton({
            label: lectureNode.title,
            nodeKey: lectureKey2,
            depth: 3,
            filter: { scope: "lecture", lectureKey: lectureNode.id, blockId: blockNode.id, weekId: weekNode.id },
            count: nodeCounts.get(lectureKey2) || 0,
            meta: lectureMeta,
            accent: lectureNode.accent
          }));
        });
      });
    });
    setFilter(currentFilter, activeNodeKey);
    if (metadata && typeof metadata === "object") {
      currentMetadata = metadata;
      updateFilterLabel();
      updateReviewButton();
    }
    reviewFilteredBtn.addEventListener("click", () => {
      const filtered = listFilteredEntries(currentFilter);
      if (!filtered.length || typeof startSession !== "function") return;
      startSession(buildSessionPayload(filtered), currentMetadata || {});
    });
    selectAllBtn.addEventListener("click", () => {
      const filtered = listFilteredEntries(currentFilter);
      filtered.forEach((entry) => {
        const key = entryKey(entry);
        if (!key) return;
        selectedKeys.add(key);
        const row = rowsByKey.get(key);
        if (row) {
          row.classList.add("is-selected");
          const checkbox = row.querySelector(".review-entry-checkbox");
          if (checkbox) checkbox.checked = true;
        }
      });
      updateSelectionBar();
    });
    clearSelectionBtn.addEventListener("click", () => {
      clearSelection();
    });
    const bulkSuspend = async (keys) => {
      if (!keys.length) return;
      selectionBar.classList.add("is-busy");
      setSelectionStatus("Suspending\u2026");
      try {
        for (const key of keys) {
          const entry = entriesByKey.get(key);
          if (!entry) continue;
          suspendSection(entry.item, entry.sectionKey, Date.now());
          await upsertItem(entry.item);
          removeEntry(entry);
        }
        renderTable();
        updateReviewButton();
        clearSelection();
        setSelectionStatus("Cards suspended.", "success");
        await handleEntryChange();
      } catch (err) {
        console.error("Failed to suspend cards", err);
        setSelectionStatus("Failed to suspend cards.", "error");
      } finally {
        selectionBar.classList.remove("is-busy");
      }
    };
    const bulkRetire = async (keys) => {
      if (!keys.length) return;
      selectionBar.classList.add("is-busy");
      setSelectionStatus("Retiring\u2026");
      try {
        const steps = await ensureDurations();
        for (const key of keys) {
          const entry = entriesByKey.get(key);
          if (!entry) continue;
          rateSection(entry.item, entry.sectionKey, RETIRE_RATING, steps, Date.now());
          await upsertItem(entry.item);
          removeEntry(entry);
        }
        renderTable();
        updateReviewButton();
        clearSelection();
        setSelectionStatus("Cards retired.", "success");
        await handleEntryChange();
      } catch (err) {
        console.error("Failed to retire cards", err);
        setSelectionStatus("Failed to retire cards.", "error");
      } finally {
        selectionBar.classList.remove("is-busy");
      }
    };
    suspendSelectedBtn.addEventListener("click", () => {
      bulkSuspend(Array.from(selectedKeys));
    });
    retireSelectedBtn.addEventListener("click", () => {
      bulkRetire(Array.from(selectedKeys));
    });
    return floating;
  }
  function renderHierarchy(container, hierarchy, { startSession, now, redraw }) {
    if (!hierarchy.root.entries.length) {
      renderEmptyState2(container);
      return;
    }
    const tree = document.createElement("div");
    tree.className = "review-tree";
    container.appendChild(tree);
    const refresh = () => {
      if (typeof redraw === "function") redraw();
    };
    const allMeta = { scope: "all", label: "All due cards" };
    const allNode = createCollapsibleNode({
      level: 0,
      title: "All cards",
      counts: hierarchy.root.counts,
      reviewLabel: "Review all",
      onReview: () => startSession(buildSessionPayload(hierarchy.root.entries), allMeta),
      onMenu: () => openEntryManager(hierarchy, {
        title: "All due cards",
        now,
        startSession,
        metadata: allMeta,
        focus: { scope: "all" },
        onChange: refresh
      }),
      defaultOpen: true
    });
    tree.appendChild(allNode.element);
    const blockList = document.createElement("div");
    blockList.className = "review-tree-children";
    allNode.content.appendChild(blockList);
    const blockFragment = document.createDocumentFragment();
    hierarchy.blocks.forEach((blockNode) => {
      const blockMeta = {
        scope: "block",
        label: `Block \u2013 ${blockNode.title}`,
        blockId: blockNode.id
      };
      const block = createCollapsibleNode({
        level: 1,
        title: blockNode.title,
        counts: blockNode.counts,
        reviewLabel: "Review block",
        onReview: () => startSession(buildSessionPayload(blockNode.entries), blockMeta),
        onMenu: () => openEntryManager(hierarchy, {
          title: `${blockNode.title} \u2014 cards`,
          now,
          startSession,
          metadata: blockMeta,
          focus: { scope: "block", blockId: blockNode.id },
          onChange: refresh
        }),
        accent: blockNode.accent
      });
      blockFragment.appendChild(block.element);
      const weekList = document.createElement("div");
      weekList.className = "review-tree-children";
      block.content.appendChild(weekList);
      const weekFragment = document.createDocumentFragment();
      blockNode.weeks.forEach((weekNode) => {
        const weekTitle = weekNode.weekNumber != null ? `Week ${weekNode.weekNumber}` : "Unassigned week";
        const weekMeta = {
          scope: "week",
          label: `${weekTitle} \u2013 ${blockNode.title}`,
          blockId: blockNode.id,
          week: weekNode.weekNumber,
          weekId: weekNode.id
        };
        const week = createCollapsibleNode({
          level: 2,
          title: weekTitle,
          counts: weekNode.counts,
          reviewLabel: "Review week",
          onReview: () => startSession(buildSessionPayload(weekNode.entries), weekMeta),
          onMenu: () => openEntryManager(hierarchy, {
            title: `${blockNode.title} \u2022 ${weekTitle}`,
            now,
            startSession,
            metadata: weekMeta,
            focus: { scope: "week", blockId: blockNode.id, weekId: weekNode.id },
            onChange: refresh
          }),
          accent: weekNode.accent
        });
        weekFragment.appendChild(week.element);
        const lectureList = document.createElement("div");
        lectureList.className = "review-lecture-list";
        week.content.appendChild(lectureList);
        const lectureFragment = document.createDocumentFragment();
        weekNode.lectures.forEach((lectureNode) => {
          const lectureRow = document.createElement("div");
          lectureRow.className = "review-lecture-row";
          if (lectureNode.accent) {
            lectureRow.classList.add("has-accent");
            lectureRow.style.setProperty("--review-accent", lectureNode.accent);
          }
          const info = document.createElement("div");
          info.className = "review-lecture-info";
          const titleEl = document.createElement("div");
          titleEl.className = "review-lecture-title";
          titleEl.textContent = lectureNode.title;
          info.appendChild(titleEl);
          const lectureCounts = lectureNode.counts || createEmptyCounts();
          const totalLecture = totalCount(lectureCounts);
          const countEl = document.createElement("div");
          countEl.className = "review-lecture-count";
          countEl.textContent = `${totalLecture} due`;
          info.appendChild(countEl);
          const lectureStats = createCountPills(lectureCounts, { variant: "inline" });
          lectureStats.classList.add("review-lecture-stats");
          info.appendChild(lectureStats);
          lectureRow.appendChild(info);
          const lectureMeta = {
            scope: "lecture",
            label: `${lectureNode.title} \u2013 ${blockNode.title}`,
            lectureId: lectureNode.id,
            lectureKey: lectureNode.id,
            blockId: blockNode.id,
            week: lectureNode.weekNumber,
            weekId: weekNode.id
          };
          const actions = createNodeActions({
            counts: lectureCounts,
            reviewLabel: "Review lecture",
            onReview: () => startSession(buildSessionPayload(lectureNode.entries), lectureMeta),
            onMenu: () => openEntryManager(hierarchy, {
              title: `${blockNode.title} \u2022 ${weekTitle} \u2022 ${lectureNode.title}`,
              now,
              startSession,
              metadata: lectureMeta,
              focus: { scope: "lecture", lectureKey: lectureNode.id, blockId: blockNode.id, weekId: weekNode.id },
              onChange: refresh
            })
          });
          actions.classList.add("review-lecture-actions");
          lectureRow.appendChild(actions);
          lectureFragment.appendChild(lectureRow);
        });
        lectureList.appendChild(lectureFragment);
      });
      weekList.appendChild(weekFragment);
    });
    blockList.appendChild(blockFragment);
  }
  async function renderReview(root2, redraw) {
    root2.innerHTML = "";
    await hydrateStudySessions().catch((err) => console.error("Failed to load saved sessions", err));
    const cohort = await loadReviewSourceItems();
    if (!Array.isArray(cohort) || !cohort.length) {
      const empty = document.createElement("div");
      empty.className = "review-empty";
      empty.textContent = "Add study cards to start building a review queue.";
      root2.appendChild(empty);
      return;
    }
    setCohort(cohort);
    const now = Date.now();
    const dueEntries = collectDueSections(cohort, { now });
    const totals = summarizeEntryCounts(dueEntries);
    const totalDue = totalCount(totals);
    const categoryGroups = groupEntriesByCategory(dueEntries);
    const { blocks } = await loadBlockCatalog();
    const blockTitles = ensureBlockTitleMap(blocks);
    const blockAccents = ensureBlockAccentMap(blocks);
    const savedEntry = getStudySessionEntry("review");
    const wrapper = document.createElement("section");
    wrapper.className = "card review-panel";
    const backRow = document.createElement("div");
    backRow.className = "review-back-row";
    const backBtn = document.createElement("button");
    backBtn.type = "button";
    backBtn.className = "btn secondary";
    backBtn.textContent = "Back to study";
    backBtn.addEventListener("click", () => {
      setSubtab("Study", "Builder");
      redraw();
    });
    backRow.appendChild(backBtn);
    wrapper.appendChild(backRow);
    const heading = document.createElement("h2");
    heading.textContent = "Review queue";
    wrapper.appendChild(heading);
    const startSession = async (pool, metadata = {}) => {
      if (!pool.length) return;
      const reviewOrdering = { ...DEFAULT_REVIEW_ORDERING };
      const orderedPool = orderReviewEntries(pool, reviewOrdering);
      await removeStudySession("review").catch((err) => console.warn("Failed to discard existing review save", err));
      setFlashSession({ idx: 0, pool: orderedPool, ratings: {}, mode: "review", metadata, reviewOrdering });
      redraw();
    };
    const summary = document.createElement("section");
    summary.className = "review-summary";
    const summaryTitle = document.createElement("h3");
    summaryTitle.className = "review-summary-title";
    summaryTitle.textContent = "Review overview";
    summary.appendChild(summaryTitle);
    const summaryTotal = document.createElement("div");
    summaryTotal.className = "review-summary-total";
    summaryTotal.textContent = totalDue ? `${totalDue} card${totalDue === 1 ? "" : "s"} due now` : "You\u2019re all caught up!";
    summary.appendChild(summaryTotal);
    const summaryCounts = createCountPills(totals, { variant: "prominent" });
    summaryCounts.classList.add("review-summary-counts");
    summary.appendChild(summaryCounts);
    const quickActions = document.createElement("div");
    quickActions.className = "review-quick-actions";
    COUNT_ORDER.forEach((key) => {
      const config = COUNT_CONFIG[key];
      const count = Number.isFinite(totals[key]) ? totals[key] : 0;
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = `review-quick-btn ${config.className}`;
      btn.textContent = `${config.label} (${count})`;
      btn.disabled = !count;
      btn.setAttribute("aria-label", `Start ${config.label.toLowerCase()} cards`);
      btn.addEventListener("click", () => {
        if (!count) return;
        const pool = categoryGroups.get(key) || [];
        if (!pool.length) return;
        startSession(buildSessionPayload(pool), {
          scope: "phase",
          phase: key,
          label: `${config.label} cards`
        });
      });
      quickActions.appendChild(btn);
    });
    if (!totalDue) {
      quickActions.classList.add("is-empty");
    }
    summary.appendChild(quickActions);
    if (totalDue) {
      const summaryHint = document.createElement("div");
      summaryHint.className = "review-summary-hint";
      summaryHint.textContent = "Use quick actions or drill into lectures below.";
      summary.appendChild(summaryHint);
    }
    wrapper.appendChild(summary);
    if (savedEntry?.session) {
      const resumeRow = document.createElement("div");
      resumeRow.className = "review-resume-row";
      const resumeLabel = document.createElement("div");
      resumeLabel.className = "review-resume-label";
      resumeLabel.textContent = savedEntry.metadata?.label || "Saved review session available";
      resumeRow.appendChild(resumeLabel);
      const resumeBtn = document.createElement("button");
      resumeBtn.type = "button";
      resumeBtn.className = "btn";
      resumeBtn.textContent = "Resume";
      resumeBtn.addEventListener("click", async () => {
        await removeStudySession("review").catch((err) => console.warn("Failed to clear saved review entry", err));
        const restored = Array.isArray(savedEntry.cohort) ? savedEntry.cohort : null;
        if (restored) {
          setCohort(restored);
        }
        setFlashSession(savedEntry.session);
        redraw();
      });
      resumeRow.appendChild(resumeBtn);
      wrapper.appendChild(resumeRow);
    }
    const body = document.createElement("div");
    body.className = "review-body";
    wrapper.appendChild(body);
    if (dueEntries.length) {
      const hierarchy = buildReviewHierarchy(dueEntries, blocks, blockTitles, blockAccents);
      renderHierarchy(body, hierarchy, { startSession, now, redraw });
    } else {
      renderEmptyState2(body);
    }
    root2.appendChild(wrapper);
  }
  var blockTitleCache, DEFAULT_BLOCK_ACCENTS, COUNT_ORDER, COUNT_CONFIG, UNASSIGNED_BLOCK, UNASSIGNED_WEEK, UNASSIGNED_LECTURE;
  var init_review = __esm({
    "js/ui/components/review.js"() {
      init_state();
      init_scheduler2();
      init_block_catalog();
      init_section_utils();
      init_study_sessions();
      init_pool();
      init_constants();
      init_storage();
      init_window_manager();
      init_order();
      blockTitleCache = null;
      DEFAULT_BLOCK_ACCENTS = [
        "#38bdf8",
        "#a855f7",
        "#f97316",
        "#22d3ee",
        "#f59e0b",
        "#34d399",
        "#f472b6"
      ];
      COUNT_ORDER = ["new", "learning", "review"];
      COUNT_CONFIG = {
        new: { label: "New", className: "is-new" },
        learning: { label: "Learning", className: "is-learning" },
        review: { label: "Review", className: "is-review" }
      };
      UNASSIGNED_BLOCK = "__unassigned";
      UNASSIGNED_WEEK = "__unassigned";
      UNASSIGNED_LECTURE = "__unassigned";
    }
  });

  // js/ui/components/flashcards.js
  var flashcards_exports = {};
  __export(flashcards_exports, {
    renderFlashcards: () => renderFlashcards
  });
  function orderingsEqual(a, b) {
    if (!a || !b) return false;
    if (a.mode !== b.mode) return false;
    const aList = Array.isArray(a.priorities) ? a.priorities : [];
    const bList = Array.isArray(b.priorities) ? b.priorities : [];
    if (aList.length !== bList.length) return false;
    for (let i = 0; i < aList.length; i += 1) {
      if (aList[i] !== bList[i]) return false;
    }
    return true;
  }
  function findPresetId(ordering) {
    const normalized2 = ensureReviewOrdering(ordering);
    const match = ORDER_PRESETS.find((preset) => orderingsEqual(ensureReviewOrdering(preset.ordering), normalized2));
    return match ? match.id : "review-learning-new";
  }
  function deriveReviewCategory(entry, snapshot) {
    if (entry && typeof entry.category === "string") {
      return normalizeReviewCategory(entry.category);
    }
    const state2 = snapshot || null;
    if (!state2 || typeof state2 !== "object") return "new";
    const { phase, lastRating } = state2;
    if (phase === "review") return "review";
    if (phase === "relearning") return "learning";
    if (phase === "learning") {
      if (!lastRating || lastRating === "again") return "new";
      return "learning";
    }
    if (lastRating === "again") return "new";
    if (lastRating === "easy" || lastRating === "good" || lastRating === "hard") return "learning";
    return "new";
  }
  function formatReviewInterval(minutes) {
    if (!Number.isFinite(minutes) || minutes <= 0) return "Now";
    if (minutes < 60) return `${minutes} min`;
    const asHours = minutes / 60;
    if (asHours < 24) {
      const roundedHours = Number.isInteger(asHours) ? asHours : Math.round(asHours * 10) / 10;
      return `${roundedHours} hr`;
    }
    const asDays = minutes / 1440;
    if (asDays < 30) {
      const roundedDays = Number.isInteger(asDays) ? asDays : Math.round(asDays * 10) / 10;
      return `${roundedDays} day${roundedDays === 1 ? "" : "s"}`;
    }
    const asMonths = minutes / 43200;
    if (asMonths < 12) {
      const roundedMonths = Number.isInteger(asMonths) ? asMonths : Math.round(asMonths * 10) / 10;
      return `${roundedMonths} mo`;
    }
    const asYears = minutes / 525600;
    const roundedYears = Number.isInteger(asYears) ? asYears : Math.round(asYears * 10) / 10;
    return `${roundedYears} yr`;
  }
  function getFlashcardAccent(item) {
    if (item?.color) return item.color;
    if (item?.kind && KIND_ACCENTS[item.kind]) return KIND_ACCENTS[item.kind];
    return "var(--accent)";
  }
  function cloneSectionState(state2) {
    if (!state2 || typeof state2 !== "object") return null;
    return JSON.parse(JSON.stringify(state2));
  }
  function queueStatusLabel(snapshot) {
    if (!snapshot || snapshot.retired) return "Already in review queue";
    const rating = snapshot.lastRating;
    if (rating && RATING_LABELS[rating]) {
      return `In review (${RATING_LABELS[rating]})`;
    }
    return "Already in review queue";
  }
  function entryIdentifier(item = {}, fallbackId = "item") {
    return item.id || item.slug || item.name || fallbackId;
  }
  function reviewEntryKey(entry) {
    if (!entry) return null;
    const itemId = entry.itemId || entryIdentifier(entry.item);
    const section = entry.sectionKey || (Array.isArray(entry.sections) ? entry.sections[0] : null);
    if (!itemId || !section) return null;
    return `${itemId}::${section}`;
  }
  function sessionEntryKey(entry) {
    if (!entry) return null;
    const section = Array.isArray(entry.sections) && entry.sections.length ? entry.sections[0] : entry.sectionKey;
    return reviewEntryKey({ item: entry.item, sectionKey: section });
  }
  function ratingKey(item, sectionKey) {
    const id = item?.id || "item";
    return `${id}::${sectionKey}`;
  }
  function sessionEntryAt(session, idx) {
    const pool = Array.isArray(session.pool) ? session.pool : [];
    return pool[idx] || null;
  }
  function normalizeFlashSession(session, fallbackPool, defaultMode = "study") {
    const source = session && typeof session === "object" ? session : {};
    const next = { ...source };
    let changed = !session || typeof session !== "object";
    const fallback = Array.isArray(fallbackPool) ? fallbackPool : [];
    const pool = Array.isArray(source.pool) && source.pool.length ? source.pool : fallback;
    if (source.pool !== pool) {
      next.pool = pool;
      changed = true;
    }
    const ratings = source.ratings && typeof source.ratings === "object" ? source.ratings : {};
    if (source.ratings !== ratings) {
      next.ratings = ratings;
      changed = true;
    }
    const baselines = source.ratingBaselines && typeof source.ratingBaselines === "object" ? source.ratingBaselines : {};
    if (source.ratingBaselines !== baselines) {
      next.ratingBaselines = baselines;
      changed = true;
    }
    let idx = typeof source.idx === "number" && Number.isFinite(source.idx) ? Math.floor(source.idx) : 0;
    if (idx < 0) idx = 0;
    const maxIdx = pool.length ? pool.length - 1 : 0;
    if (idx > maxIdx) idx = maxIdx;
    if (idx !== source.idx) {
      next.idx = idx;
      changed = true;
    }
    const mode2 = source.mode === "review" ? "review" : defaultMode;
    if (source.mode !== mode2) {
      next.mode = mode2;
      changed = true;
    }
    const ordering = ensureReviewOrdering(source.reviewOrdering);
    if (!orderingsEqual(source.reviewOrdering, ordering)) {
      next.reviewOrdering = ordering;
      changed = true;
    } else if (source.reviewOrdering !== ordering) {
      next.reviewOrdering = ordering;
    }
    return changed ? next : session;
  }
  function renderFlashcards(root2, redraw) {
    const fallbackPool = Array.isArray(state.cohort) ? state.cohort : [];
    let active = state.flashSession;
    if (active) {
      const normalized2 = normalizeFlashSession(active, fallbackPool, active.mode === "review" ? "review" : "study");
      if (normalized2 !== active) {
        setFlashSession(normalized2);
        active = normalized2;
      }
    } else {
      active = normalizeFlashSession({ idx: 0, pool: fallbackPool, ratings: {}, mode: "study" }, fallbackPool, "study");
    }
    active.ratings = active.ratings || {};
    active.ratingBaselines = active.ratingBaselines && typeof active.ratingBaselines === "object" ? active.ratingBaselines : {};
    const items = Array.isArray(active.pool) && active.pool.length ? active.pool : fallbackPool;
    const resolvePool = () => Array.isArray(active.pool) && active.pool.length ? active.pool : items;
    const commitSession = (patch = {}) => {
      const pool = resolvePool();
      const next2 = { ...active, pool, ...patch };
      next2.ratings = patch.ratings ? { ...patch.ratings } : { ...active.ratings };
      next2.ratingBaselines = patch.ratingBaselines ? { ...patch.ratingBaselines } : { ...active.ratingBaselines };
      next2.reviewOrdering = ensureReviewOrdering(patch.reviewOrdering ? patch.reviewOrdering : active.reviewOrdering);
      active = next2;
      setFlashSession(next2);
    };
    const isReview = active.mode === "review";
    const syncReviewSession = async () => {
      if (!isReview) return;
      try {
        const nowTs = Date.now();
        const cohortItems = await loadReviewSourceItems();
        setCohort(cohortItems);
        const dueEntries = collectDueSections(cohortItems, { now: nowTs });
        const dueKeys = new Set(dueEntries.map(reviewEntryKey).filter(Boolean));
        const pool = resolvePool();
        const filtered = pool.filter((entry2) => {
          const key = sessionEntryKey(entry2);
          return !key || dueKeys.has(key);
        });
        if (filtered.length === pool.length) return;
        let idx = active.idx;
        if (idx >= filtered.length) idx = Math.max(filtered.length - 1, 0);
        commitSession({ pool: filtered, idx });
        redraw();
      } catch (err) {
        console.error("Failed to sync review session", err);
      }
    };
    const openQueueManager = async (focusEntry = null, triggerBtn = null) => {
      if (!isReview) return;
      if (triggerBtn) triggerBtn.disabled = true;
      try {
        const nowTs = Date.now();
        const cohortItems = await loadReviewSourceItems();
        setCohort(cohortItems);
        const dueEntries = collectDueSections(cohortItems, { now: nowTs });
        const { blocks } = await loadBlockCatalog();
        const blockTitles = ensureBlockTitleMap(blocks);
        const blockAccents = ensureBlockAccentMap(blocks);
        const hierarchy = buildReviewHierarchy(dueEntries, blocks, blockTitles, blockAccents);
        const highlightKey = focusEntry ? sessionEntryKey(focusEntry) : null;
        let focusFilter = null;
        if (highlightKey && hierarchy?.contexts instanceof Map) {
          const contexts = hierarchy.contexts.get(highlightKey);
          if (Array.isArray(contexts) && contexts.length) {
            const ctx = contexts[0];
            focusFilter = {
              scope: "lecture",
              lectureKey: ctx.lectureKey,
              blockId: ctx.blockId,
              weekId: ctx.weekId
            };
          }
        }
        openEntryManager(hierarchy, {
          title: "Manage review queue",
          now: nowTs,
          startSession: async (pool, metadata = {}) => {
            await removeStudySession("review").catch((err) => console.warn("Failed to clear saved review entry", err));
            setFlashSession({ idx: 0, pool, ratings: {}, mode: "review", metadata });
            redraw();
          },
          metadata: { scope: "all", label: "All due cards" },
          focus: focusFilter || void 0,
          highlightEntryKey: highlightKey,
          onChange: syncReviewSession
        });
      } catch (err) {
        console.error("Failed to open review manager", err);
      } finally {
        if (triggerBtn) triggerBtn.disabled = false;
      }
    };
    root2.innerHTML = "";
    if (!items.length) {
      const msg = document.createElement("div");
      msg.textContent = "No cards selected. Adjust the filters above to add cards.";
      root2.appendChild(msg);
      return;
    }
    if (active.idx >= items.length) {
      setFlashSession(null);
      setStudySelectedMode("Flashcards");
      setSubtab("Study", isReview ? "Review" : "Builder");
      if (isReview) {
        removeStudySession("review").catch((err) => console.warn("Failed to clear review session", err));
      } else {
        removeStudySession("flashcards").catch((err) => console.warn("Failed to clear flashcard session", err));
      }
      redraw();
      return;
    }
    const entry = sessionEntryAt(active, active.idx);
    const item = entry && entry.item ? entry.item : entry;
    if (!item) {
      setFlashSession(null);
      redraw();
      return;
    }
    const allowedSections = entry && entry.sections ? entry.sections : entry && entry.sectionKey ? [entry.sectionKey] : null;
    const sections = sectionsForItem(item, allowedSections);
    const card = document.createElement("section");
    card.className = "card flashcard";
    card.tabIndex = 0;
    if (isReview) {
      card.classList.add("is-review");
    }
    const totalCount2 = items.length;
    const header = document.createElement("div");
    header.className = "flashcard-header";
    const headerInfo = document.createElement("div");
    headerInfo.className = "flashcard-header-info";
    header.appendChild(headerInfo);
    const title = document.createElement("h2");
    title.className = "flashcard-title";
    title.textContent = item.name || item.concept || "";
    headerInfo.appendChild(title);
    const progress = document.createElement("div");
    progress.className = "flashcard-progress";
    progress.textContent = totalCount2 ? `Card ${active.idx + 1} of ${totalCount2}` : "Card 0 of 0";
    headerInfo.appendChild(progress);
    let categoryBadge = null;
    if (isReview) {
      categoryBadge = document.createElement("span");
      categoryBadge.className = "flashcard-category";
      categoryBadge.hidden = true;
      headerInfo.appendChild(categoryBadge);
    }
    const headerActions = document.createElement("div");
    headerActions.className = "flashcard-header-actions";
    header.appendChild(headerActions);
    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "icon-btn flashcard-edit-btn";
    editBtn.innerHTML = "\u270F\uFE0F";
    editBtn.title = "Edit card";
    editBtn.setAttribute("aria-label", "Edit card");
    editBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const onSave = typeof redraw === "function" ? () => redraw() : void 0;
      openEditor(item.kind, onSave, item);
    });
    headerActions.appendChild(editBtn);
    if (isReview) {
      const manageBtn = document.createElement("button");
      manageBtn.type = "button";
      manageBtn.className = "icon-btn flashcard-manage-btn";
      manageBtn.innerHTML = "\u2699";
      manageBtn.title = "Manage review queue";
      manageBtn.setAttribute("aria-label", "Manage review queue");
      manageBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        openQueueManager(entry, manageBtn);
      });
      headerActions.appendChild(manageBtn);
    }
    card.appendChild(header);
    let orderSelect = null;
    const applyReviewOrdering = (ordering) => {
      const normalizedOrdering = ensureReviewOrdering(ordering);
      const pool = resolvePool();
      if (!Array.isArray(pool) || !pool.length) {
        commitSession({ reviewOrdering: normalizedOrdering });
        redraw();
        return;
      }
      const currentIdx = active.idx;
      const leading = pool.slice(0, currentIdx);
      const currentEntry = pool[currentIdx];
      const remainder = pool.slice(currentIdx + 1);
      const reorderedTail = orderReviewEntries(remainder, normalizedOrdering);
      const nextPool = currentEntry ? [...leading, currentEntry, ...reorderedTail] : [...leading, ...reorderedTail];
      commitSession({ pool: nextPool, reviewOrdering: normalizedOrdering });
      redraw();
    };
    if (isReview) {
      const orderingControls = document.createElement("div");
      orderingControls.className = "flashcard-ordering";
      const controlId = `flashcard-ordering-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const orderLabel = document.createElement("label");
      orderLabel.className = "flashcard-ordering-label";
      orderLabel.setAttribute("for", controlId);
      orderLabel.textContent = "Order cards";
      orderingControls.appendChild(orderLabel);
      orderSelect = document.createElement("select");
      orderSelect.className = "input flashcard-ordering-select";
      orderSelect.id = controlId;
      ORDER_PRESETS.forEach((preset) => {
        const option = document.createElement("option");
        option.value = preset.id;
        option.textContent = preset.label;
        orderSelect.appendChild(option);
      });
      const presetId = findPresetId(active.reviewOrdering);
      const initialPreset = ORDER_PRESETS.find((preset) => preset.id === presetId) || ORDER_PRESETS[1];
      orderSelect.value = initialPreset.id;
      orderSelect.addEventListener("change", () => {
        const preset = ORDER_PRESETS.find((entryPreset) => entryPreset.id === orderSelect.value) || initialPreset;
        applyReviewOrdering(preset.ordering);
      });
      orderingControls.appendChild(orderSelect);
      card.appendChild(orderingControls);
    }
    const durationsPromise = getReviewDurations().catch(() => ({ ...DEFAULT_REVIEW_STEPS }));
    const sectionBlocks = sections.length ? sections : [];
    const sectionRequirements = /* @__PURE__ */ new Map();
    let reviewCategory = isReview && typeof entry?.category === "string" ? normalizeReviewCategory(entry.category) : null;
    if (!sectionBlocks.length) {
      const empty = document.createElement("div");
      empty.className = "flash-empty";
      empty.textContent = "No content available for this card.";
      card.appendChild(empty);
    }
    sectionBlocks.forEach(({ key, label, content, extra }) => {
      const ratingId = ratingKey(item, key);
      let currentRating = active.ratings[ratingId] || null;
      const snapshot = getSectionStateSnapshot(item, key);
      if (isReview && !reviewCategory && snapshot) {
        reviewCategory = deriveReviewCategory(entry, snapshot);
      }
      if (snapshot && !active.ratingBaselines[ratingId]) {
        active.ratingBaselines[ratingId] = cloneSectionState(snapshot);
      }
      const lockedByQueue = !isReview && Boolean(snapshot && snapshot.last && !snapshot.retired);
      const alreadyQueued = !isReview && Boolean(snapshot && snapshot.last && !snapshot.retired);
      const requiresRating = isReview || !alreadyQueued;
      sectionRequirements.set(key, requiresRating);
      const sec = document.createElement("div");
      sec.className = "flash-section";
      if (extra) sec.classList.add("flash-section-extra");
      sec.setAttribute("role", "button");
      sec.tabIndex = 0;
      const head = document.createElement("div");
      head.className = "flash-heading";
      head.textContent = label;
      const body = document.createElement("div");
      body.className = "flash-body";
      renderRichText(body, content || "", { clozeMode: "interactive" });
      const ratingRow = document.createElement("div");
      ratingRow.className = "flash-rating";
      const ratingButtons = document.createElement("div");
      ratingButtons.className = "flash-rating-options";
      const status = document.createElement("span");
      status.className = "flash-rating-status";
      let ratingLocked = lockedByQueue;
      let adjustBtn = null;
      const clearStatusInteraction = () => {
        status.classList.remove("flash-rating-status-action");
        status.removeAttribute("role");
        status.removeAttribute("tabindex");
        status.removeAttribute("aria-label");
      };
      const makeStatusInteractive = (ariaLabel = "") => {
        status.classList.add("flash-rating-status-action");
        status.setAttribute("role", "button");
        status.setAttribute("tabindex", "0");
        if (ariaLabel) {
          status.setAttribute("aria-label", ariaLabel);
        }
      };
      const setLockState = (reason) => {
        ratingLocked = true;
        ratingRow.classList.add("is-locked");
        if (reason) {
          ratingRow.dataset.lock = reason;
        } else {
          delete ratingRow.dataset.lock;
        }
        if (adjustBtn) adjustBtn.hidden = false;
      };
      const releaseLock = () => {
        ratingLocked = false;
        ratingRow.classList.remove("is-locked");
        delete ratingRow.dataset.lock;
        delete ratingRow.dataset.state;
        clearStatusInteraction();
        if (adjustBtn) adjustBtn.hidden = true;
        ratingButtons.hidden = false;
      };
      const unlockRating = () => {
        if (!ratingLocked) return;
        releaseLock();
        ratingButtons.hidden = false;
        Array.from(ratingButtons.querySelectorAll("button")).forEach((btn) => {
          btn.disabled = false;
          btn.classList.remove("is-locked-choice");
        });
        status.classList.remove("is-error");
        status.textContent = currentRating ? "Update rating (updates queue)" : "Select a rating to queue for review";
        renderPreviews();
      };
      const activateStatus = (event) => {
        if (!ratingLocked) return;
        event.preventDefault();
        event.stopPropagation();
        unlockRating();
      };
      status.addEventListener("click", activateStatus);
      status.addEventListener("keydown", (event) => {
        if (!ratingLocked) return;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          activateStatus(event);
        }
      });
      const selectRating = (value) => {
        currentRating = value;
        active.ratings[ratingId] = value;
        Array.from(ratingButtons.querySelectorAll("button")).forEach((btn) => {
          const btnValue = btn.dataset.value;
          const isSelected = btnValue === value;
          btn.classList.toggle("is-selected", isSelected);
          if (isSelected) {
            ratingButtons.dataset.selected = value;
          } else if (ratingButtons.dataset.selected === btnValue) {
            delete ratingButtons.dataset.selected;
          }
          btn.setAttribute("aria-pressed", isSelected ? "true" : "false");
        });
        status.classList.remove("is-error");
        commitSession({ ratings: { ...active.ratings } });
      };
      const ratingPreviews = /* @__PURE__ */ new Map();
      const updatePreviews = (durations) => {
        if (!durations) return;
        const nowTs = Date.now();
        const baselineState = active.ratingBaselines[ratingId] || null;
        const projectionSource = baselineState ? (() => {
          const clone6 = JSON.parse(JSON.stringify(item));
          if (!clone6.sr || typeof clone6.sr !== "object") clone6.sr = {};
          clone6.sr.version = clone6.sr.version || item.sr && item.sr.version || 1;
          clone6.sr.sections = clone6.sr.sections && typeof clone6.sr.sections === "object" ? { ...clone6.sr.sections } : {};
          clone6.sr.sections[key] = cloneSectionState(baselineState);
          return clone6;
        })() : null;
        REVIEW_RATINGS.forEach((ratingValue) => {
          const target = ratingPreviews.get(ratingValue);
          if (!target) return;
          try {
            const projection = projectSectionRating(projectionSource ? projectionSource : item, key, ratingValue, durations, nowTs);
            if (!projection || !Number.isFinite(projection.due)) {
              target.textContent = "";
              return;
            }
            const minutes = Math.max(0, Math.round((projection.due - nowTs) / (60 * 1e3)));
            target.textContent = formatReviewInterval(minutes);
          } catch (err) {
            target.textContent = "";
          }
        });
      };
      const renderPreviews = async () => {
        try {
          const durations = await durationsPromise;
          updatePreviews(durations);
        } catch (err) {
        }
      };
      const applyQueueLock = () => {
        const label2 = queueStatusLabel(snapshot);
        setLockState("queue");
        ratingButtons.hidden = true;
        ratingRow.dataset.state = "queued";
        status.textContent = `${label2} \u2014 click to adjust`;
        makeStatusInteractive("Update review rating");
      };
      const applySessionLock = () => {
        setLockState("session");
        ratingButtons.hidden = false;
        Array.from(ratingButtons.querySelectorAll("button")).forEach((btn) => {
          const isSelected = btn.dataset.value === currentRating;
          btn.disabled = !isSelected;
          btn.classList.toggle("is-locked-choice", !isSelected);
        });
        status.classList.remove("is-error");
        ratingRow.dataset.state = "queued";
        status.textContent = "Queued for review \u2014 click to adjust";
        makeStatusInteractive("Adjust saved rating");
      };
      const handleRating = async (value) => {
        if (ratingLocked) return;
        const durations = await durationsPromise;
        setToggleState(sec, true, "revealed");
        ratingRow.classList.add("is-saving");
        status.textContent = "Saving\u2026";
        status.classList.remove("is-error");
        try {
          if (!active.ratingBaselines[ratingId] && snapshot) {
            active.ratingBaselines[ratingId] = cloneSectionState(snapshot);
          }
          const baselineState = active.ratingBaselines[ratingId];
          if (baselineState) {
            const sr = ensureItemSr(item);
            sr.sections = sr.sections || {};
            sr.sections[key] = cloneSectionState(baselineState);
          }
          rateSection(item, key, value, durations, Date.now());
          await upsertItem(item);
          selectRating(value);
          applySessionLock();
          updatePreviews(durations);
        } catch (err) {
          console.error("Failed to record rating", err);
          status.textContent = "Save failed";
          status.classList.add("is-error");
        } finally {
          ratingRow.classList.remove("is-saving");
        }
      };
      REVIEW_RATINGS.forEach((value) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.value = value;
        btn.dataset.rating = value;
        btn.className = "flash-rating-btn";
        const variant = RATING_CLASS[value];
        if (variant) btn.classList.add(variant);
        btn.setAttribute("aria-pressed", "false");
        const label2 = document.createElement("span");
        label2.className = "flash-rating-label";
        label2.textContent = RATING_LABELS[value];
        const preview = document.createElement("span");
        preview.className = "flash-rating-preview";
        btn.appendChild(label2);
        btn.appendChild(preview);
        ratingPreviews.set(value, preview);
        btn.addEventListener("click", (event) => {
          event.stopPropagation();
          handleRating(value);
        });
        btn.addEventListener("keydown", (event) => {
          event.stopPropagation();
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            handleRating(value);
          }
        });
        ratingButtons.appendChild(btn);
      });
      renderPreviews();
      adjustBtn = document.createElement("button");
      adjustBtn.type = "button";
      adjustBtn.className = "flash-rating-adjust";
      adjustBtn.textContent = "Adjust";
      adjustBtn.setAttribute("aria-label", "Adjust rating");
      adjustBtn.hidden = true;
      adjustBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        unlockRating();
      });
      adjustBtn.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          event.stopPropagation();
          unlockRating();
        }
      });
      if (lockedByQueue) {
        applyQueueLock();
      } else if (currentRating) {
        selectRating(currentRating);
        applySessionLock();
      } else {
        releaseLock();
        status.textContent = "Select a rating to queue for review";
      }
      ratingRow.appendChild(ratingButtons);
      ratingRow.appendChild(status);
      ratingRow.appendChild(adjustBtn);
      setToggleState(sec, false, "revealed");
      const toggleReveal = () => {
        if (sec.classList.contains("flash-section-disabled")) return;
        if (sec.contains(document.activeElement) && document.activeElement?.tagName === "BUTTON") return;
        const next2 = sec.dataset.active !== "true";
        setToggleState(sec, next2, "revealed");
      };
      sec.addEventListener("click", (event) => {
        if (event.detail > 1) return;
        if (event.target instanceof HTMLElement) {
          if (event.target.closest(".flash-rating")) return;
          if (event.target.closest("[data-cloze]")) return;
        }
        toggleReveal();
      });
      sec.addEventListener("keydown", (e) => {
        if (e.target instanceof HTMLElement && e.target.closest(".flash-rating")) return;
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          toggleReveal();
        }
      });
      sec.appendChild(head);
      sec.appendChild(body);
      sec.appendChild(ratingRow);
      card.appendChild(sec);
    });
    if (isReview) {
      const normalizedCategory = reviewCategory ? normalizeReviewCategory(reviewCategory) : "new";
      card.dataset.reviewCategory = normalizedCategory;
      const categoryColor = REVIEW_CATEGORY_COLORS[normalizedCategory];
      if (categoryColor) {
        card.style.setProperty("--review-category-color", categoryColor);
      } else {
        card.style.removeProperty("--review-category-color");
      }
      if (categoryBadge) {
        categoryBadge.textContent = `${REVIEW_CATEGORY_LABELS[normalizedCategory]} card`;
        categoryBadge.dataset.category = normalizedCategory;
        categoryBadge.hidden = false;
      }
    } else {
      card.style.removeProperty("--review-category-color");
    }
    const controls = document.createElement("div");
    controls.className = "row flash-controls";
    const prev = document.createElement("button");
    prev.className = "btn";
    prev.textContent = "Prev";
    prev.disabled = isReview ? active.idx === 0 : totalCount2 === 0;
    prev.addEventListener("click", () => {
      if (isReview) {
        if (active.idx > 0) {
          commitSession({ idx: active.idx - 1 });
          redraw();
        }
      } else if (totalCount2 > 0) {
        const prevIdx = totalCount2 > 1 ? active.idx === 0 ? totalCount2 - 1 : active.idx - 1 : 0;
        commitSession({ idx: prevIdx });
        redraw();
      }
    });
    controls.appendChild(prev);
    const next = document.createElement("button");
    next.className = "btn";
    next.textContent = "Next";
    const isLast = active.idx >= totalCount2 - 1;
    next.disabled = isReview ? isLast : totalCount2 === 0;
    next.addEventListener("click", () => {
      if (isReview) {
        if (active.idx < totalCount2 - 1) {
          commitSession({ idx: active.idx + 1 });
          redraw();
        }
        return;
      }
      if (!totalCount2) return;
      const nextIdx = totalCount2 > 1 ? (active.idx + 1) % totalCount2 : active.idx;
      commitSession({ idx: nextIdx });
      redraw();
    });
    controls.appendChild(next);
    let finishBtn = null;
    if (isReview) {
      finishBtn = document.createElement("button");
      finishBtn.type = "button";
      finishBtn.className = "btn flash-finish-btn";
      finishBtn.textContent = "Finish review";
      finishBtn.addEventListener("click", async () => {
        finishBtn.disabled = true;
        setFlashSession(null);
        setStudySelectedMode("Flashcards");
        setSubtab("Study", "Review");
        try {
          await removeStudySession("review").catch((err) => console.warn("Failed to clear saved review entry", err));
        } finally {
          redraw();
        }
      });
      controls.appendChild(finishBtn);
    }
    if (!isReview) {
      const saveExit = document.createElement("button");
      saveExit.className = "btn secondary";
      saveExit.textContent = "Save & close";
      saveExit.addEventListener("click", async () => {
        const original = saveExit.textContent;
        saveExit.disabled = true;
        saveExit.textContent = "Saving\u2026";
        try {
          const pool = resolvePool();
          await persistStudySession("flashcards", {
            session: { ...active, idx: active.idx, pool, ratings: { ...active.ratings || {} } },
            cohort: pool
          });
          setFlashSession(null);
          setStudySelectedMode("Flashcards");
          setSubtab("Study", "Builder");
          redraw();
        } catch (err) {
          console.error("Failed to save flashcard progress", err);
          saveExit.textContent = "Save failed";
          setTimeout(() => {
            saveExit.textContent = original;
          }, 2e3);
        } finally {
          saveExit.disabled = false;
        }
      });
      controls.appendChild(saveExit);
    } else {
      const saveExit = document.createElement("button");
      saveExit.className = "btn secondary";
      saveExit.textContent = "Pause & save";
      saveExit.addEventListener("click", async () => {
        const original = saveExit.textContent;
        saveExit.disabled = true;
        saveExit.textContent = "Saving\u2026";
        try {
          const pool = resolvePool();
          await persistStudySession("review", {
            session: {
              ...active,
              idx: active.idx,
              pool,
              ratings: { ...active.ratings || {} },
              reviewOrdering: ensureReviewOrdering(active.reviewOrdering)
            },
            cohort: state.cohort,
            metadata: active.metadata || { label: "Review session" }
          });
          setFlashSession(null);
          setSubtab("Study", "Review");
          redraw();
        } catch (err) {
          console.error("Failed to save review session", err);
          saveExit.textContent = "Save failed";
          setTimeout(() => {
            saveExit.textContent = original;
          }, 2e3);
        } finally {
          saveExit.disabled = false;
        }
      });
      controls.appendChild(saveExit);
    }
    card.appendChild(controls);
    const sessionWrap = document.createElement("div");
    sessionWrap.className = "flashcard-session";
    if (isReview) sessionWrap.classList.add("is-review");
    sessionWrap.appendChild(card);
    root2.appendChild(sessionWrap);
    card.focus();
    card.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") {
        if (!next.disabled) {
          next.click();
        } else if (isReview && finishBtn) {
          finishBtn.focus();
        }
      } else if (e.key === "ArrowLeft") {
        if (!prev.disabled) {
          prev.click();
        } else if (!isReview && totalCount2 > 1) {
          prev.click();
        }
      }
    });
    const accent = getFlashcardAccent(item);
    card.style.setProperty("--flash-accent", accent);
    card.style.setProperty("--flash-accent-soft", `color-mix(in srgb, ${accent} 16%, transparent)`);
    card.style.setProperty("--flash-accent-strong", `color-mix(in srgb, ${accent} 32%, rgba(15, 23, 42, 0.08))`);
    card.style.setProperty("--flash-accent-border", `color-mix(in srgb, ${accent} 42%, transparent)`);
  }
  var KIND_ACCENTS, RATING_LABELS, RATING_CLASS, REVIEW_CATEGORY_COLORS, REVIEW_CATEGORY_LABELS, ORDER_PRESETS;
  var init_flashcards = __esm({
    "js/ui/components/flashcards.js"() {
      init_state();
      init_utils();
      init_rich_text();
      init_section_utils();
      init_editor();
      init_constants();
      init_scheduler2();
      init_storage();
      init_study_sessions();
      init_pool();
      init_block_catalog();
      init_review();
      init_order();
      KIND_ACCENTS = {
        disease: "var(--pink)",
        drug: "var(--blue)",
        concept: "var(--green)"
      };
      RATING_LABELS = {
        again: "Again",
        hard: "Hard",
        good: "Good",
        easy: "Easy"
      };
      RATING_CLASS = {
        again: "danger",
        hard: "secondary",
        good: "",
        easy: ""
      };
      REVIEW_CATEGORY_COLORS = {
        new: "#38bdf8",
        learning: "#f59e0b",
        review: "#34d399"
      };
      REVIEW_CATEGORY_LABELS = {
        new: "New",
        learning: "Learning",
        review: "Review"
      };
      ORDER_PRESETS = [
        { id: "mixed", label: "Mixed (random)", ordering: { mode: "mixed", priorities: [] } },
        { id: "review-learning-new", label: "Review \u2192 Learning \u2192 New", ordering: { mode: "prioritized", priorities: ["review", "learning", "new"] } },
        { id: "review-new-learning", label: "Review \u2192 New \u2192 Learning", ordering: { mode: "prioritized", priorities: ["review", "new", "learning"] } },
        { id: "learning-review-new", label: "Learning \u2192 Review \u2192 New", ordering: { mode: "prioritized", priorities: ["learning", "review", "new"] } },
        { id: "learning-new-review", label: "Learning \u2192 New \u2192 Review", ordering: { mode: "prioritized", priorities: ["learning", "new", "review"] } },
        { id: "new-review-learning", label: "New \u2192 Review \u2192 Learning", ordering: { mode: "prioritized", priorities: ["new", "review", "learning"] } },
        { id: "new-learning-review", label: "New \u2192 Learning \u2192 Review", ordering: { mode: "prioritized", priorities: ["new", "learning", "review"] } }
      ];
    }
  });

  // js/ui/components/quiz.js
  var quiz_exports = {};
  __export(quiz_exports, {
    renderQuiz: () => renderQuiz
  });
  function formatReviewInterval2(minutes) {
    if (!Number.isFinite(minutes) || minutes <= 0) return "Now";
    if (minutes < 60) return `${minutes} min`;
    const asHours = minutes / 60;
    if (asHours < 24) {
      const roundedHours = Number.isInteger(asHours) ? asHours : Math.round(asHours * 10) / 10;
      return `${roundedHours} hr`;
    }
    const asDays = minutes / 1440;
    if (asDays < 30) {
      const roundedDays = Number.isInteger(asDays) ? asDays : Math.round(asDays * 10) / 10;
      return `${roundedDays} day${roundedDays === 1 ? "" : "s"}`;
    }
    const asMonths = minutes / 43200;
    if (asMonths < 12) {
      const roundedMonths = Number.isInteger(asMonths) ? asMonths : Math.round(asMonths * 10) / 10;
      return `${roundedMonths} mo`;
    }
    const asYears = minutes / 525600;
    const roundedYears = Number.isInteger(asYears) ? asYears : Math.round(asYears * 10) / 10;
    return `${roundedYears} yr`;
  }
  function cloneSectionState2(state2) {
    if (!state2 || typeof state2 !== "object") return null;
    return JSON.parse(JSON.stringify(state2));
  }
  function titleOf3(item) {
    return item?.name || item?.concept || "";
  }
  function ratingKey2(item, sectionKey) {
    const id = item?.id || "item";
    return `${id}::${sectionKey}`;
  }
  function ensureSessionDefaults(session) {
    if (!session) return;
    if (!Array.isArray(session.pool)) session.pool = [];
    session.dict = session.pool.map((it) => ({
      id: it.id,
      title: titleOf3(it),
      lower: titleOf3(it).toLowerCase()
    }));
    if (!session.answers || typeof session.answers !== "object") {
      session.answers = {};
    }
    if (!session.ratings || typeof session.ratings !== "object") {
      session.ratings = {};
    }
    if (!session.ratingBaselines || typeof session.ratingBaselines !== "object") {
      session.ratingBaselines = {};
    }
    if (typeof session.idx !== "number" || Number.isNaN(session.idx)) {
      session.idx = 0;
    }
    session.idx = Math.max(0, Math.min(Math.floor(session.idx), session.pool.length ? session.pool.length - 1 : 0));
    if (typeof session.score !== "number" || Number.isNaN(session.score)) {
      session.score = computeScore(session.answers);
    }
  }
  function computeScore(answers) {
    if (!answers) return 0;
    return Object.values(answers).filter((entry) => entry && entry.isCorrect).length;
  }
  function renderCompletion(root2, session, redraw) {
    removeStudySession("quiz").catch((err) => console.warn("Failed to clear quiz session", err));
    const wrap = document.createElement("section");
    wrap.className = "card quiz-summary";
    const heading = document.createElement("h2");
    heading.textContent = "Quiz complete";
    wrap.appendChild(heading);
    const score = document.createElement("p");
    const total = Array.isArray(session.pool) ? session.pool.length : 0;
    score.textContent = `Score ${session.score}/${total}`;
    wrap.appendChild(score);
    const btn = document.createElement("button");
    btn.className = "btn";
    btn.textContent = "Back to builder";
    btn.addEventListener("click", () => {
      setQuizSession(null);
      setStudySelectedMode("Quiz");
      setSubtab("Study", "Builder");
      redraw();
    });
    wrap.appendChild(btn);
    root2.appendChild(wrap);
  }
  function renderQuiz(root2, redraw) {
    const session = state.quizSession;
    if (!session) {
      if (root2?.dataset) delete root2.dataset.questionIdx;
      return;
    }
    ensureSessionDefaults(session);
    const hasWindow = typeof window !== "undefined";
    const docScroller = typeof document !== "undefined" ? document.scrollingElement || document.documentElement : null;
    const previousIdxRaw = root2?.dataset?.questionIdx;
    const previousIdx = previousIdxRaw !== void 0 && previousIdxRaw !== "" && !Number.isNaN(Number(previousIdxRaw)) ? Number(previousIdxRaw) : null;
    const prevScrollY = hasWindow ? window.scrollY : docScroller ? docScroller.scrollTop : 0;
    const pool = Array.isArray(session.pool) ? session.pool : [];
    root2.innerHTML = "";
    if (root2?.dataset) delete root2.dataset.questionIdx;
    if (!pool.length) {
      const empty = document.createElement("div");
      empty.textContent = "No questions available. Select study cards to begin.";
      root2.appendChild(empty);
      return;
    }
    if (session.idx >= pool.length) {
      renderCompletion(root2, session, redraw);
      return;
    }
    const item = pool[session.idx];
    if (!item) {
      renderCompletion(root2, session, redraw);
      return;
    }
    const answer = session.answers[session.idx] || { value: "", isCorrect: false, checked: false, revealed: false };
    const hasResult = Boolean(answer.checked);
    const wasCorrect = hasResult && answer.isCorrect;
    const wasRevealed = hasResult && answer.revealed;
    const isSolved = wasCorrect || wasRevealed;
    const card = document.createElement("section");
    card.className = "card quiz-card";
    root2.appendChild(card);
    const header = document.createElement("div");
    header.className = "quiz-header";
    const headerInfo = document.createElement("div");
    headerInfo.className = "quiz-header-info";
    const progress = document.createElement("div");
    progress.className = "quiz-progress";
    progress.textContent = `Question ${session.idx + 1} of ${pool.length}`;
    headerInfo.appendChild(progress);
    const tally = document.createElement("div");
    tally.className = "quiz-score";
    tally.textContent = `Score: ${session.score}`;
    headerInfo.appendChild(tally);
    header.appendChild(headerInfo);
    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "icon-btn quiz-edit-btn";
    editBtn.innerHTML = "\u270F\uFE0F";
    editBtn.title = "Edit card";
    editBtn.setAttribute("aria-label", "Edit card");
    editBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const onSave = typeof redraw === "function" ? () => redraw() : void 0;
      openEditor(item.kind, onSave, item);
    });
    header.appendChild(editBtn);
    card.appendChild(header);
    const prompt2 = document.createElement("p");
    prompt2.className = "quiz-prompt";
    prompt2.textContent = "Identify the term based on the details below.";
    card.appendChild(prompt2);
    const details = document.createElement("div");
    details.className = "quiz-details";
    const sections = sectionsForItem(item);
    const sectionSnapshots = /* @__PURE__ */ new Map();
    const baselineStore = session.ratingBaselines;
    sections.forEach(({ key }) => {
      const snapshot = getSectionStateSnapshot(item, key);
      if (snapshot) {
        sectionSnapshots.set(key, snapshot);
        const baseKey = ratingKey2(item, key);
        if (!baselineStore[baseKey]) {
          baselineStore[baseKey] = cloneSectionState2(snapshot);
        }
      }
    });
    if (!sections.length) {
      const emptySection = document.createElement("div");
      emptySection.className = "quiz-empty";
      emptySection.textContent = "No card content available for this entry.";
      details.appendChild(emptySection);
    } else {
      sections.forEach(({ key, label, content, extra }) => {
        const block = document.createElement("div");
        block.className = "quiz-section";
        if (extra) block.classList.add("quiz-section-extra");
        const head = document.createElement("div");
        head.className = "quiz-section-title";
        head.textContent = label;
        block.appendChild(head);
        const body = document.createElement("div");
        body.className = "quiz-section-body";
        renderRichText(body, content || "", { clozeMode: "interactive" });
        block.appendChild(body);
        details.appendChild(block);
      });
    }
    card.appendChild(details);
    const form = document.createElement("form");
    form.className = "quiz-answer";
    const input = document.createElement("input");
    input.type = "text";
    input.autocomplete = "off";
    input.spellcheck = false;
    input.placeholder = "Type your answer";
    input.value = answer.value || "";
    form.appendChild(input);
    const suggestions = document.createElement("ul");
    suggestions.className = "quiz-suggestions";
    const suggestionId = `quiz-suggestions-${session.idx}`;
    suggestions.id = suggestionId;
    suggestions.setAttribute("role", "listbox");
    form.appendChild(suggestions);
    input.setAttribute("aria-controls", suggestionId);
    input.setAttribute("aria-autocomplete", "list");
    input.setAttribute("aria-expanded", "false");
    const actions = document.createElement("div");
    actions.className = "quiz-answer-actions";
    const checkBtn = document.createElement("button");
    checkBtn.type = "button";
    checkBtn.className = "btn quiz-check-btn";
    checkBtn.textContent = "Check";
    checkBtn.disabled = !input.value.trim();
    checkBtn.addEventListener("click", () => gradeAnswer());
    actions.appendChild(checkBtn);
    const revealBtn = document.createElement("button");
    revealBtn.type = "button";
    revealBtn.className = "btn secondary quiz-reveal-btn";
    revealBtn.textContent = "Show answer";
    revealBtn.hidden = !(hasResult && !wasCorrect && !wasRevealed);
    actions.appendChild(revealBtn);
    form.appendChild(actions);
    const feedback = document.createElement("div");
    feedback.className = "quiz-feedback";
    if (wasCorrect) {
      feedback.textContent = "Correct!";
      feedback.classList.add("is-correct");
    } else if (wasRevealed) {
      feedback.textContent = `Answer: ${titleOf3(item)}`;
      feedback.classList.add("is-incorrect");
    } else if (hasResult) {
      feedback.textContent = "Incorrect. Try again or reveal the answer.";
      feedback.classList.add("is-incorrect");
    }
    form.appendChild(feedback);
    card.appendChild(form);
    const suggestionButtons = [];
    const setActiveSuggestion = (target = null) => {
      suggestionButtons.forEach((btn) => {
        btn.setAttribute("aria-selected", btn === target ? "true" : "false");
      });
    };
    const clearSuggestions = () => {
      suggestionButtons.splice(0, suggestionButtons.length);
      suggestions.innerHTML = "";
      input.setAttribute("aria-expanded", "false");
      setActiveSuggestion(null);
    };
    const commitSuggestion = (value) => {
      input.value = value;
      clearSuggestions();
      checkBtn.disabled = !input.value.trim();
      input.focus();
    };
    const focusSuggestion = (index) => {
      const target = suggestionButtons[index];
      if (target) {
        target.focus();
        setActiveSuggestion(target);
      }
    };
    const renderSuggestions = (matches) => {
      clearSuggestions();
      if (!matches.length) return;
      const fragment = document.createDocumentFragment();
      matches.forEach((entry, idx) => {
        const li = document.createElement("li");
        li.setAttribute("role", "presentation");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "quiz-suggestion-btn";
        btn.textContent = entry.title;
        btn.dataset.index = String(idx);
        btn.setAttribute("role", "option");
        btn.setAttribute("aria-selected", "false");
        btn.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          commitSuggestion(entry.title);
        });
        btn.addEventListener("keydown", (event) => {
          if (event.key === "ArrowDown") {
            event.preventDefault();
            focusSuggestion(Math.min(suggestionButtons.length - 1, idx + 1));
          } else if (event.key === "ArrowUp") {
            event.preventDefault();
            if (idx === 0) {
              input.focus();
            } else {
              focusSuggestion(Math.max(0, idx - 1));
            }
          } else if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            commitSuggestion(entry.title);
          }
        });
        btn.addEventListener("focus", () => {
          setActiveSuggestion(btn);
        });
        btn.addEventListener("blur", () => {
          if (typeof document !== "undefined") {
            const active = document.activeElement;
            if (active instanceof HTMLElement && suggestionButtons.includes(active) && active.closest(`#${suggestionId}`)) {
              return;
            }
          }
          setActiveSuggestion(null);
        });
        li.appendChild(btn);
        fragment.appendChild(li);
        suggestionButtons.push(btn);
      });
      suggestions.appendChild(fragment);
      input.setAttribute("aria-expanded", "true");
    };
    const updateSuggestions = () => {
      checkBtn.disabled = !input.value.trim();
      const v = input.value.toLowerCase();
      const existing = session.answers[session.idx];
      if (existing && existing.checked) {
        const answers = { ...session.answers };
        delete answers[session.idx];
        session.answers = answers;
        session.score = computeScore(answers);
        setQuizSession({ ...session });
        feedback.textContent = "";
        feedback.classList.remove("is-correct", "is-incorrect");
        revealBtn.hidden = true;
        revealBtn.disabled = false;
        tally.textContent = `Score: ${session.score}`;
        updateNavState();
      }
      if (!v) {
        clearSuggestions();
        return;
      }
      const seen = /* @__PURE__ */ new Set();
      const orderedMatches = [];
      const consider = (entry) => {
        if (!entry || seen.has(entry.id || entry.title)) return;
        seen.add(entry.id || entry.title);
        orderedMatches.push(entry);
      };
      session.dict.filter((d) => d.lower.startsWith(v)).forEach(consider);
      session.dict.filter((d) => !d.lower.startsWith(v) && d.lower.includes(v)).forEach(consider);
      renderSuggestions(orderedMatches.slice(0, 5));
    };
    input.addEventListener("input", updateSuggestions);
    input.addEventListener("keydown", (event) => {
      if (event.key === "ArrowDown" && suggestionButtons.length) {
        event.preventDefault();
        focusSuggestion(0);
      }
    });
    input.addEventListener("blur", () => {
      setTimeout(() => {
        if (typeof document !== "undefined") {
          const active = document.activeElement;
          if (active instanceof HTMLElement && active.closest(`#${suggestionId}`)) return;
        }
        clearSuggestions();
      }, 0);
    });
    revealBtn.addEventListener("click", () => {
      const revealValue = titleOf3(item);
      const answers = { ...session.answers, [session.idx]: { value: revealValue, isCorrect: false, checked: true, revealed: true } };
      session.answers = answers;
      session.score = computeScore(answers);
      setQuizSession({ ...session });
      input.value = revealValue;
      feedback.textContent = `Answer: ${titleOf3(item)}`;
      feedback.classList.remove("is-correct");
      feedback.classList.add("is-incorrect");
      revealBtn.hidden = true;
      clearSuggestions();
      tally.textContent = `Score: ${session.score}`;
      updateNavState();
    });
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      gradeAnswer();
    });
    const durationsPromise = getReviewDurations().catch(() => ({ ...DEFAULT_REVIEW_STEPS }));
    const ratingPanel = document.createElement("div");
    ratingPanel.className = "quiz-rating-panel";
    card.appendChild(ratingPanel);
    const ratingRow = document.createElement("div");
    ratingRow.className = "quiz-rating-row";
    ratingPanel.appendChild(ratingRow);
    const options = document.createElement("div");
    options.className = "quiz-rating-options";
    ratingRow.appendChild(options);
    const status = document.createElement("span");
    status.className = "quiz-rating-status";
    status.textContent = "Optional: set a rating to queue this card.";
    const ratingId = ratingKey2(item, "__overall__");
    let selectedRating = session.ratings[ratingId] || null;
    let ratingLocked = Boolean(selectedRating);
    let adjustBtn = null;
    const ratingPreviews = /* @__PURE__ */ new Map();
    const updatePreviews = (durations) => {
      if (!durations) return;
      const nowTs = Date.now();
      const projectionSources = /* @__PURE__ */ new Map();
      const resolveSource = (sectionKey) => {
        if (projectionSources.has(sectionKey)) return projectionSources.get(sectionKey);
        const baseKey = ratingKey2(item, sectionKey);
        const baselineState = session.ratingBaselines[baseKey];
        if (!baselineState) {
          projectionSources.set(sectionKey, null);
          return null;
        }
        const clone6 = JSON.parse(JSON.stringify(item));
        if (!clone6.sr || typeof clone6.sr !== "object") clone6.sr = {};
        clone6.sr.version = clone6.sr.version || item.sr && item.sr.version || 1;
        clone6.sr.sections = clone6.sr.sections && typeof clone6.sr.sections === "object" ? { ...clone6.sr.sections } : {};
        clone6.sr.sections[sectionKey] = cloneSectionState2(baselineState);
        projectionSources.set(sectionKey, clone6);
        return clone6;
      };
      REVIEW_RATINGS.forEach((ratingValue) => {
        const target = ratingPreviews.get(ratingValue);
        if (!target) return;
        try {
          let soonestDue = null;
          sections.forEach(({ key }) => {
            const source = resolveSource(key);
            const projection = projectSectionRating(source || item, key, ratingValue, durations, nowTs);
            if (!projection || !Number.isFinite(projection.due)) return;
            if (soonestDue == null || projection.due < soonestDue) {
              soonestDue = projection.due;
            }
          });
          if (soonestDue == null) {
            target.textContent = "";
            return;
          }
          const minutes = Math.max(0, Math.round((soonestDue - nowTs) / (60 * 1e3)));
          target.textContent = formatReviewInterval2(minutes);
        } catch (err) {
          target.textContent = "";
        }
      });
    };
    const renderPreviews = async () => {
      try {
        const durations = await durationsPromise;
        updatePreviews(durations);
      } catch (err) {
      }
    };
    const clearStatusInteraction = () => {
      status.classList.remove("quiz-rating-status-action");
      status.removeAttribute("role");
      status.removeAttribute("tabindex");
      status.removeAttribute("aria-label");
    };
    const makeStatusInteractive = (ariaLabel = "") => {
      status.classList.add("quiz-rating-status-action");
      status.setAttribute("role", "button");
      status.setAttribute("tabindex", "0");
      if (ariaLabel) {
        status.setAttribute("aria-label", ariaLabel);
      }
    };
    const unlockRating = () => {
      if (!ratingLocked) return;
      ratingLocked = false;
      delete options.dataset.lock;
      clearStatusInteraction();
      if (adjustBtn) adjustBtn.hidden = true;
      delete ratingRow.dataset.state;
      Array.from(options.querySelectorAll("button")).forEach((btn) => {
        btn.disabled = !isSolved;
        btn.classList.remove("is-locked-choice");
      });
      status.classList.remove("is-error");
      status.textContent = selectedRating ? "Update rating (updates queue)" : "Optional: set a rating to queue this card.";
      renderPreviews();
    };
    const applySessionLock = () => {
      ratingLocked = true;
      options.dataset.lock = "session";
      Array.from(options.querySelectorAll("button")).forEach((btn) => {
        const isSelected = btn.dataset.value === selectedRating;
        btn.disabled = !isSelected;
        btn.classList.toggle("is-locked-choice", !isSelected);
      });
      status.classList.remove("is-error");
      ratingRow.dataset.state = "queued";
      status.textContent = "Queued for review \u2014 click to adjust";
      makeStatusInteractive("Adjust saved rating");
      if (adjustBtn) adjustBtn.hidden = false;
    };
    const activateStatus = (event) => {
      if (!ratingLocked) return;
      event.preventDefault();
      event.stopPropagation();
      unlockRating();
    };
    status.addEventListener("click", activateStatus);
    status.addEventListener("keydown", (event) => {
      if (!ratingLocked) return;
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        activateStatus(event);
      }
    });
    const updateSelection = (value) => {
      selectedRating = value;
      session.ratings[ratingId] = value;
      setQuizSession({ ...session });
      Array.from(options.querySelectorAll("button")).forEach((btn) => {
        const btnValue = btn.dataset.value;
        const isSelected = btnValue === value;
        btn.classList.toggle("is-selected", isSelected);
        btn.setAttribute("aria-pressed", isSelected ? "true" : "false");
      });
      status.classList.remove("is-error");
      updateNavState();
      renderPreviews();
    };
    const handleRating = async (value) => {
      const current = session.answers[session.idx];
      if (!(current && current.checked && (current.isCorrect || current.revealed))) return;
      if (ratingLocked) return;
      status.textContent = "Saving\u2026";
      status.classList.remove("is-error");
      try {
        const durations = await durationsPromise;
        const timestamp = Date.now();
        if (sections.length) {
          const sr = ensureItemSr(item);
          sr.sections = sr.sections || {};
          sections.forEach(({ key }) => {
            const baseKey = ratingKey2(item, key);
            const snapshot = sectionSnapshots.get(key);
            if (!session.ratingBaselines[baseKey] && snapshot) {
              session.ratingBaselines[baseKey] = cloneSectionState2(snapshot);
            }
            const stored = session.ratingBaselines[baseKey];
            if (stored) {
              sr.sections[key] = cloneSectionState2(stored);
            }
          });
          sections.forEach(({ key }) => rateSection(item, key, value, durations, timestamp));
          await upsertItem(item);
        }
        updateSelection(value);
        applySessionLock();
        updatePreviews(durations);
      } catch (err) {
        console.error("Failed to record quiz rating", err);
        status.textContent = "Save failed";
        status.classList.add("is-error");
      }
    };
    REVIEW_RATINGS.forEach((value) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.dataset.value = value;
      btn.className = "btn quiz-rating-btn";
      const variant = RATING_CLASS2[value];
      if (variant) btn.classList.add(variant);
      const labelEl = document.createElement("span");
      labelEl.className = "quiz-rating-btn-label";
      labelEl.textContent = RATING_LABELS2[value];
      const previewEl = document.createElement("span");
      previewEl.className = "quiz-rating-preview";
      btn.appendChild(labelEl);
      btn.appendChild(previewEl);
      ratingPreviews.set(value, previewEl);
      btn.disabled = !isSolved;
      btn.setAttribute("aria-pressed", "false");
      btn.addEventListener("click", () => handleRating(value));
      options.appendChild(btn);
    });
    renderPreviews();
    adjustBtn = document.createElement("button");
    adjustBtn.type = "button";
    adjustBtn.className = "quiz-rating-adjust";
    adjustBtn.textContent = "Adjust";
    adjustBtn.hidden = true;
    adjustBtn.setAttribute("aria-label", "Adjust rating");
    adjustBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      unlockRating();
    });
    adjustBtn.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        event.stopPropagation();
        unlockRating();
      }
    });
    if (selectedRating) {
      updateSelection(selectedRating);
      applySessionLock();
    } else {
      ratingLocked = false;
      delete options.dataset.lock;
      clearStatusInteraction();
      delete ratingRow.dataset.state;
    }
    if (!sections.length) {
      const note = document.createElement("div");
      note.className = "quiz-rating-note";
      note.textContent = "This card has no reviewable sections.";
      ratingPanel.appendChild(note);
    }
    ratingRow.appendChild(status);
    ratingRow.appendChild(adjustBtn);
    const controls = document.createElement("div");
    controls.className = "quiz-controls";
    const backBtn = document.createElement("button");
    backBtn.type = "button";
    backBtn.className = "btn secondary";
    backBtn.textContent = "Back";
    backBtn.disabled = pool.length === 0;
    backBtn.addEventListener("click", () => {
      const prevIdx = session.idx === 0 ? pool.length - 1 : session.idx - 1;
      setQuizSession({ ...session, idx: prevIdx });
      redraw();
    });
    controls.appendChild(backBtn);
    const nextBtn = document.createElement("button");
    nextBtn.type = "button";
    nextBtn.className = "btn";
    nextBtn.textContent = "Next";
    nextBtn.disabled = true;
    nextBtn.addEventListener("click", () => {
      const nextIdx = (session.idx + 1) % pool.length;
      setQuizSession({ ...session, idx: nextIdx });
      redraw();
    });
    controls.appendChild(nextBtn);
    card.appendChild(controls);
    const footer = document.createElement("div");
    footer.className = "quiz-footer";
    const saveExit = document.createElement("button");
    saveExit.type = "button";
    saveExit.className = "btn secondary";
    saveExit.textContent = "Save & close";
    saveExit.addEventListener("click", async () => {
      const original = saveExit.textContent;
      saveExit.disabled = true;
      saveExit.textContent = "Saving\u2026";
      try {
        await persistStudySession("quiz", {
          session: {
            ...session,
            idx: session.idx,
            pool,
            answers: session.answers,
            ratings: session.ratings
          },
          cohort: pool
        });
        setQuizSession(null);
        setStudySelectedMode("Quiz");
        setSubtab("Study", "Builder");
        redraw();
      } catch (err) {
        console.error("Failed to save quiz progress", err);
        saveExit.textContent = "Save failed";
        setTimeout(() => {
          saveExit.textContent = original;
        }, 2e3);
      } finally {
        saveExit.disabled = false;
      }
    });
    footer.appendChild(saveExit);
    card.appendChild(footer);
    updateNavState();
    if (root2?.dataset) root2.dataset.questionIdx = String(session.idx);
    const shouldRestore = previousIdx === session.idx;
    const targetY = shouldRestore ? prevScrollY : 0;
    const canRestore = hasWindow || docScroller;
    if (canRestore) {
      const applyScroll = () => {
        if (hasWindow && typeof window.scrollTo === "function") {
          window.scrollTo({ left: 0, top: targetY, behavior: "auto" });
        } else if (docScroller) {
          docScroller.scrollTop = targetY;
        }
      };
      if (hasWindow && typeof window.requestAnimationFrame === "function") {
        window.requestAnimationFrame(applyScroll);
      } else if (typeof setTimeout === "function") {
        setTimeout(applyScroll, 0);
      } else {
        applyScroll();
      }
    }
    function gradeAnswer() {
      const guess = input.value.trim();
      if (!guess) return;
      const normalized2 = guess.toLowerCase();
      const correct = titleOf3(item).toLowerCase();
      const isCorrect = normalized2 === correct;
      const answers = {
        ...session.answers,
        [session.idx]: { value: guess, isCorrect, checked: true, revealed: false }
      };
      const nextScore = computeScore(answers);
      session.answers = answers;
      session.score = nextScore;
      setQuizSession({ ...session });
      tally.textContent = `Score: ${session.score}`;
      feedback.textContent = isCorrect ? "Correct!" : "Incorrect. Try again or reveal the answer.";
      feedback.classList.remove("is-correct", "is-incorrect");
      feedback.classList.add(isCorrect ? "is-correct" : "is-incorrect");
      clearSuggestions();
      revealBtn.hidden = isCorrect;
      if (!isCorrect) {
        revealBtn.disabled = false;
        revealBtn.focus();
      }
      updateNavState();
    }
    function updateNavState() {
      const currentAnswer = session.answers[session.idx];
      const solved = Boolean(currentAnswer && currentAnswer.checked && (currentAnswer.isCorrect || currentAnswer.revealed));
      nextBtn.disabled = !solved;
      Array.from(options.querySelectorAll("button")).forEach((btn) => {
        btn.disabled = !solved;
      });
      if (!solved) {
        status.classList.remove("is-error");
        status.textContent = "Optional: rate your confidence after answering.";
      } else {
        revealBtn.hidden = true;
      }
    }
  }
  var RATING_LABELS2, RATING_CLASS2;
  var init_quiz = __esm({
    "js/ui/components/quiz.js"() {
      init_state();
      init_rich_text();
      init_study_sessions();
      init_section_utils();
      init_constants();
      init_scheduler2();
      init_storage();
      init_editor();
      RATING_LABELS2 = {
        again: "Again",
        hard: "Hard",
        good: "Good",
        easy: "Easy"
      };
      RATING_CLASS2 = {
        again: "danger",
        hard: "secondary",
        good: "",
        easy: ""
      };
    }
  });

  // js/ui/components/block-mode.js
  var block_mode_exports = {};
  __export(block_mode_exports, {
    renderBlockMode: () => renderBlockMode
  });
  function renderBlockMode(root2, redraw) {
    const shell = document.createElement("section");
    shell.className = "block-mode-shell";
    root2.appendChild(shell);
    drawBlockMode(shell, redraw);
  }
  function drawBlockMode(shell, globalRedraw) {
    shell.innerHTML = "";
    const redraw = () => drawBlockMode(shell, globalRedraw);
    const items = state.cohort || [];
    if (!items.length) {
      shell.appendChild(messageCard("Select study cards to unlock Blocks mode. Use the filters above to assemble a cohort."));
      return;
    }
    const sections = collectSections(items);
    if (!sections.length) {
      shell.appendChild(messageCard("The selected cards do not have structured sections yet. Add cards with rich content to practice in Blocks mode."));
      return;
    }
    let activeKey = state.blockMode.section;
    if (!activeKey || !sections.some((sec) => sec.key === activeKey)) {
      activeKey = sections[0].key;
      if (activeKey !== state.blockMode.section) {
        setBlockMode({ section: activeKey });
      }
    }
    const sectionData = sections.find((sec) => sec.key === activeKey) || sections[0];
    const entryMap = /* @__PURE__ */ new Map();
    sectionData.items.forEach((info) => {
      entryMap.set(entryIdFor(info.itemId, sectionData.key), info);
    });
    const validAssignments = sanitizeAssignments(sectionData.key, entryMap);
    const assignedSet = new Set(Object.values(validAssignments));
    const reveal = !!(state.blockMode.reveal && state.blockMode.reveal[sectionData.key]);
    const bankEntries = Array.from(entryMap.entries()).filter(([id]) => !assignedSet.has(id)).map(([entryId, info]) => ({ entryId, value: info.value, itemId: info.itemId }));
    const orderedBank = orderEntries(sectionData.key, bankEntries);
    const results = sectionData.items.map((info) => {
      const entryId = entryIdFor(info.itemId, sectionData.key);
      const assignedId = validAssignments[info.itemId];
      const assignedInfo = assignedId ? entryMap.get(assignedId) : null;
      const assignedValue = assignedInfo ? assignedInfo.value : "";
      const correct = assignedValue && normalized(assignedValue) === normalized(info.value);
      return { ...info, entryId, assignedId, assignedValue, correct };
    });
    const filledCount = results.filter((r) => r.assignedValue).length;
    const correctCount = results.filter((r) => r.correct).length;
    shell.appendChild(renderHeader({
      sections,
      activeKey: sectionData.key,
      filledCount,
      correctCount,
      total: results.length,
      bankRemaining: orderedBank.length,
      reveal,
      onSectionChange: (key) => {
        const nextReveal = { ...state.blockMode.reveal || {} };
        delete nextReveal[key];
        setBlockMode({ section: key, reveal: nextReveal });
        redraw();
      },
      onCheck: () => {
        const nextReveal = { ...state.blockMode.reveal || {} };
        nextReveal[sectionData.key] = true;
        setBlockMode({ reveal: nextReveal });
        redraw();
      },
      onReset: () => {
        const assignments = { ...state.blockMode.assignments || {} };
        assignments[sectionData.key] = {};
        const revealMap = { ...state.blockMode.reveal || {} };
        delete revealMap[sectionData.key];
        setBlockMode({ assignments, reveal: revealMap });
        redraw();
      }
    }));
    const board = document.createElement("div");
    board.className = "block-mode-board";
    results.forEach((result) => {
      board.appendChild(renderBlockCard({
        sectionLabel: sectionData.label,
        reveal,
        result,
        onRemove: () => {
          const assignments = { ...state.blockMode.assignments || {} };
          const nextSectionAssignments = { ...assignments[sectionData.key] || {} };
          delete nextSectionAssignments[result.itemId];
          assignments[sectionData.key] = nextSectionAssignments;
          const revealMap = { ...state.blockMode.reveal || {} };
          delete revealMap[sectionData.key];
          setBlockMode({ assignments, reveal: revealMap });
          redraw();
        },
        onDrop: (entryId) => {
          const info = entryMap.get(entryId);
          if (!info) return;
          const assignments = { ...state.blockMode.assignments || {} };
          const nextSectionAssignments = { ...assignments[sectionData.key] || {} };
          for (const [itemId, assigned] of Object.entries(nextSectionAssignments)) {
            if (assigned === entryId) delete nextSectionAssignments[itemId];
          }
          nextSectionAssignments[result.itemId] = entryId;
          assignments[sectionData.key] = nextSectionAssignments;
          const revealMap = { ...state.blockMode.reveal || {} };
          delete revealMap[sectionData.key];
          setBlockMode({ assignments, reveal: revealMap });
          redraw();
        }
      }));
    });
    shell.appendChild(board);
    shell.appendChild(renderBank({
      label: sectionData.label,
      entries: orderedBank
    }));
    shell.appendChild(renderFooter({
      globalRedraw,
      sectionLabel: sectionData.label,
      filledCount,
      total: results.length
    }));
  }
  function snapshotBlockState() {
    const source = state.blockMode || {};
    const clone6 = (value) => deepClone(value ?? {});
    return {
      section: source.section || "",
      assignments: clone6(source.assignments),
      reveal: clone6(source.reveal),
      order: clone6(source.order)
    };
  }
  function renderFooter({ globalRedraw, sectionLabel, filledCount, total }) {
    const card = document.createElement("div");
    card.className = "card block-mode-footer";
    const status = document.createElement("div");
    status.className = "block-mode-footer-status";
    if (total > 0) {
      status.textContent = filledCount ? `Progress saved for ${filledCount}/${total} prompts` : "No assignments yet";
    } else {
      status.textContent = "No prompts in this section yet.";
    }
    card.appendChild(status);
    const actions = document.createElement("div");
    actions.className = "block-mode-footer-actions";
    const saveBtn = document.createElement("button");
    saveBtn.type = "button";
    saveBtn.className = "btn";
    saveBtn.textContent = "Save & exit";
    saveBtn.addEventListener("click", async () => {
      const original = saveBtn.textContent;
      saveBtn.disabled = true;
      saveBtn.textContent = "Saving\u2026";
      try {
        const snapshot = snapshotBlockState();
        await persistStudySession("blocks", {
          session: snapshot,
          cohort: state.cohort,
          metadata: {
            label: sectionLabel ? `Blocks \u2013 ${sectionLabel}` : "Blocks session"
          }
        });
        resetBlockMode();
        setStudySelectedMode("Blocks");
        setSubtab("Study", "Builder");
        if (typeof globalRedraw === "function") {
          globalRedraw();
        }
      } catch (err) {
        console.error("Failed to save blocks progress", err);
        saveBtn.textContent = "Save failed";
        setTimeout(() => {
          saveBtn.textContent = original;
        }, 2e3);
      } finally {
        saveBtn.disabled = false;
      }
    });
    actions.appendChild(saveBtn);
    const exitBtn = document.createElement("button");
    exitBtn.type = "button";
    exitBtn.className = "btn secondary";
    exitBtn.textContent = "Exit without saving";
    exitBtn.addEventListener("click", async () => {
      exitBtn.disabled = true;
      try {
        await removeStudySession("blocks").catch((err) => console.warn("Failed to discard blocks session", err));
      } finally {
        resetBlockMode();
        setStudySelectedMode("Blocks");
        setSubtab("Study", "Builder");
        if (typeof globalRedraw === "function") {
          globalRedraw();
        }
      }
    });
    actions.appendChild(exitBtn);
    card.appendChild(actions);
    return card;
  }
  function renderHeader({ sections, activeKey, filledCount, correctCount, total, bankRemaining, reveal, onSectionChange, onCheck, onReset }) {
    const card = document.createElement("div");
    card.className = "card block-mode-header";
    const titleRow = document.createElement("div");
    titleRow.className = "block-mode-header-row";
    const title = document.createElement("h2");
    title.textContent = "Blocks Mode";
    titleRow.appendChild(title);
    const selectWrap = document.createElement("label");
    selectWrap.className = "block-mode-select";
    const selectLabel = document.createElement("span");
    selectLabel.textContent = "Section";
    selectWrap.appendChild(selectLabel);
    const select = document.createElement("select");
    sections.forEach((sec) => {
      const opt = document.createElement("option");
      opt.value = sec.key;
      opt.textContent = sec.label;
      if (sec.key === activeKey) opt.selected = true;
      select.appendChild(opt);
    });
    select.addEventListener("change", () => onSectionChange(select.value));
    selectWrap.appendChild(select);
    titleRow.appendChild(selectWrap);
    card.appendChild(titleRow);
    const meta = document.createElement("div");
    meta.className = "block-mode-meta-row";
    const placed = document.createElement("span");
    placed.textContent = `Placed: ${filledCount}/${total}`;
    meta.appendChild(placed);
    if (reveal) {
      const score = document.createElement("span");
      score.textContent = `Correct: ${correctCount}/${total}`;
      meta.appendChild(score);
    }
    const bankInfo = document.createElement("span");
    bankInfo.textContent = `In bank: ${bankRemaining}`;
    meta.appendChild(bankInfo);
    card.appendChild(meta);
    const actions = document.createElement("div");
    actions.className = "block-mode-actions";
    const checkBtn = document.createElement("button");
    checkBtn.type = "button";
    checkBtn.className = "btn";
    checkBtn.textContent = "Check answers";
    checkBtn.disabled = !filledCount;
    checkBtn.addEventListener("click", onCheck);
    actions.appendChild(checkBtn);
    const resetBtn = document.createElement("button");
    resetBtn.type = "button";
    resetBtn.className = "btn secondary";
    resetBtn.textContent = "Reset section";
    resetBtn.disabled = !filledCount;
    resetBtn.addEventListener("click", onReset);
    actions.appendChild(resetBtn);
    card.appendChild(actions);
    return card;
  }
  function renderBlockCard({ sectionLabel, reveal, result, onRemove, onDrop }) {
    const card = document.createElement("div");
    card.className = "card block-mode-card";
    const title = document.createElement("div");
    title.className = "block-mode-card-title";
    title.textContent = itemTitle(result.item);
    card.appendChild(title);
    const subtitle = document.createElement("div");
    subtitle.className = "block-mode-card-subtitle";
    subtitle.textContent = formatItemContext(result.item);
    if (subtitle.textContent) card.appendChild(subtitle);
    const slot = document.createElement("div");
    slot.className = "block-mode-slot";
    slot.dataset.itemId = result.itemId;
    slot.dataset.section = sectionLabel;
    slot.addEventListener("dragover", (event) => {
      event.preventDefault();
      slot.classList.add("drag-over");
    });
    slot.addEventListener("dragenter", (event) => {
      event.preventDefault();
      slot.classList.add("drag-over");
    });
    slot.addEventListener("dragleave", () => {
      slot.classList.remove("drag-over");
    });
    slot.addEventListener("drop", (event) => {
      event.preventDefault();
      slot.classList.remove("drag-over");
      const entryId = event.dataTransfer.getData("text/plain");
      if (entryId) onDrop(entryId);
    });
    if (result.assignedValue) {
      slot.classList.add("filled");
      const chip = document.createElement("div");
      chip.className = "block-chip assigned";
      const text = document.createElement("div");
      text.className = "block-chip-text";
      text.textContent = result.assignedValue;
      chip.appendChild(text);
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "chip-remove";
      removeBtn.textContent = "\xD7";
      removeBtn.addEventListener("click", onRemove);
      chip.appendChild(removeBtn);
      slot.appendChild(chip);
    } else {
      const placeholder = document.createElement("div");
      placeholder.className = "block-slot-placeholder";
      placeholder.textContent = `Drop ${sectionLabel.toLowerCase()} here`;
      slot.appendChild(placeholder);
    }
    card.appendChild(slot);
    if (reveal) {
      slot.classList.add(result.correct ? "correct" : result.assignedValue ? "incorrect" : "missing");
      if (!result.correct) {
        const answer = document.createElement("div");
        answer.className = "block-mode-answer";
        const label = document.createElement("span");
        label.textContent = "Answer";
        const body = document.createElement("div");
        body.textContent = result.value;
        answer.appendChild(label);
        answer.appendChild(body);
        card.appendChild(answer);
      }
    }
    return card;
  }
  function renderBank({ label, entries, onPick }) {
    const card = document.createElement("div");
    card.className = "card block-mode-bank";
    const title = document.createElement("div");
    title.className = "block-mode-bank-title";
    title.textContent = `${label} bank`;
    card.appendChild(title);
    const list = document.createElement("div");
    list.className = "block-mode-bank-items";
    if (!entries.length) {
      const empty = document.createElement("div");
      empty.className = "block-mode-bank-empty";
      empty.textContent = "All matches placed!";
      list.appendChild(empty);
    } else {
      entries.forEach((entry) => {
        const chip = document.createElement("div");
        chip.className = "block-chip";
        chip.textContent = entry.value;
        chip.draggable = true;
        chip.addEventListener("dragstart", (event) => {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", entry.entryId);
          chip.classList.add("dragging");
        });
        chip.addEventListener("dragend", () => chip.classList.remove("dragging"));
        if (onPick) {
          chip.addEventListener("click", () => onPick(entry.entryId));
        }
        list.appendChild(chip);
      });
    }
    card.appendChild(list);
    return card;
  }
  function collectSections(items) {
    const map = /* @__PURE__ */ new Map();
    items.forEach((item, index) => {
      const itemId = resolveItemId(item, index);
      sectionDefsForKind(item.kind).forEach((def) => {
        const value = sectionValue(item[def.key]);
        if (!value) return;
        let section = map.get(def.key);
        if (!section) {
          section = { key: def.key, label: def.label, items: [] };
          map.set(def.key, section);
        }
        section.items.push({ item, itemId, value });
      });
    });
    return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label));
  }
  function sanitizeAssignments(sectionKey, entryMap) {
    const current = state.blockMode.assignments && state.blockMode.assignments[sectionKey] || {};
    let changed = false;
    const valid = {};
    for (const [itemId, entryId] of Object.entries(current)) {
      if (entryMap.has(entryId)) {
        valid[itemId] = entryId;
      } else {
        changed = true;
      }
    }
    if (changed) {
      const assignments = { ...state.blockMode.assignments || {} };
      assignments[sectionKey] = valid;
      setBlockMode({ assignments });
    }
    return valid;
  }
  function orderEntries(sectionKey, entries) {
    const ids = entries.map((entry) => entry.entryId);
    const existing = state.blockMode.order && state.blockMode.order[sectionKey] || [];
    const filtered = existing.filter((id) => ids.includes(id));
    const missing = ids.filter((id) => !filtered.includes(id));
    const next = filtered.concat(missing);
    if (!arraysEqual2(existing, next)) {
      const order = { ...state.blockMode.order || {} };
      order[sectionKey] = next;
      setBlockMode({ order });
    }
    const byId = new Map(entries.map((entry) => [entry.entryId, entry]));
    return next.map((id) => byId.get(id)).filter(Boolean);
  }
  function entryIdFor(itemId, sectionKey) {
    return `${itemId}::${sectionKey}`;
  }
  function sectionValue(raw) {
    if (raw == null) return "";
    const text = typeof raw === "string" ? raw : String(raw);
    const sanitized = sanitizeHtml(text);
    const template = document.createElement("template");
    template.innerHTML = sanitized;
    return template.content.textContent?.trim() || "";
  }
  function normalized(text) {
    return sectionValue(text).replace(/\s+/g, " ").toLowerCase();
  }
  function resolveItemId(item, index) {
    return item.id || item.uid || item.slug || item.key || `${item.kind || "item"}-${index}`;
  }
  function itemTitle(item) {
    return item.name || item.concept || item.title || "Card";
  }
  function formatItemContext(item) {
    const parts = [];
    if (item.kind) parts.push(capitalize(item.kind));
    if (Array.isArray(item.lectures) && item.lectures.length) {
      const lectureNames = item.lectures.map((l) => l.name).filter(Boolean);
      if (lectureNames.length) parts.push(lectureNames.join(", "));
    }
    return parts.join(" \u2022 ");
  }
  function capitalize(text) {
    if (!text) return "";
    return text.charAt(0).toUpperCase() + text.slice(1);
  }
  function arraysEqual2(a, b) {
    if (a.length !== b.length) return false;
    return a.every((val, idx) => val === b[idx]);
  }
  function messageCard(text) {
    const card = document.createElement("div");
    card.className = "card block-mode-empty";
    card.textContent = text;
    return card;
  }
  var init_block_mode = __esm({
    "js/ui/components/block-mode.js"() {
      init_state();
      init_rich_text();
      init_sections();
      init_study_sessions();
      init_utils();
    }
  });

  // js/ui/components/block-board.js
  var block_board_exports = {};
  __export(block_board_exports, {
    __setBlockBoardDeps: () => __setBlockBoardDeps,
    renderBlockBoard: () => renderBlockBoard
  });
  function __setBlockBoardDeps({ loadBlockCatalog: loadFn, listAllLectures: listFn, saveLecture: saveFn, getSettings: settingsFn } = {}) {
    loadCatalog = typeof loadFn === "function" ? loadFn : loadBlockCatalog;
    fetchLectures2 = typeof listFn === "function" ? listFn : listAllLectures;
    persistLecture = typeof saveFn === "function" ? saveFn : saveLecture;
    fetchSettings = typeof settingsFn === "function" ? settingsFn : getSettings;
  }
  function ensureBoardState() {
    if (!state.blockBoard) {
      state.blockBoard = {
        collapsedBlocks: [],
        hiddenTimelines: [],
        autoCollapsed: [],
        autoHidden: [],
        manualExpanded: [],
        manualTimeline: []
      };
    }
    if (!Array.isArray(state.blockBoard.collapsedBlocks)) {
      state.blockBoard.collapsedBlocks = [];
    }
    if (!Array.isArray(state.blockBoard.hiddenTimelines)) {
      state.blockBoard.hiddenTimelines = [];
      if (state.blockBoard.showDensity === false && !state.blockBoard.hiddenTimelines.includes("__all__")) {
        state.blockBoard.hiddenTimelines.push("__all__");
      }
    }
    if (!Array.isArray(state.blockBoard.autoCollapsed)) {
      state.blockBoard.autoCollapsed = [];
    }
    if (!Array.isArray(state.blockBoard.autoHidden)) {
      state.blockBoard.autoHidden = [];
    }
    if (!Array.isArray(state.blockBoard.manualExpanded)) {
      state.blockBoard.manualExpanded = [];
    }
    if (!Array.isArray(state.blockBoard.manualTimeline)) {
      state.blockBoard.manualTimeline = [];
    }
    return state.blockBoard;
  }
  function passColor(order = 1) {
    return passColorForOrder(order);
  }
  function startOfDay2(timestamp) {
    const date = new Date(timestamp);
    date.setHours(0, 0, 0, 0);
    return date.getTime();
  }
  function shiftDay(dayTs, offset = 0) {
    if (!Number.isFinite(dayTs)) return null;
    const date = new Date(dayTs);
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + offset);
    date.setHours(0, 0, 0, 0);
    return date.getTime();
  }
  function enumerateDaySpan(startDay, totalDays) {
    if (!Number.isFinite(startDay) || !Number.isFinite(totalDays) || totalDays <= 0) {
      return [];
    }
    const days = [];
    const cursor = new Date(startDay);
    cursor.setHours(0, 0, 0, 0);
    const count = Math.max(0, Math.floor(totalDays));
    for (let i = 0; i < count; i += 1) {
      const value = cursor.getTime();
      if (!days.length || days[days.length - 1] !== value) {
        days.push(value);
      }
      cursor.setDate(cursor.getDate() + 1);
      cursor.setHours(0, 0, 0, 0);
    }
    return days;
  }
  function enumerateDayRange(startDay, endDay) {
    if (!Number.isFinite(startDay) || !Number.isFinite(endDay)) return [];
    if (endDay < startDay) return [];
    const days = [];
    const cursor = new Date(startDay);
    cursor.setHours(0, 0, 0, 0);
    const safetyLimit = 3660;
    for (let i = 0; i < safetyLimit; i += 1) {
      const value = cursor.getTime();
      if (value > endDay) break;
      if (!days.length || days[days.length - 1] !== value) {
        days.push(value);
      }
      cursor.setDate(cursor.getDate() + 1);
      cursor.setHours(0, 0, 0, 0);
    }
    return days;
  }
  function formatDay(timestamp) {
    const date = new Date(Number(timestamp));
    const formatter = new Intl.DateTimeFormat(void 0, { weekday: "short", month: "short", day: "numeric" });
    return formatter.format(date);
  }
  function parseBlockDate2(value) {
    if (!value) return null;
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return null;
    return date;
  }
  function formatBlockDate2(value) {
    const date = parseBlockDate2(value);
    if (!date) return null;
    return BLOCK_RANGE_FORMAT.format(date);
  }
  function blockRangeLabel(block) {
    const start = formatBlockDate2(block?.startDate);
    const end = formatBlockDate2(block?.endDate);
    if (start && end) return `${start} \u2192 ${end}`;
    if (start) return `Starts ${start}`;
    if (end) return `Ends ${end}`;
    return null;
  }
  function blockSpanDays(block) {
    const start = parseBlockDate2(block?.startDate);
    const end = parseBlockDate2(block?.endDate);
    if (!start || !end) return null;
    const diff = end.getTime() - start.getTime();
    if (diff < 0) return null;
    return Math.round(diff / DAY_MS2) + 1;
  }
  function normalizeShiftUnit(id) {
    if (typeof id !== "string") return "days";
    const normalized2 = SHIFT_OFFSET_UNITS.find((option) => option.id === id);
    return normalized2 ? normalized2.id : "days";
  }
  function combineShiftValueUnit(value, unitId) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) {
      return 0;
    }
    const unit = SHIFT_OFFSET_UNITS.find((option) => option.id === normalizeShiftUnit(unitId)) || SHIFT_OFFSET_UNITS[2];
    return Math.max(0, Math.round(numeric * unit.minutes));
  }
  function buildScopeOptions(mode2) {
    if (mode2 === "pull") {
      return [
        { id: "single", label: "Only this pass" },
        { id: "chain-before", label: "This & preceding passes" }
      ];
    }
    return [
      { id: "single", label: "Only this pass" },
      { id: "chain-after", label: "This & following passes" }
    ];
  }
  function openShiftDialog(mode2, { title, description, defaultValue = 1, defaultUnit = "days" } = {}) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.className = "modal block-board-shift-modal";
      const card = document.createElement("div");
      card.className = "card block-board-shift-card";
      const heading = document.createElement("h3");
      heading.textContent = title || (mode2 === "push" ? "Push later" : "Pull earlier");
      card.appendChild(heading);
      if (description) {
        const desc = document.createElement("p");
        desc.className = "block-board-shift-description";
        desc.textContent = description;
        card.appendChild(desc);
      }
      const fields = document.createElement("div");
      fields.className = "block-board-shift-fields";
      const amountField = document.createElement("label");
      amountField.className = "block-board-shift-field";
      amountField.textContent = "Amount";
      const amountInput = document.createElement("input");
      amountInput.type = "number";
      amountInput.className = "input block-board-shift-input";
      amountInput.min = "0";
      amountInput.step = "1";
      amountInput.value = String(defaultValue);
      amountField.appendChild(amountInput);
      fields.appendChild(amountField);
      const unitField = document.createElement("label");
      unitField.className = "block-board-shift-field";
      unitField.textContent = "Unit";
      const unitSelect = document.createElement("select");
      unitSelect.className = "input block-board-shift-unit";
      SHIFT_OFFSET_UNITS.forEach((option) => {
        const opt = document.createElement("option");
        opt.value = option.id;
        opt.textContent = option.label;
        unitSelect.appendChild(opt);
      });
      unitSelect.value = normalizeShiftUnit(defaultUnit);
      unitField.appendChild(unitSelect);
      fields.appendChild(unitField);
      card.appendChild(fields);
      const scopeGroup = document.createElement("fieldset");
      scopeGroup.className = "block-board-shift-scope";
      const legend = document.createElement("legend");
      legend.textContent = "Scope";
      scopeGroup.appendChild(legend);
      const scopeInputs = [];
      buildScopeOptions(mode2).forEach((option, index) => {
        const wrapper = document.createElement("label");
        wrapper.className = "block-board-shift-scope-option";
        const input = document.createElement("input");
        input.type = "radio";
        input.name = "block-board-shift-scope";
        input.value = option.id;
        if (index === 0) input.checked = true;
        const span = document.createElement("span");
        span.textContent = option.label;
        wrapper.appendChild(input);
        wrapper.appendChild(span);
        scopeGroup.appendChild(wrapper);
        scopeInputs.push(input);
      });
      card.appendChild(scopeGroup);
      const feedback = document.createElement("div");
      feedback.className = "block-board-shift-error";
      card.appendChild(feedback);
      const actions = document.createElement("div");
      actions.className = "block-board-shift-actions";
      const confirm = document.createElement("button");
      confirm.type = "button";
      confirm.className = "btn";
      confirm.textContent = mode2 === "push" ? "Push later" : "Pull earlier";
      const cancel2 = document.createElement("button");
      cancel2.type = "button";
      cancel2.className = "btn secondary";
      cancel2.textContent = "Cancel";
      actions.appendChild(confirm);
      actions.appendChild(cancel2);
      card.appendChild(actions);
      function cleanup(result) {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
        }
        resolve(result);
      }
      confirm.addEventListener("click", () => {
        const minutes = combineShiftValueUnit(amountInput.value, unitSelect.value);
        if (!Number.isFinite(minutes) || minutes <= 0) {
          feedback.textContent = "Enter a value greater than zero.";
          feedback.classList.add("is-visible");
          amountInput.focus();
          return;
        }
        const selectedScope = scopeInputs.find((input) => input.checked)?.value || "single";
        cleanup({ minutes, scope: selectedScope });
      });
      cancel2.addEventListener("click", () => cleanup(null));
      overlay.addEventListener("click", (event) => {
        if (event.target === overlay) {
          cleanup(null);
        }
      });
      overlay.appendChild(card);
      document.body.appendChild(overlay);
      amountInput.focus({ preventScroll: true });
    });
  }
  function shiftPassesForScope(lecture, passOrder, deltaMinutes, scope) {
    if (!lecture || typeof lecture !== "object") return lecture;
    const targetOrder = Number(passOrder);
    if (!Number.isFinite(targetOrder)) return lecture;
    const delta = Number(deltaMinutes);
    if (!Number.isFinite(delta) || delta === 0) return lecture;
    const passes = Array.isArray(lecture.passes) ? lecture.passes.map((pass) => ({ ...pass })) : [];
    if (!passes.length) return lecture;
    const shiftMs = Math.round(delta * 60 * 1e3);
    const normalizedScope = scope === "chain-after" || scope === "chain-before" ? scope : "single";
    passes.forEach((pass) => {
      const order = Number(pass?.order);
      if (!Number.isFinite(order)) return;
      const inScope = normalizedScope === "chain-after" ? order >= targetOrder : normalizedScope === "chain-before" ? order <= targetOrder : order === targetOrder;
      if (!inScope) return;
      if (!Number.isFinite(pass?.due)) return;
      if (Number.isFinite(pass?.completedAt)) return;
      const nextDue = Math.max(0, Math.round(pass.due + shiftMs));
      pass.due = nextDue;
    });
    const status = deriveLectureStatus(passes, lecture.status);
    const nextDueAt = calculateNextDue(passes);
    return {
      ...lecture,
      passes,
      status,
      nextDueAt
    };
  }
  function collectTimelineSegments(blockLectures, days) {
    const dayMap = new Map(days.map((day) => [day, []]));
    blockLectures.forEach((lecture) => {
      const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
      passes.forEach((pass) => {
        if (!pass) return;
        const due = Number(pass?.due);
        if (!Number.isFinite(due)) return;
        const dayKey = startOfDay2(due);
        if (!dayMap.has(dayKey)) return;
        dayMap.get(dayKey).push({
          lecture,
          pass,
          order: Number(pass?.order),
          completed: Number.isFinite(pass?.completedAt)
        });
      });
    });
    return days.map((day) => {
      const entries = (dayMap.get(day) || []).slice().sort((a, b) => {
        if (a.completed !== b.completed) return a.completed ? 1 : -1;
        const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
        const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
        if (orderA !== orderB) return orderA - orderB;
        const nameA = a.lecture?.name || "";
        const nameB = b.lecture?.name || "";
        return nameA.localeCompare(nameB);
      });
      return { day, entries };
    });
  }
  function formatPassDueLabel(due) {
    if (!Number.isFinite(due)) return "";
    const date = new Date(due);
    const datePart = PASS_DUE_FORMAT2.format(date);
    const timePart = PASS_TIME_FORMAT2.format(date);
    return `${datePart} \u2022 ${timePart}`;
  }
  function collectDefaultBoardDays(now = Date.now()) {
    const today = startOfDay2(now);
    const start = shiftDay(today, -2);
    return enumerateDaySpan(start != null ? start : today, DEFAULT_BOARD_DAYS);
  }
  function collectLectureDueRange(lectures) {
    let start = null;
    let end = null;
    if (!Array.isArray(lectures)) return { start, end };
    lectures.forEach((lecture) => {
      const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
      passes.forEach((pass) => {
        const due = Number(pass?.due);
        if (!Number.isFinite(due)) return;
        const day = startOfDay2(due);
        if (start == null || day < start) start = day;
        if (end == null || day > end) end = day;
      });
    });
    return { start, end };
  }
  function collectDaysForBlock(block, lectures = [], now = Date.now()) {
    const startDate = parseBlockDate2(block?.startDate);
    const endDate = parseBlockDate2(block?.endDate);
    const dueRange = collectLectureDueRange(lectures);
    const weeks = Number(block?.weeks);
    let startDay = startDate ? startOfDay2(startDate.getTime()) : null;
    let endDay = endDate ? startOfDay2(endDate.getTime()) : null;
    if (Number.isFinite(weeks) && weeks > 0) {
      const totalDays = Math.max(1, Math.round(weeks * 7));
      if (startDay != null && endDay == null) {
        endDay = startDay + (totalDays - 1) * DAY_MS2;
      } else if (endDay != null && startDay == null) {
        startDay = endDay - (totalDays - 1) * DAY_MS2;
      }
    }
    if (dueRange.start != null) {
      startDay = startDay == null ? dueRange.start : Math.min(startDay, dueRange.start);
    }
    if (dueRange.end != null) {
      endDay = endDay == null ? dueRange.end : Math.max(endDay, dueRange.end);
    }
    if (startDay != null && endDay != null && endDay >= startDay) {
      const spanDays = Math.floor((endDay - startDay) / DAY_MS2) + 1;
      if (spanDays < 3) {
        const deficit = 3 - spanDays;
        const padBefore = Math.ceil(deficit / 2);
        const padAfter = deficit - padBefore;
        const paddedStart = shiftDay(startDay, -padBefore);
        const paddedEnd = shiftDay(endDay, padAfter);
        startDay = paddedStart != null ? paddedStart : startDay;
        endDay = paddedEnd != null ? paddedEnd : endDay;
      }
      return enumerateDayRange(startDay, endDay);
    }
    if (Number.isFinite(weeks) && weeks > 0) {
      const totalDays = Math.max(1, Math.round(weeks * 7));
      const anchor = dueRange.start != null ? dueRange.start : startOfDay2(now);
      return enumerateDaySpan(anchor, totalDays);
    }
    if (dueRange.start != null && dueRange.end != null && dueRange.end >= dueRange.start) {
      return enumerateDayRange(dueRange.start, dueRange.end);
    }
    if (startDate) {
      const start = startOfDay2(startDate.getTime());
      return enumerateDaySpan(start, 7);
    }
    return [];
  }
  function buildPassElement(entry, onComplete, onShift) {
    const chip = document.createElement("div");
    chip.className = "block-board-pass-chip";
    chip.style.setProperty("--chip-accent", passColor(entry?.pass?.order));
    const chipComplete = Number.isFinite(entry?.pass?.completedAt);
    chip.classList.toggle("is-complete", chipComplete);
    chip.classList.toggle("is-pending", !chipComplete);
    chip.dataset.passOrder = String(entry?.pass?.order ?? "");
    const title = document.createElement("div");
    title.className = "block-board-pass-title";
    title.textContent = entry?.lecture?.name || `Lecture ${entry?.lecture?.id}`;
    chip.appendChild(title);
    const meta = document.createElement("div");
    meta.className = "block-board-pass-meta";
    const label = entry?.pass?.label || `Pass ${entry?.pass?.order ?? ""}`;
    const action = entry?.pass?.action ? entry.pass.action : "";
    const dueLabel = Number.isFinite(entry?.pass?.due) ? formatPassDueLabel(entry.pass.due) : "Unscheduled";
    const parts = [label];
    if (action) parts.push(action);
    if (dueLabel) parts.push(dueLabel);
    meta.textContent = parts.join(" \u2022 ");
    chip.appendChild(meta);
    const actions = document.createElement("div");
    actions.className = "block-board-pass-actions";
    const done = document.createElement("button");
    done.type = "button";
    done.className = "btn tertiary";
    done.textContent = "Mark done";
    done.addEventListener("click", () => {
      chip.classList.add("is-complete");
      chip.classList.remove("is-pending");
      onComplete(entry);
    });
    actions.appendChild(done);
    if (typeof onShift === "function") {
      const push = document.createElement("button");
      push.type = "button";
      push.className = "btn tertiary";
      push.textContent = "Push";
      push.addEventListener("click", () => onShift(entry, "push"));
      actions.appendChild(push);
      const pull = document.createElement("button");
      pull.type = "button";
      pull.className = "btn tertiary";
      pull.textContent = "Pull";
      pull.addEventListener("click", () => onShift(entry, "pull"));
      actions.appendChild(pull);
    }
    chip.appendChild(actions);
    return chip;
  }
  function applyPassDueUpdate(lecture, passOrder, newDue) {
    const passes = Array.isArray(lecture?.passes) ? lecture.passes.map((pass) => ({ ...pass })) : [];
    const index = passes.findIndex((pass) => pass?.order === passOrder);
    if (index >= 0) {
      passes[index] = { ...passes[index], due: newDue ?? null };
      if (!Number.isFinite(newDue)) {
        passes[index].due = null;
      }
      passes[index].completedAt = passes[index].completedAt ?? null;
      if (passes[index].completedAt && newDue && newDue > passes[index].completedAt) {
        passes[index].completedAt = null;
      }
    }
    const status = deriveLectureStatus(passes, lecture?.status);
    const nextDueAt = calculateNextDue(passes);
    return { ...lecture, passes, status, nextDueAt };
  }
  function createPassCard(entry, onDrag) {
    const card = document.createElement("div");
    card.className = "block-board-pass-card";
    card.draggable = true;
    card.style.setProperty("--card-accent", passColor(entry?.pass?.order));
    const isComplete = Number.isFinite(entry?.pass?.completedAt);
    card.classList.toggle("is-complete", isComplete);
    card.classList.toggle("is-pending", !isComplete);
    card.dataset.blockId = entry?.lecture?.blockId ?? "";
    card.dataset.lectureId = entry?.lecture?.id ?? "";
    card.dataset.passOrder = entry?.pass?.order ?? "";
    card.dataset.passDue = Number.isFinite(entry?.pass?.due) ? String(entry.pass.due) : "";
    card.dataset.status = isComplete ? "complete" : "pending";
    const lectureName = entry?.lecture?.name || "Lecture";
    const title = document.createElement("div");
    title.className = "block-board-pass-title card-title";
    const titleInner = document.createElement("span");
    titleInner.className = "block-board-pass-title-inner";
    titleInner.textContent = lectureName;
    title.appendChild(titleInner);
    card.appendChild(title);
    const scheduleMarquee = () => {
      const container = title;
      const inner = titleInner;
      if (!container || !inner) return;
      const available = container.clientWidth;
      const content = inner.scrollWidth;
      const overflow = Math.round(content - available);
      if (available > 0 && overflow > 8) {
        const distance = overflow + 24;
        const duration = Math.min(22, Math.max(8, distance / 24));
        container.classList.add("is-animated");
        container.style.setProperty("--marquee-distance", `${distance}px`);
        container.style.setProperty("--marquee-duration", `${duration}s`);
      } else {
        container.classList.remove("is-animated");
        container.style.removeProperty("--marquee-distance");
        container.style.removeProperty("--marquee-duration");
      }
    };
    if (typeof requestAnimationFrame === "function") {
      requestAnimationFrame(scheduleMarquee);
    } else {
      setTimeout(scheduleMarquee, 0);
    }
    const passLabel = entry?.pass?.label || (entry?.pass?.order != null ? `Pass ${entry.pass.order}` : "Pass");
    const dueFullLabel = Number.isFinite(entry?.pass?.due) ? formatPassDueLabel(entry.pass.due) : "Unscheduled";
    const passOrder = document.createElement("span");
    passOrder.className = "block-board-pass-pill-order";
    passOrder.textContent = passLabel;
    card.appendChild(passOrder);
    const descriptionParts = [lectureName, passLabel];
    if (entry?.pass?.action) descriptionParts.push(entry.pass.action);
    if (dueFullLabel) descriptionParts.push(dueFullLabel);
    card.setAttribute("aria-label", descriptionParts.join(" \u2022 "));
    card.title = descriptionParts.join(" \u2022 ");
    card.addEventListener("dragstart", (event) => {
      if (!event.dataTransfer) return;
      const payload = {
        blockId: card.dataset.blockId,
        lectureId: card.dataset.lectureId,
        passOrder: Number(card.dataset.passOrder),
        due: card.dataset.passDue ? Number(card.dataset.passDue) : null
      };
      event.dataTransfer.effectAllowed = "move";
      event.dataTransfer.setData("application/json", JSON.stringify(payload));
      onDrag?.(payload);
    });
    return card;
  }
  function createDayColumn(dayTs) {
    const column = document.createElement("div");
    column.className = "block-board-day-column";
    column.dataset.day = String(dayTs);
    const header = document.createElement("div");
    header.className = "block-board-day-header";
    header.textContent = formatDay(dayTs);
    if (startOfDay2(Date.now()) === dayTs) {
      column.classList.add("today");
    }
    column.appendChild(header);
    const list = document.createElement("div");
    list.className = "block-board-day-list";
    column.appendChild(list);
    column.addEventListener("dragover", (event) => {
      event.preventDefault();
      column.classList.add("dropping");
    });
    column.addEventListener("dragleave", () => {
      column.classList.remove("dropping");
    });
    return column;
  }
  function scrollGridToToday(grid) {
    if (!grid) return;
    const todayColumn = grid.querySelector(".block-board-day-column.today");
    if (!todayColumn) return;
    if (grid.scrollWidth <= grid.clientWidth + 1) return;
    const apply = () => {
      const columnRect = todayColumn.getBoundingClientRect();
      const gridRect = grid.getBoundingClientRect();
      const relativeLeft = columnRect.left - gridRect.left + grid.scrollLeft;
      const halfWidth = Math.max(0, (grid.clientWidth - todayColumn.clientWidth) / 2);
      const maxScroll = Math.max(0, grid.scrollWidth - grid.clientWidth);
      const target = Math.max(0, Math.min(maxScroll, relativeLeft - halfWidth));
      if (typeof grid.scrollTo === "function") {
        grid.scrollTo({ left: target, behavior: "auto" });
      } else {
        grid.scrollLeft = target;
      }
    };
    if (typeof requestAnimationFrame === "function") {
      requestAnimationFrame(apply);
    } else {
      setTimeout(apply, 0);
    }
  }
  function sortPassEntries(entries) {
    return entries.slice().sort((a, b) => {
      const aComplete = Number.isFinite(a?.pass?.completedAt);
      const bComplete = Number.isFinite(b?.pass?.completedAt);
      if (aComplete !== bComplete) return aComplete ? 1 : -1;
      const orderA = Number.isFinite(a?.pass?.order) ? a.pass.order : Number.POSITIVE_INFINITY;
      const orderB = Number.isFinite(b?.pass?.order) ? b.pass.order : Number.POSITIVE_INFINITY;
      if (orderA !== orderB) return orderA - orderB;
      const nameA = a?.lecture?.name || "";
      const nameB = b?.lecture?.name || "";
      return nameA.localeCompare(nameB);
    });
  }
  async function updateLectureSchedule(lecture, updateFn) {
    const updated = updateFn(lecture);
    await persistLecture(updated);
  }
  function renderUrgentQueues(root2, queues, handlers) {
    const wrapper = document.createElement("section");
    wrapper.className = "block-board-summary";
    const config = [
      { key: "today", label: "Today's To-Do", empty: "Nothing due today.", accent: "var(--blue)" },
      { key: "tomorrow", label: "Due Tomorrow", empty: "Nothing due tomorrow.", accent: "var(--yellow)" },
      { key: "overdue", label: "Overdue", empty: "No overdue passes. \u{1F389}", accent: "var(--rose)" }
    ];
    config.forEach(({ key, label, empty, accent }) => {
      const card = document.createElement("article");
      card.className = "block-board-summary-card";
      if (accent) card.style.setProperty("--summary-accent", accent);
      const header = document.createElement("div");
      header.className = "block-board-summary-header";
      const title = document.createElement("h3");
      title.className = "block-board-summary-title";
      title.textContent = label;
      header.appendChild(title);
      const entries = queues[key] || [];
      const count = document.createElement("span");
      count.className = "block-board-summary-count";
      count.textContent = String(entries.length);
      header.appendChild(count);
      card.appendChild(header);
      const list = document.createElement("div");
      list.className = "block-board-summary-list";
      if (!entries.length) {
        const emptyState = document.createElement("div");
        emptyState.className = "block-board-summary-empty";
        emptyState.textContent = empty || "Nothing queued.";
        list.appendChild(emptyState);
      } else {
        entries.forEach((entry) => {
          const chip = buildPassElement(entry, handlers.onComplete, handlers.onShift);
          list.appendChild(chip);
        });
      }
      card.appendChild(list);
      wrapper.appendChild(card);
    });
    root2.appendChild(wrapper);
  }
  function buildDayAssignments(blockLectures, days) {
    const assignments = /* @__PURE__ */ new Map();
    blockLectures.forEach((lecture) => {
      const passes = Array.isArray(lecture?.passes) ? lecture.passes : [];
      passes.forEach((pass) => {
        if (!pass || Number.isFinite(pass.completedAt)) return;
        const due = Number.isFinite(pass.due) ? startOfDay2(pass.due) : null;
        const key = due != null ? due : "unscheduled";
        if (!assignments.has(key)) assignments.set(key, []);
        assignments.get(key).push({ lecture, pass });
      });
    });
    days.forEach((day) => {
      if (!assignments.has(day)) assignments.set(day, []);
    });
    const unscheduled = assignments.get("unscheduled");
    if (!unscheduled || !unscheduled.length) {
      assignments.delete("unscheduled");
    }
    return assignments;
  }
  function attachDropHandlers(column, blockEntries, refresh) {
    column.addEventListener("drop", async (event) => {
      event.preventDefault();
      column.classList.remove("dropping");
      const payloadRaw = event.dataTransfer?.getData("application/json");
      if (!payloadRaw) return;
      let payload;
      try {
        payload = JSON.parse(payloadRaw);
      } catch (err) {
        return;
      }
      const { lectureId, passOrder } = payload || {};
      const lecture = blockEntries.find((item) => String(item.lecture?.id) === String(lectureId))?.lecture;
      if (!lecture) return;
      const dayValue = column.dataset.day;
      const targetDay = dayValue ? Number(dayValue) : null;
      const newDue = targetDay != null ? targetDay + (payload?.due != null ? payload.due % DAY_MS2 : 9 * 60 * 60 * 1e3) : null;
      await updateLectureSchedule(lecture, (lec) => applyPassDueUpdate(lec, passOrder, newDue));
      await refresh({ full: true });
    });
  }
  function renderBlockBoardBlock(container, block, blockLectures, days, refresh, gridScrollState = /* @__PURE__ */ new Map()) {
    const boardState = ensureBoardState();
    const wrapper = document.createElement("section");
    wrapper.className = "block-board-block";
    wrapper.dataset.blockId = String(block?.blockId ?? "");
    if (block?.color) {
      wrapper.style.setProperty("--block-accent", block.color);
      wrapper.classList.add("has-accent");
    }
    const header = document.createElement("div");
    header.className = "block-board-block-header";
    const heading = document.createElement("div");
    heading.className = "block-board-block-heading";
    const title = document.createElement("h2");
    title.className = "block-board-block-title";
    title.textContent = block?.title || block?.name || `Block ${block?.blockId}`;
    if (block?.color) {
      title.style.setProperty("--block-accent", block.color);
      title.classList.add("has-accent");
    }
    heading.appendChild(title);
    const metaParts = [];
    const rangeText = blockRangeLabel(block);
    if (rangeText) metaParts.push(rangeText);
    const weekValue = Number(block?.weeks);
    if (Number.isFinite(weekValue) && weekValue > 0) {
      const weeks = Math.round(weekValue);
      metaParts.push(`${weeks} week${weeks === 1 ? "" : "s"}`);
    }
    const span = blockSpanDays(block);
    if (span) metaParts.push(`${span} day${span === 1 ? "" : "s"}`);
    if (metaParts.length) {
      const meta = document.createElement("div");
      meta.className = "block-board-block-meta";
      meta.textContent = metaParts.join(" \u2022 ");
      heading.appendChild(meta);
    }
    header.appendChild(heading);
    const controls = document.createElement("div");
    controls.className = "block-board-block-controls";
    const collapseBtn = document.createElement("button");
    collapseBtn.type = "button";
    collapseBtn.className = "btn secondary";
    const blockKey = String(block?.blockId ?? "");
    const isCollapsed = blockKey ? boardState.collapsedBlocks.includes(blockKey) : false;
    collapseBtn.textContent = isCollapsed ? "Expand" : "Minimize";
    collapseBtn.addEventListener("click", () => {
      if (!blockKey) return;
      const current = ensureBoardState();
      const nextCollapsed = new Set((current.collapsedBlocks || []).map(String));
      const manualExpanded = new Set((current.manualExpanded || []).map(String));
      const autoCollapsed = new Set((current.autoCollapsed || []).map(String));
      if (nextCollapsed.has(blockKey)) {
        nextCollapsed.delete(blockKey);
        manualExpanded.add(blockKey);
        autoCollapsed.delete(blockKey);
      } else {
        nextCollapsed.add(blockKey);
        manualExpanded.delete(blockKey);
        autoCollapsed.delete(blockKey);
      }
      setBlockBoardState({
        collapsedBlocks: Array.from(nextCollapsed),
        manualExpanded: Array.from(manualExpanded),
        autoCollapsed: Array.from(autoCollapsed)
      });
      refresh();
    });
    controls.appendChild(collapseBtn);
    const hiddenTimelineSet = new Set((boardState.hiddenTimelines || []).map((id) => String(id)));
    const timelineHidden = hiddenTimelineSet.has("__all__") || hiddenTimelineSet.has(blockKey);
    const timelineBtn = document.createElement("button");
    timelineBtn.type = "button";
    timelineBtn.className = "btn secondary";
    timelineBtn.textContent = timelineHidden ? "Show timeline" : "Hide timeline";
    timelineBtn.addEventListener("click", () => {
      if (!blockKey) return;
      const current = ensureBoardState();
      const nextHidden = new Set((current.hiddenTimelines || []).map((id) => String(id)));
      const manualTimeline = new Set((current.manualTimeline || []).map(String));
      const autoHidden = new Set((current.autoHidden || []).map(String));
      const hideAll = nextHidden.has("__all__");
      nextHidden.delete("__all__");
      if (timelineHidden) {
        nextHidden.delete(blockKey);
        manualTimeline.add(blockKey);
        autoHidden.delete(blockKey);
      } else {
        nextHidden.add(blockKey);
        manualTimeline.delete(blockKey);
        autoHidden.delete(blockKey);
      }
      if (hideAll) {
        nextHidden.add("__all__");
      }
      setBlockBoardState({
        hiddenTimelines: Array.from(nextHidden),
        manualTimeline: Array.from(manualTimeline),
        autoHidden: Array.from(autoHidden)
      });
      refresh();
    });
    controls.appendChild(timelineBtn);
    header.appendChild(controls);
    wrapper.appendChild(header);
    const assignments = buildDayAssignments(blockLectures, days);
    const unscheduledEntries = sortPassEntries(assignments.get("unscheduled") || []);
    assignments.delete("unscheduled");
    const blockEntries = [];
    assignments.forEach((entries) => {
      sortPassEntries(entries).forEach((entry) => blockEntries.push(entry));
    });
    unscheduledEntries.forEach((entry) => blockEntries.push(entry));
    if (!timelineHidden) {
      const timelineData = collectTimelineSegments(blockLectures, days);
      const timeline = document.createElement("div");
      timeline.className = "block-board-timeline";
      const timelineHeader = document.createElement("div");
      timelineHeader.className = "block-board-timeline-header";
      const timelineTitle = document.createElement("h3");
      timelineTitle.className = "block-board-timeline-title";
      timelineTitle.textContent = `Block Timeline \u2014 ${block?.title || block?.name || "Block"}`;
      timelineHeader.appendChild(timelineTitle);
      const spanCount = blockSpanDays(block) || days.length;
      const spanLabel = document.createElement("span");
      spanLabel.className = "block-board-timeline-span";
      spanLabel.textContent = `${spanCount} day${spanCount === 1 ? "" : "s"}`;
      timelineHeader.appendChild(spanLabel);
      timeline.appendChild(timelineHeader);
      const track = document.createElement("div");
      track.className = "block-board-timeline-track";
      const todayKey = startOfDay2(Date.now());
      timelineData.forEach(({ day, entries }) => {
        const column = document.createElement("div");
        column.className = "block-board-timeline-column";
        if (day === todayKey) {
          column.classList.add("is-today");
        }
        const date = new Date(day);
        const isoDate = Number.isFinite(day) ? date.toISOString().slice(0, 10) : "";
        const tooltip = isoDate ? `${isoDate} \u2022 ${entries.length} due` : `${date.toLocaleDateString()} \u2022 ${entries.length} due`;
        column.setAttribute("data-count", String(entries.length));
        const bar = document.createElement("div");
        bar.className = "block-board-timeline-bar";
        bar.title = tooltip;
        const count = entries.length;
        if (count > 0) {
          const hasCompleted = entries.some((entry) => entry.completed);
          if (hasCompleted) {
            bar.classList.add("has-complete");
          } else {
            bar.classList.add("is-pending");
          }
          const gap = 0;
          let segmentHeight = TIMELINE_BASE_UNIT_HEIGHT;
          const gapTotal = gap * Math.max(0, count - 1);
          let totalHeight = segmentHeight * count + gapTotal;
          if (totalHeight > TIMELINE_MAX_BAR_HEIGHT) {
            const available = Math.max(TIMELINE_MAX_BAR_HEIGHT - gapTotal, TIMELINE_MIN_SEGMENT_HEIGHT * count);
            segmentHeight = Math.max(TIMELINE_MIN_SEGMENT_HEIGHT, available / count);
            totalHeight = segmentHeight * count + gapTotal;
          }
          bar.style.height = `${Math.max(totalHeight, TIMELINE_MIN_SEGMENT_HEIGHT)}px`;
          entries.forEach((entry) => {
            const segment = document.createElement("div");
            segment.className = "block-board-timeline-segment";
            segment.style.setProperty("--segment-color", passColor(entry.order));
            segment.style.height = `${segmentHeight}px`;
            if (entry.completed) {
              segment.classList.add("is-complete");
            } else {
              segment.classList.add("is-pending");
            }
            bar.appendChild(segment);
          });
        } else {
          bar.classList.add("is-empty");
        }
        column.appendChild(bar);
        const label = document.createElement("div");
        label.className = "block-board-timeline-day";
        label.textContent = date.getDate();
        label.setAttribute("aria-hidden", "true");
        column.appendChild(label);
        if (tooltip) {
          column.setAttribute("aria-label", tooltip);
        }
        track.appendChild(column);
      });
      timeline.appendChild(track);
      wrapper.appendChild(timeline);
    }
    if (isCollapsed) {
      container.appendChild(wrapper);
      return;
    }
    if (unscheduledEntries.length) {
      const backlog = document.createElement("div");
      backlog.className = "block-board-backlog";
      const backlogTitle = document.createElement("h3");
      backlogTitle.className = "block-board-backlog-title";
      backlogTitle.textContent = "Needs a date";
      backlog.appendChild(backlogTitle);
      const backlogHint = document.createElement("p");
      backlogHint.className = "block-board-backlog-hint";
      backlogHint.textContent = "Drag a pass onto a day to schedule it.";
      backlog.appendChild(backlogHint);
      const backlogList = document.createElement("div");
      backlogList.className = "block-board-backlog-list";
      unscheduledEntries.forEach((entry) => {
        const card = createPassCard(entry);
        backlogList.appendChild(card);
      });
      backlog.appendChild(backlogList);
      wrapper.appendChild(backlog);
    }
    const board = document.createElement("div");
    board.className = "block-board-grid";
    days.forEach((day) => {
      const column = createDayColumn(day);
      const entries = sortPassEntries(assignments.get(day) || []);
      entries.forEach((entry) => {
        const card = createPassCard(entry);
        column.querySelector(".block-board-day-list").appendChild(card);
      });
      attachDropHandlers(column, blockEntries, refresh);
      board.appendChild(column);
    });
    wrapper.appendChild(board);
    const blockId = String(block?.blockId ?? "");
    if (blockId && !gridScrollState.has(blockId)) {
      scrollGridToToday(board);
    }
    container.appendChild(wrapper);
  }
  async function renderBlockBoard(container, refresh) {
    if (!container) return;
    const scrollSnapshot = captureBoardScrollState(container);
    container.innerHTML = "";
    container.classList.add("block-board-container");
    const boardState = ensureBoardState();
    const settingsPromise = fetchSettings().catch(() => null);
    const [catalog, lectures, settings] = await Promise.all([
      loadCatalog(),
      fetchLectures2(),
      settingsPromise
    ]);
    const { blocks } = catalog;
    setPassColorPalette(settings?.plannerDefaults?.passColors);
    if (Array.isArray(blocks) && blocks.length) {
      const validBlockIds = /* @__PURE__ */ new Set();
      blocks.forEach((block) => {
        if (!block || block.blockId == null) return;
        validBlockIds.add(String(block.blockId));
      });
      const normalizedCollapsed = new Set((boardState.collapsedBlocks || []).map((id) => String(id)));
      const hideAllTimelines = Array.isArray(boardState.hiddenTimelines) ? boardState.hiddenTimelines.includes("__all__") : false;
      const normalizedHidden = new Set(
        (boardState.hiddenTimelines || []).map((id) => String(id)).filter((id) => id !== "__all__")
      );
      const manualExpanded = new Set((boardState.manualExpanded || []).map((id) => String(id)));
      const manualTimeline = new Set((boardState.manualTimeline || []).map((id) => String(id)));
      const autoCollapsed = new Set((boardState.autoCollapsed || []).map((id) => String(id)));
      const autoHidden = new Set((boardState.autoHidden || []).map((id) => String(id)));
      let manualExpandedChanged = false;
      let manualTimelineChanged = false;
      let autoCollapsedChanged = false;
      let autoHiddenChanged = false;
      manualExpanded.forEach((id) => {
        if (!validBlockIds.has(id)) {
          manualExpanded.delete(id);
          manualExpandedChanged = true;
        }
      });
      manualTimeline.forEach((id) => {
        if (!validBlockIds.has(id)) {
          manualTimeline.delete(id);
          manualTimelineChanged = true;
        }
      });
      autoCollapsed.forEach((id) => {
        if (!validBlockIds.has(id)) {
          autoCollapsed.delete(id);
          autoCollapsedChanged = true;
        }
      });
      autoHidden.forEach((id) => {
        if (!validBlockIds.has(id)) {
          autoHidden.delete(id);
          autoHiddenChanged = true;
        }
      });
      const latestBlockId = resolveLatestBlockId(blocks);
      let collapsedChanged = false;
      let hiddenChanged = false;
      blocks.forEach((block) => {
        if (!block || block.blockId == null) return;
        const blockId = String(block.blockId);
        const isLatest = latestBlockId != null && blockId === latestBlockId;
        const keepOpen = isLatest || manualExpanded.has(blockId);
        if (keepOpen) {
          if (normalizedCollapsed.has(blockId) && autoCollapsed.has(blockId)) {
            normalizedCollapsed.delete(blockId);
            collapsedChanged = true;
          }
          if (autoCollapsed.delete(blockId)) {
            autoCollapsedChanged = true;
          }
        } else if (!normalizedCollapsed.has(blockId)) {
          normalizedCollapsed.add(blockId);
          collapsedChanged = true;
          if (!autoCollapsed.has(blockId)) {
            autoCollapsed.add(blockId);
            autoCollapsedChanged = true;
          }
        }
        if (!hideAllTimelines) {
          const manualShow = manualTimeline.has(blockId);
          const shouldAutoHide = !keepOpen && !manualShow;
          if (shouldAutoHide) {
            if (!normalizedHidden.has(blockId)) {
              normalizedHidden.add(blockId);
              hiddenChanged = true;
            }
            if (!autoHidden.has(blockId)) {
              autoHidden.add(blockId);
              autoHiddenChanged = true;
            }
          } else {
            const wasAutoHidden = autoHidden.has(blockId);
            if (wasAutoHidden && normalizedHidden.has(blockId) && (manualShow || keepOpen)) {
              normalizedHidden.delete(blockId);
              hiddenChanged = true;
            }
            if (wasAutoHidden) {
              autoHidden.delete(blockId);
              autoHiddenChanged = true;
            }
          }
        }
      });
      const collapsedArr = Array.from(normalizedCollapsed);
      const hiddenArr = hideAllTimelines ? ["__all__"] : Array.from(normalizedHidden);
      const manualExpandedArr = Array.from(manualExpanded);
      const manualTimelineArr = Array.from(manualTimeline);
      const autoCollapsedArr = Array.from(autoCollapsed);
      const autoHiddenArr = Array.from(autoHidden);
      const arraysEqual3 = (a = [], b = []) => {
        if (!Array.isArray(a) || !Array.isArray(b)) return false;
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i += 1) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      };
      const patch = {};
      if (!arraysEqual3(boardState.collapsedBlocks || [], collapsedArr)) {
        patch.collapsedBlocks = collapsedArr;
      }
      if (!arraysEqual3(boardState.hiddenTimelines || [], hiddenArr)) {
        patch.hiddenTimelines = hiddenArr;
      }
      if (manualExpandedChanged || !arraysEqual3(boardState.manualExpanded || [], manualExpandedArr)) {
        patch.manualExpanded = manualExpandedArr;
      }
      if (manualTimelineChanged || !arraysEqual3(boardState.manualTimeline || [], manualTimelineArr)) {
        patch.manualTimeline = manualTimelineArr;
      }
      if (autoCollapsedChanged || !arraysEqual3(boardState.autoCollapsed || [], autoCollapsedArr)) {
        patch.autoCollapsed = autoCollapsedArr;
      }
      if (autoHiddenChanged || !arraysEqual3(boardState.autoHidden || [], autoHiddenArr)) {
        patch.autoHidden = autoHiddenArr;
      }
      if (Object.keys(patch).length) {
        setBlockBoardState(patch);
        if (patch.collapsedBlocks) boardState.collapsedBlocks = patch.collapsedBlocks;
        if (patch.hiddenTimelines) boardState.hiddenTimelines = patch.hiddenTimelines;
        if (patch.manualExpanded) boardState.manualExpanded = patch.manualExpanded;
        if (patch.manualTimeline) boardState.manualTimeline = patch.manualTimeline;
        if (patch.autoCollapsed) boardState.autoCollapsed = patch.autoCollapsed;
        if (patch.autoHidden) boardState.autoHidden = patch.autoHidden;
      }
    }
    const fallbackDays = collectDefaultBoardDays();
    const refreshBoard = async (options = {}) => {
      if (options && options.full && typeof refresh === "function") {
        await refresh();
      } else {
        await renderBlockBoard(container, refresh);
      }
    };
    const queues = groupLectureQueues(lectures);
    const urgentHost = document.createElement("div");
    renderUrgentQueues(urgentHost, queues, {
      onComplete: async (entry) => {
        const passOrder = entry?.pass?.order;
        const lecture = entry?.lecture;
        if (!lecture || !Number.isFinite(passOrder)) return;
        const passIndex = Array.isArray(lecture.passes) ? lecture.passes.findIndex((pass) => pass?.order === passOrder) : -1;
        if (passIndex < 0) return;
        await updateLectureSchedule(lecture, (lec) => markPassCompleted(lec, passIndex));
        await refreshBoard({ full: true });
      },
      onShift: async (entry, mode2) => {
        if (!entry?.lecture) return;
        const lecture = entry.lecture;
        const passOrder = Number(entry?.pass?.order);
        if (!Number.isFinite(passOrder)) return;
        const lectureLabel = lecture?.name || `Lecture ${lecture?.id ?? ""}`;
        const passLabel = entry?.pass?.label || (Number.isFinite(passOrder) ? `Pass ${passOrder}` : "Pass");
        const result = await openShiftDialog(mode2, {
          description: `${lectureLabel} \u2022 ${passLabel}`,
          defaultUnit: "days",
          defaultValue: 1
        });
        if (!result || !Number.isFinite(result.minutes) || result.minutes <= 0) return;
        const delta = mode2 === "push" ? result.minutes : -result.minutes;
        try {
          await updateLectureSchedule(lecture, (lec) => shiftPassesForScope(lec, passOrder, delta, result.scope));
          await refreshBoard({ full: true });
        } catch (err) {
          console.error("Failed to shift pass timing", err);
        }
      }
    });
    container.appendChild(urgentHost);
    const previousGridScroll = /* @__PURE__ */ new Map();
    const gridEntries = Array.isArray(scrollSnapshot?.gridScroll) ? scrollSnapshot.gridScroll : [];
    gridEntries.forEach((entry) => {
      if (!entry) return;
      const blockId = entry?.blockId;
      if (blockId == null) return;
      previousGridScroll.set(String(blockId), Number(entry?.left) || 0);
    });
    const blockList = document.createElement("div");
    blockList.className = "block-board-list";
    const lecturesByBlock = /* @__PURE__ */ new Map();
    lectures.forEach((lecture) => {
      const key = String(lecture?.blockId ?? "");
      if (!lecturesByBlock.has(key)) lecturesByBlock.set(key, []);
      lecturesByBlock.get(key).push(lecture);
    });
    blocks.forEach((block) => {
      const blockLectures = lecturesByBlock.get(String(block.blockId)) || [];
      const blockDays = collectDaysForBlock(block, blockLectures);
      const daysForBlock = blockDays.length ? blockDays : fallbackDays;
      renderBlockBoardBlock(blockList, block, blockLectures, daysForBlock, refreshBoard, previousGridScroll);
    });
    container.appendChild(blockList);
    restoreBoardScrollState(container, scrollSnapshot);
  }
  function captureBoardScrollState(container) {
    if (!container || typeof container !== "object") return null;
    const dayScroll = [];
    container.querySelectorAll(".block-board-day-list").forEach((list) => {
      const column = list.closest(".block-board-day-column");
      const block = list.closest(".block-board-block");
      const blockId = block?.dataset?.blockId ?? "";
      const day = column?.dataset?.day ?? "";
      if (blockId && day) {
        dayScroll.push({ key: `${blockId}::${day}`, top: list.scrollTop });
      }
    });
    const gridScroll = [];
    container.querySelectorAll(".block-board-block").forEach((blockEl) => {
      const blockId = blockEl?.dataset?.blockId ?? "";
      if (!blockId) return;
      const grid = blockEl.querySelector(".block-board-grid");
      if (!grid) return;
      gridScroll.push({ blockId, left: grid.scrollLeft });
    });
    const snapshot = {
      containerTop: container.scrollTop,
      containerLeft: container.scrollLeft,
      dayScroll,
      gridScroll,
      windowX: typeof window !== "undefined" ? window.scrollX : null,
      windowY: typeof window !== "undefined" ? window.scrollY : null
    };
    return snapshot;
  }
  function restoreBoardScrollState(container, snapshot) {
    if (!container || !snapshot) return;
    const apply = () => {
      if (typeof container.scrollTo === "function") {
        container.scrollTo(snapshot.containerLeft ?? 0, snapshot.containerTop ?? 0);
      } else {
        container.scrollLeft = snapshot.containerLeft ?? 0;
        container.scrollTop = snapshot.containerTop ?? 0;
      }
      if (snapshot.windowX != null && snapshot.windowY != null && typeof window !== "undefined") {
        const nav = typeof navigator !== "undefined" ? navigator : typeof window.navigator !== "undefined" ? window.navigator : null;
        const ua = nav && typeof nav.userAgent === "string" ? nav.userAgent.toLowerCase() : "";
        const hasNativeScrollTo = typeof window.scrollTo === "function" && !String(window.scrollTo).includes("notImplemented");
        const shouldRestoreWindow = !ua.includes("jsdom") && hasNativeScrollTo;
        if (shouldRestoreWindow) {
          try {
            window.scrollTo(snapshot.windowX, snapshot.windowY);
          } catch (err) {
          }
        }
      }
      const dayEntries = Array.isArray(snapshot.dayScroll) ? snapshot.dayScroll : [];
      const dayScrollMap = new Map(dayEntries.map((entry) => [entry.key, entry.top]));
      if (dayScrollMap.size) {
        container.querySelectorAll(".block-board-block").forEach((blockEl) => {
          const blockId = blockEl?.dataset?.blockId ?? "";
          if (!blockId) return;
          blockEl.querySelectorAll(".block-board-day-column").forEach((column) => {
            const day = column?.dataset?.day ?? "";
            if (!day) return;
            const key = `${blockId}::${day}`;
            if (!dayScrollMap.has(key)) return;
            const list = column.querySelector(".block-board-day-list");
            if (list) list.scrollTop = dayScrollMap.get(key) ?? 0;
          });
        });
      }
      const gridEntries = Array.isArray(snapshot.gridScroll) ? snapshot.gridScroll : [];
      if (gridEntries.length) {
        const gridScrollMap = new Map(gridEntries.map((entry) => [String(entry.blockId ?? ""), Number(entry.left) || 0]));
        container.querySelectorAll(".block-board-block").forEach((blockEl) => {
          const blockId = blockEl?.dataset?.blockId ?? "";
          if (!blockId || !gridScrollMap.has(blockId)) return;
          const grid = blockEl.querySelector(".block-board-grid");
          if (!grid) return;
          const target = gridScrollMap.get(blockId);
          if (typeof grid.scrollTo === "function") {
            grid.scrollTo({ left: target, behavior: "auto" });
          } else {
            grid.scrollLeft = target;
          }
        });
      }
    };
    if (typeof requestAnimationFrame === "function") {
      requestAnimationFrame(apply);
    } else {
      setTimeout(apply, 0);
    }
  }
  var loadCatalog, fetchLectures2, persistLecture, fetchSettings, DAY_MS2, DEFAULT_BOARD_DAYS, SHIFT_OFFSET_UNITS, TIMELINE_BASE_UNIT_HEIGHT, TIMELINE_MAX_BAR_HEIGHT, TIMELINE_MIN_SEGMENT_HEIGHT, BLOCK_RANGE_FORMAT, PASS_DUE_FORMAT2, PASS_TIME_FORMAT2;
  var init_block_board = __esm({
    "js/ui/components/block-board.js"() {
      init_state();
      init_block_catalog();
      init_storage();
      init_scheduler();
      init_pass_colors();
      init_utils();
      loadCatalog = loadBlockCatalog;
      fetchLectures2 = listAllLectures;
      persistLecture = saveLecture;
      fetchSettings = getSettings;
      DAY_MS2 = 24 * 60 * 60 * 1e3;
      DEFAULT_BOARD_DAYS = 14;
      SHIFT_OFFSET_UNITS = [
        { id: "minutes", label: "minutes", minutes: 1 },
        { id: "hours", label: "hours", minutes: 60 },
        { id: "days", label: "days", minutes: 60 * 24 },
        { id: "weeks", label: "weeks", minutes: 60 * 24 * 7 }
      ];
      TIMELINE_BASE_UNIT_HEIGHT = 20;
      TIMELINE_MAX_BAR_HEIGHT = 200;
      TIMELINE_MIN_SEGMENT_HEIGHT = 12;
      BLOCK_RANGE_FORMAT = new Intl.DateTimeFormat(void 0, {
        month: "short",
        day: "numeric",
        year: "numeric"
      });
      PASS_DUE_FORMAT2 = new Intl.DateTimeFormat(void 0, {
        month: "short",
        day: "numeric"
      });
      PASS_TIME_FORMAT2 = new Intl.DateTimeFormat(void 0, {
        hour: "numeric",
        minute: "2-digit"
      });
    }
  });

  // js/ui/components/exams.js
  var exams_exports = {};
  __export(exams_exports, {
    renderExamRunner: () => renderExamRunner,
    renderExams: () => renderExams
  });
  function csvOptionIndex(optionNumber) {
    return 5 + (optionNumber - 1) * 2;
  }
  function csvOptionCorrectIndex(optionNumber) {
    return csvOptionIndex(optionNumber) + 1;
  }
  function sanitizeRichText(value) {
    const raw = value == null ? "" : String(value);
    if (!raw) return "";
    const looksHtml = /<([a-z][^>]*>)/i.test(raw);
    const normalized2 = looksHtml ? raw : raw.replace(/\r?\n/g, "<br>");
    const sanitized = sanitizeHtml(normalized2);
    return isEmptyHtml(sanitized) ? "" : sanitized;
  }
  function ensureArrayTags(tags) {
    if (!Array.isArray(tags)) {
      if (tags == null) return [];
      if (typeof tags === "string") {
        return tags.split(/[|,]/).map((tag) => tag.trim()).filter(Boolean);
      }
      return [];
    }
    return tags.map((tag) => String(tag).trim()).filter(Boolean);
  }
  function parseTagString(tags) {
    if (!tags) return [];
    return String(tags).split(/[|,]/).map((tag) => tag.trim()).filter(Boolean);
  }
  function parseBooleanFlag(value) {
    if (value == null) return false;
    const str = String(value).trim().toLowerCase();
    return ["true", "1", "yes", "y", "correct"].includes(str);
  }
  function csvEscape(value) {
    const str = value == null ? "" : String(value);
    if (!str) return "";
    if (/["]/.test(str) || /[\n\r,]/.test(str)) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  }
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  function scorePercentage(result) {
    if (!result || !Number.isFinite(result.correct) || !Number.isFinite(result.total) || result.total <= 0) {
      return null;
    }
    return Math.round(result.correct / result.total * 100);
  }
  function scoreBadgeClass(pct) {
    if (!Number.isFinite(pct)) return "neutral";
    if (pct >= 85) return "good";
    if (pct >= 70) return "warn";
    return "bad";
  }
  function createScoreBadge(result, label) {
    const pct = scorePercentage(result);
    const badge = document.createElement("span");
    badge.className = ["exam-score-badge", `exam-score-badge--${scoreBadgeClass(pct)}`].join(" ");
    if (label) {
      const labelEl = document.createElement("span");
      labelEl.className = "exam-score-badge-label";
      labelEl.textContent = label;
      badge.appendChild(labelEl);
    }
    const value = document.createElement("span");
    value.className = "exam-score-badge-value";
    if (pct == null) {
      value.textContent = "\u2014";
    } else {
      value.textContent = `${pct}%`;
    }
    badge.appendChild(value);
    return badge;
  }
  function setTimerElement(sess, element) {
    if (!sess) return;
    sess.__timerElement = element || null;
    if (element) {
      updateTimerElement(sess);
    }
  }
  function updateTimerElement(sess) {
    if (!sess) return;
    const el = sess.__timerElement;
    if (!el) return;
    const remaining = typeof sess.remainingMs === "number" ? Math.max(0, sess.remainingMs) : totalExamTimeMs(sess.exam);
    el.textContent = formatCountdown(remaining);
  }
  function ensureQuestionStats(sess) {
    const questionCount = sess?.exam?.questions?.length || 0;
    if (!sess) return;
    if (!Array.isArray(sess.questionStats)) {
      sess.questionStats = Array.from({ length: questionCount }, () => ({
        timeMs: 0,
        changes: [],
        enteredAt: null,
        initialAnswer: null,
        initialAnswerAt: null
      }));
      return;
    }
    if (sess.questionStats.length !== questionCount) {
      const next = Array.from({ length: questionCount }, (_, idx) => {
        const prev = sess.questionStats[idx] || {};
        return {
          timeMs: Number.isFinite(prev.timeMs) ? prev.timeMs : 0,
          changes: Array.isArray(prev.changes) ? [...prev.changes] : [],
          enteredAt: null,
          initialAnswer: prev.initialAnswer ?? null,
          initialAnswerAt: prev.initialAnswerAt ?? null
        };
      });
      sess.questionStats = next;
      return;
    }
    sess.questionStats.forEach((stat) => {
      if (!stat) return;
      if (!Array.isArray(stat.changes)) stat.changes = [];
      if (!Number.isFinite(stat.timeMs)) stat.timeMs = 0;
      if (stat.enteredAt == null) stat.enteredAt = null;
      if (!("initialAnswer" in stat)) stat.initialAnswer = null;
      if (!("initialAnswerAt" in stat)) stat.initialAnswerAt = null;
    });
  }
  function beginQuestionTiming(sess, idx) {
    if (!sess || sess.mode !== "taking") return;
    ensureQuestionStats(sess);
    const stat = sess.questionStats?.[idx];
    if (!stat) return;
    if (stat.enteredAt == null) {
      stat.enteredAt = Date.now();
    }
  }
  function finalizeQuestionTiming(sess, idx) {
    if (!sess || sess.mode !== "taking") return;
    ensureQuestionStats(sess);
    const stat = sess.questionStats?.[idx];
    if (!stat || stat.enteredAt == null) return;
    const now = Date.now();
    const delta = Math.max(0, now - stat.enteredAt);
    stat.timeMs = (Number.isFinite(stat.timeMs) ? stat.timeMs : 0) + delta;
    stat.enteredAt = null;
  }
  function finalizeActiveQuestionTiming(sess) {
    if (!sess || typeof sess.idx !== "number") return;
    finalizeQuestionTiming(sess, sess.idx);
  }
  function ensureScrollPositions(sess) {
    if (!sess) return;
    if (!sess.scrollPositions || typeof sess.scrollPositions !== "object") {
      sess.scrollPositions = {};
    }
  }
  function resolveScrollContainer(root2) {
    const hasDocument = typeof document !== "undefined";
    if (hasDocument) {
      if (root2 && typeof root2.closest === "function") {
        const scoped = root2.closest(".tab-content");
        if (scoped) return scoped;
      }
      const main = document.querySelector("main");
      if (main) return main;
    }
    if (typeof window !== "undefined") return window;
    return null;
  }
  function isWindowScroller(scroller) {
    return typeof window !== "undefined" && scroller === window;
  }
  function readScrollPosition(scroller) {
    if (!scroller) return 0;
    if (isWindowScroller(scroller)) {
      return window.scrollY || window.pageYOffset || 0;
    }
    return scroller.scrollTop || 0;
  }
  function applyScrollPosition(scroller, value) {
    if (!scroller) return;
    const top = Number.isFinite(value) ? value : 0;
    if (isWindowScroller(scroller)) {
      if (typeof window.scrollTo === "function") {
        window.scrollTo({ left: 0, top, behavior: "auto" });
      }
      return;
    }
    if (typeof scroller.scrollTo === "function") {
      scroller.scrollTo({ left: 0, top, behavior: "auto" });
    } else {
      scroller.scrollTop = top;
    }
  }
  function storeScrollPosition(sess, idx, value) {
    if (!sess || typeof idx !== "number") return;
    ensureScrollPositions(sess);
    const numeric = Number.isFinite(value) ? value : 0;
    sess.scrollPositions[idx] = numeric;
  }
  function getStoredScroll(sess, idx) {
    if (!sess || typeof idx !== "number") return null;
    const store2 = sess.scrollPositions;
    if (!store2 || typeof store2 !== "object") return null;
    const value = store2[idx];
    return Number.isFinite(value) ? value : null;
  }
  function navigateToQuestion(sess, nextIdx, render) {
    if (!sess || typeof nextIdx !== "number") return;
    const total = sess.exam?.questions?.length || 0;
    if (!total) return;
    const clamped = Math.min(Math.max(nextIdx, 0), Math.max(0, total - 1));
    if (clamped === sess.idx) return;
    if (typeof sess.idx === "number") {
      const scroller = resolveScrollContainer();
      const scrollPos = readScrollPosition(scroller);
      storeScrollPosition(sess, sess.idx, scrollPos);
    }
    if (sess.mode === "taking") {
      finalizeActiveQuestionTiming(sess);
    }
    sess.idx = clamped;
    if (sess.mode === "taking") {
      beginQuestionTiming(sess, clamped);
    }
    render();
  }
  function recordAnswerChange(sess, idx, question, nextAnswer) {
    if (!sess || sess.mode !== "taking") return;
    ensureQuestionStats(sess);
    const stat = sess.questionStats?.[idx];
    if (!stat) return;
    const prev = sess.answers?.[idx];
    if (prev === nextAnswer) return;
    if (prev == null) {
      if (nextAnswer != null && stat.initialAnswer == null) {
        stat.initialAnswer = nextAnswer;
        stat.initialAnswerAt = Date.now();
      }
      return;
    }
    const change = {
      at: Date.now(),
      from: prev ?? null,
      to: nextAnswer ?? null
    };
    if (prev != null) change.fromCorrect = prev === question.answer;
    if (nextAnswer != null) change.toCorrect = nextAnswer === question.answer;
    if (!Array.isArray(stat.changes)) stat.changes = [];
    stat.changes.push(change);
  }
  function snapshotQuestionStats(sess) {
    ensureQuestionStats(sess);
    return (sess.questionStats || []).map((stat) => ({
      timeMs: Number.isFinite(stat?.timeMs) ? stat.timeMs : 0,
      changes: Array.isArray(stat?.changes) ? stat.changes.map((change) => ({ ...change })) : [],
      initialAnswer: stat?.initialAnswer ?? null,
      initialAnswerAt: stat?.initialAnswerAt ?? null
    }));
  }
  function extractAnswerSequence(stat, finalAnswer) {
    const sequence = [];
    const push = (value) => {
      if (value == null) return;
      if (sequence[sequence.length - 1] === value) return;
      sequence.push(value);
    };
    if (stat && stat.initialAnswer != null) {
      push(stat.initialAnswer);
    }
    const changes = Array.isArray(stat?.changes) ? stat.changes : [];
    changes.forEach((change) => {
      if (!change) return;
      if (change.to != null) push(change.to);
    });
    if (finalAnswer != null) {
      push(finalAnswer);
    }
    return sequence;
  }
  function analyzeAnswerChange(stat, question, finalAnswer) {
    if (!question) {
      return {
        initialAnswer: null,
        finalAnswer: null,
        initialCorrect: null,
        finalCorrect: null,
        changed: false,
        direction: null,
        switched: false,
        sequence: []
      };
    }
    const answerId = question.answer;
    const sequence = extractAnswerSequence(stat, finalAnswer);
    const initialAnswer = sequence.length ? sequence[0] : stat?.initialAnswer ?? null;
    const resolvedFinalAnswer = sequence.length ? sequence[sequence.length - 1] : finalAnswer ?? null;
    const initialCorrect = initialAnswer != null ? initialAnswer === answerId : null;
    const finalCorrect = resolvedFinalAnswer != null ? resolvedFinalAnswer === answerId : null;
    const switched = sequence.length > 1;
    const changed = switched && initialAnswer != null && resolvedFinalAnswer != null && initialAnswer !== resolvedFinalAnswer;
    let direction = null;
    if (changed) {
      if (initialCorrect === true && finalCorrect === false) {
        direction = "right-to-wrong";
      } else if (initialCorrect === false && finalCorrect === true) {
        direction = "wrong-to-right";
      } else {
        direction = "neutral";
      }
    }
    return {
      initialAnswer,
      finalAnswer: resolvedFinalAnswer,
      initialCorrect,
      finalCorrect,
      changed,
      direction,
      switched,
      sequence
    };
  }
  function summarizeAnswerChanges(questionStats, exam, answers = {}) {
    let rightToWrong = 0;
    let wrongToRight = 0;
    let switched = 0;
    let endedDifferent = 0;
    questionStats.forEach((stat, idx) => {
      const question = exam?.questions?.[idx];
      if (!question) return;
      const finalAnswer = answers[idx];
      const details = analyzeAnswerChange(stat, question, finalAnswer);
      if (details.switched) {
        switched += 1;
      }
      if (details.changed) {
        endedDifferent += 1;
        if (details.direction === "right-to-wrong") rightToWrong += 1;
        if (details.direction === "wrong-to-right") wrongToRight += 1;
      }
    });
    return {
      rightToWrong,
      wrongToRight,
      switched,
      endedDifferent,
      returnedToOriginal: Math.max(0, switched - endedDifferent),
      totalChanges: switched
    };
  }
  function clone5(value) {
    return value != null ? deepClone(value) : value;
  }
  function totalExamTimeMs(exam) {
    const seconds = typeof exam.secondsPerQuestion === "number" ? exam.secondsPerQuestion : DEFAULT_SECONDS;
    return seconds * (exam.questions?.length || 0) * 1e3;
  }
  function stopTimer(sess) {
    finalizeActiveQuestionTiming(sess);
    const handle = timerHandles.get(sess);
    if (handle) {
      clearInterval(handle);
      timerHandles.delete(sess);
    }
    if (sess?.startedAt) {
      const now = Date.now();
      const delta = Math.max(0, now - sess.startedAt);
      sess.elapsedMs = (sess.elapsedMs || 0) + delta;
      if (sess.exam?.timerMode === "timed" && typeof sess.remainingMs === "number") {
        sess.remainingMs = Math.max(0, sess.remainingMs - delta);
      }
      sess.startedAt = null;
      updateTimerElement(sess);
    }
  }
  function ensureTimer(sess, render) {
    if (!sess || sess.mode !== "taking" || sess.exam.timerMode !== "timed") return;
    if (timerHandles.has(sess)) return;
    if (typeof sess.remainingMs !== "number") {
      sess.remainingMs = totalExamTimeMs(sess.exam);
    }
    if (typeof sess.elapsedMs !== "number") sess.elapsedMs = 0;
    sess.startedAt = Date.now();
    const handle = setInterval(() => {
      const now = Date.now();
      const last = sess.startedAt || now;
      const delta = Math.max(0, now - last);
      sess.startedAt = now;
      sess.elapsedMs = (sess.elapsedMs || 0) + delta;
      sess.remainingMs = Math.max(0, (sess.remainingMs ?? 0) - delta);
      if (sess.remainingMs <= 0) {
        stopTimer(sess);
        finalizeExam(sess, render, { autoSubmit: true });
      } else {
        updateTimerElement(sess);
      }
    }, 1e3);
    timerHandles.set(sess, handle);
  }
  function teardownKeyboardNavigation() {
    if (keyHandler) {
      window.removeEventListener("keydown", keyHandler);
      keyHandler = null;
      keyHandlerSession = null;
    }
  }
  function setupKeyboardNavigation(sess, render) {
    if (!sess || sess.mode === "summary") {
      teardownKeyboardNavigation();
      return;
    }
    if (keyHandler && keyHandlerSession === sess) return;
    teardownKeyboardNavigation();
    keyHandlerSession = sess;
    keyHandler = (event) => {
      if (event.defaultPrevented) return;
      const target = event.target;
      if (target instanceof HTMLElement) {
        const tag = target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || target.isContentEditable) return;
      }
      if (event.key === "ArrowRight") {
        if (sess.idx < sess.exam.questions.length - 1) {
          event.preventDefault();
          navigateToQuestion(sess, sess.idx + 1, render);
        }
      } else if (event.key === "ArrowLeft") {
        if (sess.idx > 0) {
          event.preventDefault();
          navigateToQuestion(sess, sess.idx - 1, render);
        }
      }
    };
    window.addEventListener("keydown", keyHandler);
  }
  function formatCountdown(ms) {
    const totalSeconds = Math.max(0, Math.ceil(ms / 1e3));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    if (hours > 0) {
      return [hours, minutes, seconds].map((val) => String(val).padStart(2, "0")).join(":");
    }
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }
  function currentElapsedMs(sess) {
    const base = sess?.elapsedMs || 0;
    if (sess?.startedAt) {
      return base + Math.max(0, Date.now() - sess.startedAt);
    }
    return base;
  }
  function slugify2(text) {
    const lowered = (text || "").toLowerCase();
    const normalized2 = lowered.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    return normalized2 || "exam";
  }
  function triggerExamDownload(exam) {
    try {
      const data = JSON.stringify(exam, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${slugify2(exam.examTitle || "exam")}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 0);
      return true;
    } catch (err) {
      console.warn("Failed to export exam", err);
      return false;
    }
  }
  function examToCsv(exam) {
    const rows = [];
    rows.push(CSV_HEADERS);
    const metaRow = new Array(CSV_HEADERS.length).fill("");
    metaRow[0] = CSV_ROW_META;
    metaRow[1] = exam.examTitle || "";
    metaRow[2] = exam.timerMode === "timed" ? "timed" : "untimed";
    metaRow[3] = Number.isFinite(exam.secondsPerQuestion) ? String(exam.secondsPerQuestion) : String(DEFAULT_SECONDS);
    rows.push(metaRow);
    (exam.questions || []).forEach((question) => {
      const row = new Array(CSV_HEADERS.length).fill("");
      row[0] = CSV_ROW_QUESTION;
      row[4] = question.stem || "";
      const options = Array.isArray(question.options) ? question.options : [];
      options.slice(0, CSV_MAX_OPTIONS).forEach((opt, idx) => {
        const optionCol = csvOptionIndex(idx + 1);
        const correctCol = csvOptionCorrectIndex(idx + 1);
        row[optionCol] = opt.text || "";
        row[correctCol] = opt.id === question.answer ? "TRUE" : "";
      });
      if (CSV_EXPLANATION_INDEX >= 0) row[CSV_EXPLANATION_INDEX] = question.explanation || "";
      if (CSV_TAGS_INDEX >= 0) row[CSV_TAGS_INDEX] = Array.isArray(question.tags) ? question.tags.join(" | ") : "";
      if (CSV_MEDIA_INDEX >= 0) row[CSV_MEDIA_INDEX] = question.media || "";
      rows.push(row);
    });
    return rows.map((row) => row.map(csvEscape).join(",")).join("\r\n");
  }
  function downloadExamCsv(exam) {
    const csv = examToCsv(exam);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    downloadBlob(blob, `${slugify2(exam.examTitle || "exam")}.csv`);
  }
  function downloadExamCsvTemplate() {
    const sampleQuestion = createBlankQuestion();
    sampleQuestion.stem = sanitizeRichText("What is the capital of France?");
    sampleQuestion.options = [
      { id: uid(), text: sanitizeRichText("Paris") },
      { id: uid(), text: sanitizeRichText("London") },
      { id: uid(), text: sanitizeRichText("Rome") }
    ];
    sampleQuestion.answer = sampleQuestion.options[0]?.id || "";
    sampleQuestion.explanation = sanitizeRichText("Paris is the capital and most populous city of France.");
    sampleQuestion.tags = ["geography"];
    const { exam } = ensureExamShape({
      examTitle: "Example Exam",
      timerMode: "untimed",
      secondsPerQuestion: DEFAULT_SECONDS,
      questions: [sampleQuestion],
      results: []
    });
    const csv = examToCsv(exam);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    downloadBlob(blob, "exam-template.csv");
  }
  function parseCsv(text) {
    const rows = [];
    let current = "";
    let row = [];
    let inQuotes = false;
    for (let i = 0; i < text.length; i += 1) {
      const char = text[i];
      if (inQuotes) {
        if (char === '"') {
          if (text[i + 1] === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = false;
          }
        } else {
          current += char;
        }
      } else if (char === '"') {
        inQuotes = true;
      } else if (char === ",") {
        row.push(current);
        current = "";
      } else if (char === "\r") {
        row.push(current);
        rows.push(row);
        row = [];
        current = "";
        if (text[i + 1] === "\n") i += 1;
      } else if (char === "\n") {
        row.push(current);
        rows.push(row);
        row = [];
        current = "";
      } else {
        current += char;
      }
    }
    row.push(current);
    if (row.length > 1 || row[0].trim()) {
      rows.push(row);
    }
    return rows.filter((r) => !(r.length === 1 && r[0].trim() === ""));
  }
  function examFromCsv(text) {
    const rows = parseCsv(text);
    if (!rows.length) {
      throw new Error("Empty CSV");
    }
    const header = rows[0].map((col) => col.trim());
    const indexMap = /* @__PURE__ */ new Map();
    header.forEach((name, idx) => {
      if (!name) return;
      indexMap.set(name, idx);
    });
    const getCell = (row, key) => {
      const idx = indexMap.has(key) ? indexMap.get(key) : -1;
      if (idx == null || idx < 0) return "";
      return row[idx] ?? "";
    };
    const base = {
      examTitle: "Imported Exam",
      timerMode: "untimed",
      secondsPerQuestion: DEFAULT_SECONDS,
      questions: [],
      results: []
    };
    rows.slice(1).forEach((row) => {
      const type = String(getCell(row, "type") || "").trim().toLowerCase();
      if (!type) return;
      if (type === CSV_ROW_META) {
        const title = String(getCell(row, "examTitle") || "").trim();
        if (title) base.examTitle = title;
        const mode2 = String(getCell(row, "timerMode") || "").trim().toLowerCase();
        if (mode2 === "timed" || mode2 === "untimed") base.timerMode = mode2;
        const seconds = Number(getCell(row, "secondsPerQuestion"));
        if (Number.isFinite(seconds) && seconds > 0) base.secondsPerQuestion = seconds;
        return;
      }
      if (type !== CSV_ROW_QUESTION) return;
      const question = createBlankQuestion();
      question.stem = sanitizeRichText(getCell(row, "stem"));
      question.explanation = sanitizeRichText(getCell(row, "explanation"));
      question.tags = parseTagString(getCell(row, "tags"));
      question.media = String(getCell(row, "media") || "").trim();
      question.options = [];
      question.answer = "";
      for (let i = 1; i <= CSV_MAX_OPTIONS; i += 1) {
        const optionHtml2 = sanitizeRichText(getCell(row, `option${i}`));
        if (!optionHtml2) continue;
        const option = { id: uid(), text: optionHtml2 };
        question.options.push(option);
        if (!question.answer && parseBooleanFlag(getCell(row, `option${i}Correct`))) {
          question.answer = option.id;
        }
      }
      if (question.options.length < 2) {
        return;
      }
      if (!question.answer) {
        question.answer = question.options[0].id;
      }
      base.questions.push(question);
    });
    if (!base.questions.length) {
      throw new Error("No questions found in CSV");
    }
    return ensureExamShape(base).exam;
  }
  function ensureExamShape(exam) {
    const next = clone5(exam) || {};
    let changed = false;
    if (!next.id) {
      next.id = uid();
      changed = true;
    }
    if (!next.examTitle) {
      next.examTitle = "Untitled Exam";
      changed = true;
    }
    if (next.timerMode !== "timed") {
      if (next.timerMode !== "untimed") changed = true;
      next.timerMode = "untimed";
    }
    if (typeof next.secondsPerQuestion !== "number" || next.secondsPerQuestion <= 0) {
      next.secondsPerQuestion = DEFAULT_SECONDS;
      changed = true;
    }
    if (!Array.isArray(next.questions)) {
      next.questions = [];
      changed = true;
    }
    next.questions = next.questions.map((q) => {
      const question = { ...q };
      if (!question.id) {
        question.id = uid();
        changed = true;
      }
      const originalStem = question.stem;
      question.stem = sanitizeRichText(question.stem);
      if (originalStem !== question.stem) changed = true;
      if (!Array.isArray(question.options)) {
        question.options = [];
        changed = true;
      }
      question.options = question.options.map((opt) => {
        const option = { ...opt };
        if (!option.id) {
          option.id = uid();
          changed = true;
        }
        const originalText = option.text;
        option.text = sanitizeRichText(option.text);
        if (originalText !== option.text) changed = true;
        return option;
      });
      if (!question.answer || !question.options.some((opt) => opt.id === question.answer)) {
        question.answer = question.options[0]?.id || "";
        changed = true;
      }
      const originalExplanation = question.explanation;
      question.explanation = sanitizeRichText(question.explanation);
      if (originalExplanation !== question.explanation) changed = true;
      const normalizedTags = ensureArrayTags(question.tags);
      if (question.tags?.length !== normalizedTags.length || question.tags?.some((t, idx) => t !== normalizedTags[idx])) {
        question.tags = normalizedTags;
        changed = true;
      } else {
        question.tags = normalizedTags;
      }
      if (question.media == null) {
        question.media = "";
        changed = true;
      }
      return question;
    });
    if (!Array.isArray(next.results)) {
      next.results = [];
      changed = true;
    }
    next.results = next.results.map((res) => {
      const result = { ...res };
      if (!result.id) {
        result.id = uid();
        changed = true;
      }
      if (typeof result.when !== "number") {
        result.when = Date.now();
        changed = true;
      }
      if (typeof result.correct !== "number") {
        result.correct = Number(result.correct) || 0;
        changed = true;
      }
      if (typeof result.total !== "number") {
        result.total = Number(result.total) || (next.questions?.length ?? 0);
        changed = true;
      }
      if (!result.answers || typeof result.answers !== "object") {
        result.answers = {};
        changed = true;
      }
      if (!Array.isArray(result.flagged)) {
        result.flagged = [];
        changed = true;
      }
      if (typeof result.durationMs !== "number") {
        result.durationMs = 0;
        changed = true;
      }
      if (typeof result.answered !== "number") {
        result.answered = Object.keys(result.answers || {}).length;
        changed = true;
      }
      return result;
    });
    return { exam: next, changed };
  }
  function createBlankQuestion() {
    return {
      id: uid(),
      stem: "",
      options: [1, 2, 3, 4].map(() => ({ id: uid(), text: "" })),
      answer: "",
      explanation: "",
      tags: [],
      media: ""
    };
  }
  function createTakingSession(exam) {
    const snapshot = clone5(exam);
    const totalMs = snapshot.timerMode === "timed" ? totalExamTimeMs(snapshot) : null;
    return {
      mode: "taking",
      exam: snapshot,
      idx: 0,
      answers: {},
      flagged: {},
      checked: {},
      startedAt: Date.now(),
      elapsedMs: 0,
      remainingMs: totalMs,
      baseExam: null,
      subsetIndices: null,
      questionStats: snapshot.questions.map(() => ({
        timeMs: 0,
        changes: [],
        enteredAt: null,
        initialAnswer: null,
        initialAnswerAt: null
      }))
    };
  }
  function hydrateSavedSession(saved, fallbackExam) {
    const baseExam = saved?.exam ? ensureExamShape(saved.exam).exam : fallbackExam;
    const exam = clone5(baseExam);
    const questionCount = exam.questions.length;
    const idx = Math.min(Math.max(Number(saved?.idx) || 0, 0), Math.max(0, questionCount - 1));
    const remaining = typeof saved?.remainingMs === "number" ? Math.max(0, saved.remainingMs) : exam.timerMode === "timed" ? totalExamTimeMs(exam) : null;
    const elapsed = Math.max(0, Number(saved?.elapsedMs) || 0);
    return {
      mode: "taking",
      exam,
      idx,
      answers: saved?.answers ? { ...saved.answers } : {},
      flagged: saved?.flagged ? { ...saved.flagged } : {},
      checked: saved?.checked ? { ...saved.checked } : {},
      startedAt: Date.now(),
      elapsedMs: elapsed,
      remainingMs: remaining,
      baseExam: saved?.baseExam ? ensureExamShape(saved.baseExam).exam : null,
      subsetIndices: Array.isArray(saved?.subsetIndices) ? [...saved.subsetIndices] : null,
      questionStats: exam.questions.map((_, questionIdx) => {
        const stat = saved?.questionStats?.[questionIdx] || {};
        return {
          timeMs: Number.isFinite(stat.timeMs) ? stat.timeMs : 0,
          changes: Array.isArray(stat.changes) ? stat.changes.map((change) => ({ ...change })) : [],
          enteredAt: null,
          initialAnswer: stat.initialAnswer ?? null,
          initialAnswerAt: Number.isFinite(stat.initialAnswerAt) ? stat.initialAnswerAt : null
        };
      })
    };
  }
  async function renderExams(root2, render) {
    const scroller = resolveScrollContainer(root2);
    examViewScrollTop = readScrollPosition(scroller);
    root2.innerHTML = "";
    root2.className = "exam-view";
    const controls = document.createElement("div");
    controls.className = "exam-controls";
    const heading = document.createElement("div");
    heading.className = "exam-heading";
    heading.innerHTML = "<h1>Exams</h1><p>Import exams, take them, and review your attempts.</p>";
    controls.appendChild(heading);
    const actions = document.createElement("div");
    actions.className = "exam-control-actions";
    const status = document.createElement("div");
    status.className = "exam-status";
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json,.csv,application/json,text/csv";
    fileInput.style.display = "none";
    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const name = (file.name || "").toLowerCase();
        if (name.endsWith(".csv") || (file.type || "").includes("csv")) {
          const text = await file.text();
          const imported = examFromCsv(text);
          await upsertExam({ ...imported, updatedAt: Date.now() });
          lastExamStatusMessage = `Imported "${imported.examTitle}" from CSV.`;
          render();
        } else {
          const text = await file.text();
          const parsed = JSON.parse(text);
          const { exam } = ensureExamShape(parsed);
          await upsertExam({ ...exam, updatedAt: Date.now() });
          lastExamStatusMessage = `Imported "${exam.examTitle}" from JSON.`;
          render();
        }
      } catch (err) {
        console.warn("Failed to import exam", err);
        status.textContent = "Unable to import exam \u2014 check the file format.";
      } finally {
        fileInput.value = "";
      }
    });
    const importBtn = document.createElement("button");
    importBtn.type = "button";
    importBtn.className = "btn secondary";
    importBtn.textContent = "Import JSON/CSV";
    importBtn.addEventListener("click", () => fileInput.click());
    actions.appendChild(importBtn);
    const templateBtn = document.createElement("button");
    templateBtn.type = "button";
    templateBtn.className = "btn secondary";
    templateBtn.textContent = "CSV Template";
    templateBtn.addEventListener("click", () => {
      try {
        downloadExamCsvTemplate();
        status.textContent = "CSV template downloaded.";
      } catch (err) {
        console.warn("Failed to create CSV template", err);
        status.textContent = "Unable to download template.";
      }
    });
    actions.appendChild(templateBtn);
    const newBtn = document.createElement("button");
    newBtn.type = "button";
    newBtn.className = "btn";
    newBtn.textContent = "New Exam";
    newBtn.addEventListener("click", () => openExamEditor(null, render));
    actions.appendChild(newBtn);
    controls.appendChild(actions);
    const layout = state.examLayout || { mode: "grid", detailsVisible: false };
    const viewMode = layout.mode === "row" ? "row" : "grid";
    const detailsVisible = layout.detailsVisible !== false;
    const layoutControls = document.createElement("div");
    layoutControls.className = "exam-layout-controls";
    const layoutToggle = document.createElement("button");
    layoutToggle.type = "button";
    layoutToggle.className = "exam-layout-toggle";
    layoutToggle.setAttribute("aria-pressed", viewMode === "row" ? "true" : "false");
    layoutToggle.setAttribute("aria-label", viewMode === "row" ? "Switch to column view" : "Switch to row view");
    const toggleIcon = document.createElement("span");
    toggleIcon.className = "exam-layout-toggle-icon";
    layoutToggle.appendChild(toggleIcon);
    const toggleText = document.createElement("span");
    toggleText.className = "sr-only";
    toggleText.textContent = viewMode === "row" ? "Show exams in columns" : "Show exams in rows";
    layoutToggle.appendChild(toggleText);
    layoutToggle.addEventListener("click", () => {
      const nextMode = viewMode === "row" ? "grid" : "row";
      setExamLayout({ mode: nextMode });
      render();
    });
    layoutControls.appendChild(layoutToggle);
    controls.appendChild(layoutControls);
    controls.appendChild(status);
    root2.appendChild(controls);
    root2.appendChild(fileInput);
    if (lastExamStatusMessage) {
      status.textContent = lastExamStatusMessage;
      lastExamStatusMessage = "";
    } else {
      status.textContent = "";
    }
    const [stored, savedSessions] = await Promise.all([
      listExams(),
      listExamSessions()
    ]);
    const exams = [];
    const pendingUpdates = [];
    for (const raw of stored) {
      const { exam, changed } = ensureExamShape(raw);
      exams.push(exam);
      if (changed) {
        pendingUpdates.push(upsertExam(exam).catch((err) => {
          console.warn("Failed to normalize exam", err);
        }));
      }
    }
    if (pendingUpdates.length) {
      await Promise.all(pendingUpdates);
    }
    exams.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
    const sessionMap = /* @__PURE__ */ new Map();
    for (const sess of savedSessions) {
      if (sess?.examId) sessionMap.set(sess.examId, sess);
    }
    const cleanupTasks = [];
    for (const sess of savedSessions) {
      if (!exams.find((ex) => ex.id === sess.examId)) {
        cleanupTasks.push(deleteExamSessionProgress(sess.examId).catch((err) => {
          console.warn("Failed to cleanup orphaned exam session", err);
        }));
      }
    }
    if (cleanupTasks.length) {
      await Promise.all(cleanupTasks);
    }
    if (!exams.length) {
      const empty = document.createElement("div");
      empty.className = "exam-empty";
      empty.innerHTML = "<p>No exams yet. Import a JSON or CSV exam, download the template, or create one from scratch.</p>";
      root2.appendChild(empty);
      return;
    }
    const layoutSnapshot = { mode: viewMode, detailsVisible };
    const grid = document.createElement("div");
    grid.className = "exam-grid";
    if (viewMode === "row") {
      grid.classList.add("exam-grid--row");
    }
    const frag = document.createDocumentFragment();
    exams.forEach((exam) => {
      frag.appendChild(buildExamCard(exam, render, sessionMap.get(exam.id), status, layoutSnapshot));
    });
    grid.appendChild(frag);
    root2.appendChild(grid);
    applyScrollPosition(scroller, examViewScrollTop);
  }
  function buildExamCard(exam, render, savedSession, statusEl, layout) {
    const layoutMode = layout?.mode === "row" ? "row" : "grid";
    const defaultExpanded = layout?.detailsVisible !== false;
    const expandedState = state.examAttemptExpanded[exam.id];
    const isExpanded = expandedState != null ? expandedState : defaultExpanded;
    const last = latestResult(exam);
    const best = bestResult(exam);
    const card = document.createElement("article");
    card.className = "card exam-card";
    if (layoutMode === "row") {
      card.classList.add("exam-card--row");
    }
    if (isExpanded) {
      card.classList.add("exam-card--expanded");
    }
    const header = document.createElement("div");
    header.className = "exam-card-header";
    card.appendChild(header);
    const summaryButton = document.createElement("button");
    summaryButton.type = "button";
    summaryButton.className = "exam-card-summary";
    summaryButton.setAttribute("aria-expanded", isExpanded ? "true" : "false");
    summaryButton.addEventListener("click", () => {
      const nextExpanded = !isExpanded;
      if (nextExpanded) {
        state.examAttemptExpanded = {};
      }
      setExamAttemptExpanded(exam.id, nextExpanded);
      render();
    });
    header.appendChild(summaryButton);
    const summaryContent = document.createElement("div");
    summaryContent.className = "exam-card-summary-content";
    summaryButton.appendChild(summaryContent);
    const titleGroup = document.createElement("div");
    titleGroup.className = "exam-card-title-group";
    summaryContent.appendChild(titleGroup);
    const title = document.createElement("h2");
    title.className = "exam-card-title";
    title.textContent = exam.examTitle;
    titleGroup.appendChild(title);
    const meta = document.createElement("div");
    meta.className = "exam-card-meta";
    const questionCount = document.createElement("span");
    questionCount.textContent = `${exam.questions.length} question${exam.questions.length === 1 ? "" : "s"}`;
    meta.appendChild(questionCount);
    const timerInfo = document.createElement("span");
    timerInfo.textContent = exam.timerMode === "timed" ? `Timed \u2022 ${exam.secondsPerQuestion}s/question` : "Untimed";
    meta.appendChild(timerInfo);
    titleGroup.appendChild(meta);
    const glance = document.createElement("div");
    glance.className = "exam-card-pills";
    summaryContent.appendChild(glance);
    if (exam.results.length) {
      const attemptsChip = document.createElement("span");
      attemptsChip.className = "exam-card-chip";
      attemptsChip.textContent = `${exam.results.length} attempt${exam.results.length === 1 ? "" : "s"}`;
      attemptsChip.title = `${exam.results.length} recorded attempt${exam.results.length === 1 ? "" : "s"}`;
      glance.appendChild(attemptsChip);
    }
    if (best) {
      const badge = createScoreBadge(best);
      badge.classList.add("exam-score-badge--pill");
      badge.dataset.badge = "best";
      badge.title = `Best attempt \u2022 ${formatScore(best)}`;
      badge.setAttribute("aria-label", `Best attempt ${formatScore(best)}`);
      glance.appendChild(badge);
    }
    if (last && (!best || last.id !== best.id)) {
      const badge = createScoreBadge(last);
      badge.classList.add("exam-score-badge--pill");
      badge.dataset.badge = "last";
      badge.title = `Last attempt \u2022 ${formatScore(last)}`;
      badge.setAttribute("aria-label", `Last attempt ${formatScore(last)}`);
      glance.appendChild(badge);
    }
    if (savedSession) {
      const progressChip = document.createElement("span");
      progressChip.className = "exam-card-chip exam-card-chip--progress";
      progressChip.textContent = "In progress";
      glance.appendChild(progressChip);
    }
    const caret = document.createElement("span");
    caret.className = "exam-card-caret";
    summaryButton.appendChild(caret);
    const quickAction = document.createElement("div");
    quickAction.className = "exam-card-cta";
    header.appendChild(quickAction);
    const quickBtn = document.createElement("button");
    quickBtn.className = "btn exam-card-primary";
    quickBtn.disabled = !savedSession && !last && exam.questions.length === 0;
    quickAction.appendChild(quickBtn);
    if (savedSession) {
      quickBtn.textContent = "Resume";
      quickBtn.addEventListener("click", async () => {
        const latest = await loadExamSession(exam.id);
        if (!latest) {
          if (statusEl) statusEl.textContent = "Saved attempt could not be found.";
          render();
          return;
        }
        const session = hydrateSavedSession(latest, exam);
        setExamSession(session);
        render();
      });
    } else if (last) {
      quickBtn.textContent = "Review";
      quickBtn.addEventListener("click", () => {
        const reviewPacket = resolveReviewPacket(exam, last);
        setExamSession({ mode: "review", exam: clone5(reviewPacket.exam), result: clone5(reviewPacket.result), idx: 0 });
        render();
      });
    } else {
      quickBtn.textContent = "Start";
      quickBtn.addEventListener("click", () => {
        setExamSession(createTakingSession(exam));
        render();
      });
    }
    const menuWrap = document.createElement("div");
    menuWrap.className = "exam-card-menu";
    quickAction.appendChild(menuWrap);
    const menuToggle = document.createElement("button");
    menuToggle.type = "button";
    menuToggle.className = "exam-card-menu-toggle";
    menuToggle.setAttribute("aria-haspopup", "true");
    menuToggle.setAttribute("aria-expanded", "false");
    const menuId = `exam-card-menu-${exam.id}`;
    menuToggle.setAttribute("aria-controls", menuId);
    const menuToggleIcon = document.createElement("span");
    menuToggleIcon.className = "exam-card-menu-toggle__icon";
    const menuToggleIconBar = document.createElement("span");
    menuToggleIconBar.className = "exam-card-menu-toggle__icon-bar";
    menuToggleIcon.appendChild(menuToggleIconBar);
    menuToggle.appendChild(menuToggleIcon);
    const menuToggleLabel = document.createElement("span");
    menuToggleLabel.className = "exam-card-menu-toggle__label";
    menuToggleLabel.textContent = "Actions";
    menuToggle.appendChild(menuToggleLabel);
    const menuToggleSr = document.createElement("span");
    menuToggleSr.className = "sr-only";
    menuToggleSr.textContent = "Toggle exam actions";
    menuToggle.appendChild(menuToggleSr);
    menuWrap.appendChild(menuToggle);
    const menuPanel = document.createElement("div");
    menuPanel.className = "exam-card-menu-panel";
    menuPanel.id = menuId;
    menuPanel.setAttribute("aria-hidden", "true");
    menuPanel.setAttribute("role", "menu");
    menuWrap.appendChild(menuPanel);
    let menuOpen = false;
    const handleOutside = (event) => {
      if (!menuOpen) return;
      if (menuWrap.contains(event.target)) return;
      closeMenu();
    };
    const handleKeydown = (event) => {
      if (!menuOpen) return;
      if (event.key === "Escape") {
        event.preventDefault();
        closeMenu();
        menuToggle.focus();
      }
    };
    const handleFocus = (event) => {
      if (!menuOpen) return;
      if (menuWrap.contains(event.target)) return;
      closeMenu();
    };
    function openMenu() {
      if (menuOpen) return;
      menuOpen = true;
      menuWrap.classList.add("exam-card-menu--open");
      const panelHeight = menuPanel.scrollHeight || menuPanel.offsetHeight || 0;
      menuWrap.style.setProperty("--menu-panel-gap", `${Math.round(panelHeight + 24)}px`);
      menuToggle.setAttribute("aria-expanded", "true");
      menuPanel.setAttribute("aria-hidden", "false");
      document.addEventListener("click", handleOutside, true);
      document.addEventListener("keydown", handleKeydown, true);
      document.addEventListener("focusin", handleFocus, true);
    }
    function closeMenu() {
      if (!menuOpen) return;
      menuOpen = false;
      menuWrap.classList.remove("exam-card-menu--open");
      menuWrap.style.setProperty("--menu-panel-gap", "0px");
      menuToggle.setAttribute("aria-expanded", "false");
      menuPanel.setAttribute("aria-hidden", "true");
      document.removeEventListener("click", handleOutside, true);
      document.removeEventListener("keydown", handleKeydown, true);
      document.removeEventListener("focusin", handleFocus, true);
    }
    menuToggle.addEventListener("click", (event) => {
      event.stopPropagation();
      if (menuOpen) {
        closeMenu();
      } else {
        openMenu();
      }
    });
    menuPanel.addEventListener("click", (event) => {
      event.stopPropagation();
    });
    const addMenuAction = (label, handler, options = {}) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "exam-card-menu-item";
      item.setAttribute("role", "menuitem");
      if (options.variant === "danger") {
        item.classList.add("is-danger");
      }
      if (options.disabled) {
        item.disabled = true;
      }
      item.textContent = label;
      item.addEventListener("click", async () => {
        if (item.disabled) return;
        const result = await handler();
        if (result === false) return;
        closeMenu();
      });
      menuPanel.appendChild(item);
    };
    addMenuAction("Restart Exam", async () => {
      if (exam.questions.length === 0) return false;
      if (savedSession) {
        const confirm = await confirmModal("Start a new attempt and discard saved progress?");
        if (!confirm) return false;
        await deleteExamSessionProgress(exam.id).catch(() => {
        });
      }
      setExamSession(createTakingSession(exam));
      render();
    }, { disabled: exam.questions.length === 0 });
    if (last) {
      addMenuAction("Review Last Attempt", () => {
        const reviewPacket = resolveReviewPacket(exam, last);
        setExamSession({ mode: "review", exam: clone5(reviewPacket.exam), result: clone5(reviewPacket.result), idx: 0 });
        render();
      });
    }
    addMenuAction("Edit Exam", () => {
      openExamEditor(exam, render);
    });
    addMenuAction("Export JSON", () => {
      const ok = triggerExamDownload(exam);
      if (!ok && statusEl) {
        statusEl.textContent = "Unable to export exam.";
      } else if (ok && statusEl) {
        statusEl.textContent = "Exam exported as JSON.";
      }
    });
    addMenuAction("Export CSV", () => {
      try {
        downloadExamCsv(exam);
        if (statusEl) statusEl.textContent = "Exam exported as CSV.";
      } catch (err) {
        console.warn("Failed to export exam CSV", err);
        if (statusEl) statusEl.textContent = "Unable to export exam CSV.";
      }
    });
    addMenuAction("Delete Exam", async () => {
      const ok = await confirmModal(`Delete "${exam.examTitle}"? This will remove all attempts.`);
      if (!ok) return false;
      await deleteExamSessionProgress(exam.id).catch(() => {
      });
      await deleteExam(exam.id);
      render();
    }, { variant: "danger" });
    const details = document.createElement("div");
    details.className = "exam-card-details";
    if (!isExpanded) {
      details.setAttribute("hidden", "true");
    }
    card.appendChild(details);
    if (savedSession) {
      const banner = document.createElement("div");
      banner.className = "exam-saved-banner";
      const updated = savedSession.updatedAt ? new Date(savedSession.updatedAt).toLocaleString() : null;
      banner.textContent = updated ? `Saved attempt \u2022 ${updated}` : "Saved attempt available";
      details.appendChild(banner);
    }
    const attemptsWrap = document.createElement("div");
    attemptsWrap.className = "exam-attempts";
    const attemptsHeader = document.createElement("div");
    attemptsHeader.className = "exam-attempts-header";
    const attemptsTitle = document.createElement("h3");
    attemptsTitle.textContent = "Attempts";
    attemptsHeader.appendChild(attemptsTitle);
    const attemptsCount = document.createElement("span");
    attemptsCount.className = "exam-attempt-count";
    attemptsCount.textContent = String(exam.results.length);
    attemptsHeader.appendChild(attemptsCount);
    attemptsWrap.appendChild(attemptsHeader);
    if (!exam.results.length) {
      const none = document.createElement("p");
      none.className = "exam-attempt-empty";
      none.textContent = "No attempts yet.";
      attemptsWrap.appendChild(none);
    } else {
      const list = document.createElement("div");
      list.className = "exam-attempt-list";
      [...exam.results].sort((a, b) => b.when - a.when).forEach((result) => {
        list.appendChild(buildAttemptRow(exam, result, render));
      });
      attemptsWrap.appendChild(list);
    }
    details.appendChild(attemptsWrap);
    return card;
  }
  function buildAttemptRow(exam, result, render) {
    const row = document.createElement("div");
    row.className = "exam-attempt-row";
    const wrongIndices = incorrectQuestionIndices(exam, result);
    const main = document.createElement("div");
    main.className = "exam-attempt-main";
    row.appendChild(main);
    const badge = createScoreBadge(result);
    badge.classList.add("exam-score-badge--pill", "exam-attempt-score");
    badge.title = formatScore(result);
    main.appendChild(badge);
    const details = document.createElement("div");
    details.className = "exam-attempt-details";
    main.appendChild(details);
    const date = document.createElement("div");
    date.className = "exam-attempt-date";
    date.textContent = new Date(result.when).toLocaleString();
    details.appendChild(date);
    const meta = document.createElement("div");
    meta.className = "exam-attempt-meta";
    const answeredText = `${result.answered}/${result.total} answered`;
    const flaggedText = `${result.flagged.length} flagged`;
    const durationText = result.durationMs ? formatDuration(result.durationMs) : "\u2014";
    meta.textContent = `${answeredText} \u2022 ${flaggedText} \u2022 ${durationText}`;
    details.appendChild(meta);
    const actions = document.createElement("div");
    actions.className = "exam-attempt-actions";
    row.appendChild(actions);
    const review = document.createElement("button");
    review.className = "btn secondary exam-attempt-review";
    review.textContent = "Review";
    review.addEventListener("click", () => {
      const reviewPacket = resolveReviewPacket(exam, result);
      setExamSession({ mode: "review", exam: clone5(reviewPacket.exam), result: clone5(reviewPacket.result), idx: 0 });
      render();
    });
    actions.appendChild(review);
    const retakeIncorrect = document.createElement("button");
    retakeIncorrect.className = "btn secondary exam-attempt-retake";
    retakeIncorrect.textContent = "Retake Incorrect";
    retakeIncorrect.disabled = wrongIndices.length === 0;
    retakeIncorrect.addEventListener("click", () => {
      const subset = subsetExamForIndices(exam, null, wrongIndices);
      if (!subset) return;
      const session = createTakingSession(subset.exam);
      session.baseExam = clone5(exam);
      session.subsetIndices = [...wrongIndices];
      setExamSession(session);
      render();
    });
    actions.appendChild(retakeIncorrect);
    return row;
  }
  function createStat(label, value) {
    const wrap = document.createElement("div");
    wrap.className = "exam-stat";
    const lbl = document.createElement("div");
    lbl.className = "exam-stat-label";
    lbl.textContent = label;
    const val = document.createElement("div");
    val.className = "exam-stat-value";
    val.textContent = value;
    wrap.appendChild(lbl);
    wrap.appendChild(val);
    return wrap;
  }
  function latestResult(exam) {
    if (!exam.results?.length) return null;
    return exam.results.reduce((acc, res) => acc == null || res.when > acc.when ? res : acc, null);
  }
  function bestResult(exam) {
    if (!exam.results?.length) return null;
    return exam.results.reduce((acc, res) => {
      const pct = res.total ? res.correct / res.total : 0;
      const bestPct = acc?.total ? acc.correct / acc.total : -1;
      if (!acc || pct > bestPct) return res;
      return acc;
    }, null);
  }
  function formatScore(result) {
    const pct = result.total ? Math.round(result.correct / result.total * 100) : 0;
    return `${result.correct}/${result.total} \u2022 ${pct}%`;
  }
  function formatDuration(ms) {
    if (ms == null) return "\u2014";
    const totalSeconds = Math.max(0, Math.round(ms / 1e3));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    const parts = [];
    if (hours) parts.push(`${hours}h`);
    if (minutes) parts.push(`${minutes}m`);
    parts.push(`${seconds}s`);
    return parts.join(" ");
  }
  function optionText(question, id) {
    const html = question.options.find((opt) => opt.id === id)?.text || "";
    return htmlToPlainText(html).trim();
  }
  function optionHtml(question, id) {
    const html = question.options.find((opt) => opt.id === id)?.text || "";
    return sanitizeRichText(html);
  }
  function mediaElement(source) {
    if (!source) return null;
    const wrap = document.createElement("div");
    wrap.className = "exam-media";
    const lower = source.toLowerCase();
    if (lower.startsWith("data:video") || /\.(mp4|webm|ogg)$/i.test(lower)) {
      const video = document.createElement("video");
      video.controls = true;
      video.src = source;
      wrap.appendChild(video);
    } else if (lower.startsWith("data:audio") || /\.(mp3|wav|ogg)$/i.test(lower)) {
      const audio = document.createElement("audio");
      audio.controls = true;
      audio.src = source;
      wrap.appendChild(audio);
    } else {
      const img = document.createElement("img");
      img.src = source;
      img.alt = "Question media";
      img.classList.add("exam-zoomable-media");
      wrap.appendChild(img);
    }
    return wrap;
  }
  function toggleExamImageZoom(img) {
    if (!img) return;
    const nextState = !img.classList.contains("exam-zoomed");
    img.classList.toggle("exam-zoomed", nextState);
    img.setAttribute("aria-expanded", nextState ? "true" : "false");
  }
  function enhanceExamMedia(container) {
    if (!container) return;
    const selectors = [
      ".exam-media img",
      ".exam-stem img",
      ".exam-option .option-text img",
      ".exam-explanation-body img",
      ".exam-answer-html img"
    ];
    const images = container.querySelectorAll(selectors.join(", "));
    images.forEach((img) => {
      img.classList.add("exam-zoomable-media");
      img.addEventListener("dblclick", () => toggleExamImageZoom(img));
    });
  }
  function answerClass(question, selectedId, optionId) {
    const isCorrect = optionId === question.answer;
    if (selectedId == null) return isCorrect ? "correct-answer" : "";
    if (selectedId === optionId) {
      return selectedId === question.answer ? "correct-answer" : "incorrect-answer";
    }
    return isCorrect ? "correct-answer" : "";
  }
  function evaluateQuestionAnswer(question, answer) {
    const options = Array.isArray(question?.options) ? question.options : [];
    const responded = answer != null && answer !== "";
    if (!responded) {
      return {
        responded: false,
        isValid: false,
        isCorrect: false
      };
    }
    const matchedOption = options.find((opt) => opt.id === answer) || null;
    const isValid = Boolean(matchedOption);
    const isCorrect = isValid && matchedOption?.id === question?.answer;
    return {
      responded: true,
      isValid,
      isCorrect
    };
  }
  function incorrectQuestionIndices(exam, result) {
    if (!exam || !result) return [];
    const questions = Array.isArray(exam.questions) ? exam.questions : [];
    const subsetIndices = Array.isArray(result.subsetIndices) ? result.subsetIndices.filter((idx) => Number.isInteger(idx) && idx >= 0 && idx < questions.length) : null;
    const indices = subsetIndices && subsetIndices.length ? subsetIndices : questions.map((_, idx) => idx);
    return indices.reduce((list, idx) => {
      const question = questions[idx];
      const ans = result.answers?.[idx];
      if (ans == null || ans !== question?.answer) {
        list.push(idx);
      }
      return list;
    }, []);
  }
  function subsetExamForIndices(exam, result, indices) {
    const valid = Array.isArray(indices) ? indices.filter((idx) => Number.isInteger(idx) && idx >= 0 && idx < (exam?.questions?.length || 0)) : [];
    if (!exam || !valid.length) return null;
    const baseQuestions = Array.isArray(exam.questions) ? exam.questions : [];
    const nextExam = clone5(exam);
    nextExam.questions = valid.map((idx) => ({ ...clone5(baseQuestions[idx]), originalIndex: idx }));
    if (!result) return { exam: nextExam };
    const nextResult = clone5(result) || {};
    nextResult.answers = {};
    nextResult.flagged = [];
    nextResult.questionStats = [];
    let answered = 0;
    let correct = 0;
    valid.forEach((origIdx, newIdx) => {
      const answer = result.answers?.[origIdx];
      if (answer != null) {
        nextResult.answers[newIdx] = answer;
        answered += 1;
        if (answer === baseQuestions[origIdx]?.answer) {
          correct += 1;
        }
      }
      if (Array.isArray(result.flagged) && result.flagged.includes(origIdx)) {
        nextResult.flagged.push(newIdx);
      }
      const stat = Array.isArray(result.questionStats) ? clone5(result.questionStats[origIdx]) : null;
      nextResult.questionStats[newIdx] = stat || {
        timeMs: 0,
        changes: [],
        enteredAt: null,
        initialAnswer: null,
        initialAnswerAt: null
      };
    });
    nextResult.total = nextExam.questions.length;
    nextResult.correct = correct;
    nextResult.answered = answered;
    nextResult.changeSummary = summarizeAnswerChanges(nextResult.questionStats, nextExam, nextResult.answers);
    return { exam: nextExam, result: nextResult };
  }
  function resolveReviewPacket(exam, result) {
    if (!exam || !result) return { exam, result };
    if (Array.isArray(result.subsetIndices) && result.subsetIndices.length) {
      const subset = subsetExamForIndices(exam, result, result.subsetIndices);
      if (subset) return subset;
    }
    return { exam, result };
  }
  function renderQuestionMap(sidebar, sess, render) {
    const map = document.createElement("section");
    map.className = "question-map";
    const header = document.createElement("div");
    header.className = "question-map__header";
    const title = document.createElement("h3");
    title.textContent = "Question Map";
    header.appendChild(title);
    const questionCount = sess.exam.questions.length;
    const isReview = sess.mode === "review";
    const answers = isReview ? sess.result?.answers || {} : sess.answers || {};
    const answeredCount = sess.exam.questions.reduce((count, question, idx) => {
      const answer = answers[idx];
      const evaluation = evaluateQuestionAnswer(question, answer);
      return evaluation.responded ? count + 1 : count;
    }, 0);
    const countBadge = document.createElement("span");
    countBadge.className = "question-map__count";
    countBadge.textContent = `${answeredCount}/${questionCount} answered`;
    header.appendChild(countBadge);
    map.appendChild(header);
    const grid = document.createElement("div");
    grid.className = "question-map__grid";
    map.appendChild(grid);
    const statsList = isReview ? Array.isArray(sess.result?.questionStats) ? sess.result.questionStats : [] : Array.isArray(sess.questionStats) ? sess.questionStats : [];
    const summary = isReview ? summarizeAnswerChanges(statsList, sess.exam, answers) : null;
    if (isReview && sess.result) {
      sess.result.changeSummary = summary;
    }
    const flaggedSet = new Set(sess.mode === "review" ? sess.result.flagged || [] : Object.entries(sess.flagged || {}).filter(([_, v]) => v).map(([idx]) => Number(idx)));
    sess.exam.questions.forEach((question, idx) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "question-map__item";
      const number = document.createElement("span");
      number.className = "question-map__item-label";
      number.textContent = String(idx + 1);
      item.appendChild(number);
      const flagIndicator = document.createElement("span");
      flagIndicator.className = "question-map__item-flag";
      flagIndicator.setAttribute("aria-hidden", "true");
      flagIndicator.textContent = "\u{1F6A9}";
      item.appendChild(flagIndicator);
      const isCurrent = sess.idx === idx;
      item.classList.toggle("is-current", isCurrent);
      item.setAttribute("aria-pressed", isCurrent ? "true" : "false");
      if (isCurrent) {
        item.setAttribute("aria-current", "true");
      } else {
        item.removeAttribute("aria-current");
      }
      const answer = answers[idx];
      const evaluation = evaluateQuestionAnswer(question, answer);
      const { responded, isValid, isCorrect } = evaluation;
      const tooltipParts = [];
      const labelParts = [`Question ${idx + 1}`];
      let status = "unanswered";
      const wasChecked = !isReview && Boolean(sess.checked?.[idx]);
      if (isReview) {
        if (!responded) {
          status = "review-unanswered";
          tooltipParts.push("Not answered");
        } else if (!isValid) {
          status = "invalid";
          tooltipParts.push("Answered (option removed)");
        } else {
          status = isCorrect ? "correct" : "incorrect";
          tooltipParts.push(isCorrect ? "Answered correctly" : "Answered incorrectly");
        }
        const stat = statsList[idx];
        const changeDetails = analyzeAnswerChange(stat, question, answer);
        delete item.dataset.changeDirection;
        if (changeDetails.changed) {
          if (changeDetails.direction === "right-to-wrong") {
            item.dataset.changeDirection = "right-to-wrong";
            tooltipParts.push("Changed from correct to incorrect");
          } else if (changeDetails.direction === "wrong-to-right") {
            item.dataset.changeDirection = "wrong-to-right";
            tooltipParts.push("Changed from incorrect to correct");
          } else {
            item.dataset.changeDirection = "changed";
            tooltipParts.push("Changed answer");
          }
        } else if (changeDetails.switched) {
          item.dataset.changeDirection = "returned";
          tooltipParts.push("Changed answers but returned to start");
        }
      } else {
        if (!responded) {
          tooltipParts.push(wasChecked ? "Checked without answer" : "Not answered");
        } else if (!isValid) {
          status = "invalid";
          tooltipParts.push("Answer no longer matches options");
        } else if (wasChecked) {
          status = isCorrect ? "correct" : "incorrect";
          tooltipParts.push(isCorrect ? "Checked correct" : "Checked incorrect");
        } else {
          status = "answered";
          tooltipParts.push("Answered");
        }
      }
      item.dataset.status = status;
      if (status === "correct" || status === "incorrect") {
        item.classList.add("is-graded");
      } else if (status === "answered") {
        item.classList.add("is-answered");
      } else if (status === "invalid") {
        item.classList.add("is-invalid");
      } else {
        item.classList.add("is-unanswered");
      }
      if (status === "review-unanswered") {
        item.classList.add("is-review-unanswered");
      }
      if (status === "invalid") {
        labelParts.push("Answer needs review");
      }
      if (tooltipParts.length) {
        labelParts.push(...tooltipParts);
      }
      const flagged = flaggedSet.has(idx);
      if (flagged) {
        item.dataset.flagged = "true";
        flagIndicator.hidden = false;
        labelParts.push("Flagged");
      } else {
        delete item.dataset.flagged;
        flagIndicator.hidden = true;
      }
      if (isCurrent) {
        labelParts.push("Current question");
      }
      if (tooltipParts.length) {
        item.title = tooltipParts.join(" \xB7 ");
      }
      item.setAttribute("aria-label", labelParts.join(", "));
      item.addEventListener("click", () => {
        navigateToQuestion(sess, idx, render);
      });
      grid.appendChild(item);
    });
    if (summary) {
      const meta = document.createElement("div");
      meta.className = "question-map__summary";
      const summaryTitle = document.createElement("div");
      summaryTitle.className = "question-map__summary-title";
      summaryTitle.textContent = "Answer changes";
      meta.appendChild(summaryTitle);
      const summaryStats = document.createElement("div");
      summaryStats.className = "question-map__summary-stats";
      summaryStats.innerHTML = `
      <span><strong>${summary.switched}</strong> switched</span>
      <span><strong>${summary.returnedToOriginal}</strong> returned</span>
      <span><strong>${summary.rightToWrong}</strong> right \u2192 wrong</span>
      <span><strong>${summary.wrongToRight}</strong> wrong \u2192 right</span>
    `;
      meta.appendChild(summaryStats);
      map.appendChild(meta);
    }
    sidebar.appendChild(map);
    return summary;
  }
  function renderExamRunner(root2, render) {
    const sess = state.examSession;
    if (!sess) {
      teardownKeyboardNavigation();
      return;
    }
    if (sess.mode === "review" && !sess.result) {
      teardownKeyboardNavigation();
      root2.innerHTML = "";
      root2.className = "exam-session";
      const empty = document.createElement("div");
      empty.className = "exam-empty";
      empty.innerHTML = "<p>This review session is missing data.</p>";
      const back = document.createElement("button");
      back.className = "btn";
      back.textContent = "Back to Exams";
      back.addEventListener("click", () => {
        setExamSession(null);
        render();
      });
      empty.appendChild(back);
      root2.appendChild(empty);
      return;
    }
    const hasWindow = typeof window !== "undefined";
    const prevIdx = sess.__lastRenderedIdx;
    const prevMode = sess.__lastRenderedMode;
    const scroller = resolveScrollContainer(root2);
    const prevScrollY = readScrollPosition(scroller);
    const questionChanged = typeof prevIdx === "number" ? prevIdx !== sess.idx : false;
    if (scroller && questionChanged && typeof prevIdx === "number") {
      storeScrollPosition(sess, prevIdx, prevScrollY);
    } else if (scroller && !questionChanged && typeof prevIdx !== "number" && typeof sess.idx === "number") {
      storeScrollPosition(sess, sess.idx, prevScrollY);
    }
    root2.innerHTML = "";
    root2.className = "exam-session";
    if (sess.mode === "summary") {
      teardownKeyboardNavigation();
      renderSummary(root2, render, sess);
      return;
    }
    ensureScrollPositions(sess);
    setupKeyboardNavigation(sess, render);
    if (!sess.answers) sess.answers = {};
    if (!sess.flagged) sess.flagged = {};
    if (!sess.checked) sess.checked = {};
    if (typeof sess.elapsedMs !== "number") sess.elapsedMs = 0;
    if (sess.exam.timerMode === "timed" && typeof sess.remainingMs !== "number") {
      sess.remainingMs = totalExamTimeMs(sess.exam);
    }
    if (!sess.startedAt) sess.startedAt = Date.now();
    const questionCount = sess.exam.questions.length;
    if (!questionCount) {
      const empty = document.createElement("div");
      empty.className = "exam-empty";
      empty.innerHTML = "<p>This exam does not contain any questions.</p>";
      const back = document.createElement("button");
      back.className = "btn";
      back.textContent = "Back to Exams";
      back.addEventListener("click", () => {
        teardownKeyboardNavigation();
        setExamSession(null);
        render();
      });
      empty.appendChild(back);
      root2.appendChild(empty);
      return;
    }
    if (sess.mode === "taking" && sess.exam.timerMode === "timed") {
      ensureTimer(sess, render);
    }
    if (sess.idx < 0) sess.idx = 0;
    if (sess.idx >= questionCount) sess.idx = questionCount - 1;
    ensureQuestionStats(sess);
    if (sess.mode === "taking") {
      beginQuestionTiming(sess, sess.idx);
    }
    const container = document.createElement("div");
    container.className = "exam-runner";
    root2.appendChild(container);
    const main = document.createElement("section");
    main.className = "exam-main";
    container.appendChild(main);
    const sidebar = document.createElement("aside");
    sidebar.className = "exam-sidebar";
    container.appendChild(sidebar);
    const question = sess.exam.questions[sess.idx];
    const answers = sess.mode === "review" ? sess.result.answers || {} : sess.answers || {};
    const selected = answers[sess.idx];
    const isInstantCheck = sess.mode === "taking" && sess.exam.timerMode !== "timed" && Boolean(sess.checked?.[sess.idx]);
    const showReview = sess.mode === "review" || isInstantCheck;
    const top = document.createElement("div");
    top.className = "exam-topbar";
    const progress = document.createElement("div");
    progress.className = "exam-progress";
    progress.textContent = `${sess.exam.examTitle} \u2022 Question ${sess.idx + 1} of ${questionCount}`;
    top.appendChild(progress);
    const flagBtn = document.createElement("button");
    flagBtn.type = "button";
    flagBtn.className = "flag-btn";
    const isFlagged = sess.mode === "review" ? (sess.result.flagged || []).includes(sess.idx) : Boolean(sess.flagged?.[sess.idx]);
    setToggleState(flagBtn, isFlagged);
    flagBtn.textContent = isFlagged ? "\u{1F6A9} Flagged" : "Flag question";
    if (sess.mode === "taking") {
      flagBtn.addEventListener("click", () => {
        if (!sess.flagged) sess.flagged = {};
        sess.flagged[sess.idx] = !isFlagged;
        render();
      });
    } else {
      flagBtn.disabled = true;
    }
    top.appendChild(flagBtn);
    if (sess.mode === "taking" && sess.exam.timerMode === "timed") {
      const timerEl = document.createElement("div");
      timerEl.className = "exam-timer";
      const remainingMs = typeof sess.remainingMs === "number" ? sess.remainingMs : totalExamTimeMs(sess.exam);
      timerEl.textContent = formatCountdown(remainingMs);
      setTimerElement(sess, timerEl);
      top.appendChild(timerEl);
    } else {
      setTimerElement(sess, null);
    }
    if (sess.mode === "review") {
      const exitReview = document.createElement("button");
      exitReview.type = "button";
      exitReview.className = "btn secondary exam-top-exit";
      if (sess.fromSummary) {
        exitReview.textContent = "Back to Summary";
        exitReview.addEventListener("click", () => {
          setExamSession({ mode: "summary", exam: sess.exam, latestResult: sess.fromSummary });
          render();
        });
      } else {
        exitReview.textContent = "Back to Exams";
        exitReview.addEventListener("click", () => {
          teardownKeyboardNavigation();
          setExamSession(null);
          render();
        });
      }
      top.appendChild(exitReview);
    }
    main.appendChild(top);
    const stem = document.createElement("div");
    stem.className = "exam-stem";
    const stemHtml = question.stem && !isEmptyHtml(question.stem) ? question.stem : "";
    stem.innerHTML = stemHtml || '<p class="exam-stem-empty">(No prompt)</p>';
    main.appendChild(stem);
    const media = mediaElement(question.media);
    if (media) main.appendChild(media);
    if (question.tags?.length) {
      const tagWrap = document.createElement("div");
      tagWrap.className = "exam-tags";
      question.tags.forEach((tag) => {
        const chip = document.createElement("span");
        chip.className = "exam-tag";
        chip.textContent = tag;
        tagWrap.appendChild(chip);
      });
      main.appendChild(tagWrap);
    }
    const optionsWrap = document.createElement("div");
    optionsWrap.className = "exam-options";
    if (!question.options.length) {
      const warn = document.createElement("p");
      warn.className = "exam-warning";
      warn.textContent = "This question has no answer options.";
      optionsWrap.appendChild(warn);
    }
    question.options.forEach((opt) => {
      const choice = document.createElement(sess.mode === "taking" ? "button" : "div");
      if (sess.mode === "taking") choice.type = "button";
      choice.className = "exam-option";
      if (sess.mode === "review") choice.classList.add("review");
      const indicator = document.createElement("span");
      indicator.className = "option-indicator";
      choice.appendChild(indicator);
      const label = document.createElement("span");
      label.className = "option-text";
      label.innerHTML = opt.text || '<span class="exam-option-empty">(Empty option)</span>';
      choice.appendChild(label);
      const isSelected = selected === opt.id;
      if (sess.mode === "taking") {
        setToggleState(choice, isSelected, "selected");
        choice.addEventListener("click", () => {
          recordAnswerChange(sess, sess.idx, question, opt.id);
          sess.answers[sess.idx] = opt.id;
          if (sess.exam.timerMode !== "timed" && sess.checked) {
            delete sess.checked[sess.idx];
          }
          render();
        });
        if (isInstantCheck) {
          const cls = answerClass(question, selected, opt.id);
          if (cls) choice.classList.add(cls);
          if (isSelected) choice.classList.add("chosen");
        }
      } else {
        const cls = answerClass(question, selected, opt.id);
        if (cls) choice.classList.add(cls);
        if (isSelected) choice.classList.add("chosen");
      }
      optionsWrap.appendChild(choice);
    });
    main.appendChild(optionsWrap);
    if (showReview) {
      const verdict = document.createElement("div");
      verdict.className = "exam-verdict";
      let verdictText = "Not answered";
      let verdictClass = "neutral";
      if (selected != null) {
        if (selected === question.answer) {
          verdictText = "Correct";
          verdictClass = "correct";
        } else {
          verdictText = "Incorrect";
          verdictClass = "incorrect";
        }
      }
      verdict.classList.add(verdictClass);
      verdict.textContent = sess.mode === "review" ? verdictText : `Checked: ${verdictText}`;
      main.appendChild(verdict);
      const answerSummary = document.createElement("div");
      answerSummary.className = "exam-answer-summary";
      const answerSummaryList = document.createElement("div");
      answerSummaryList.className = "exam-answer-summary-list";
      const renderAnswerRow = (labelText, html) => {
        const row = document.createElement("div");
        row.className = "exam-answer-row";
        const label = document.createElement("strong");
        label.textContent = `${labelText}:`;
        row.appendChild(label);
        const body = document.createElement("div");
        body.className = "exam-answer-html";
        const safeHtml = html && !isEmptyHtml(html) ? html : "<em>\u2014</em>";
        body.innerHTML = safeHtml;
        row.appendChild(body);
        return row;
      };
      answerSummaryList.appendChild(renderAnswerRow("Your answer", optionHtml(question, selected)));
      answerSummaryList.appendChild(renderAnswerRow("Correct answer", optionHtml(question, question.answer)));
      answerSummary.appendChild(answerSummaryList);
      main.appendChild(answerSummary);
      if (sess.mode === "review") {
        const stats = sess.result?.questionStats?.[sess.idx];
        if (stats) {
          const insights = document.createElement("div");
          insights.className = "exam-review-insights";
          const timeSpent = document.createElement("div");
          timeSpent.innerHTML = `<strong>Time spent:</strong> ${formatDuration(stats.timeMs)}`;
          insights.appendChild(timeSpent);
          const finalAnswer = sess.result?.answers?.[sess.idx];
          const changeDetails = analyzeAnswerChange(stats, question, finalAnswer);
          if (changeDetails.switched) {
            const changeInfo = document.createElement("div");
            const label = document.createElement("strong");
            label.textContent = "Answer change:";
            changeInfo.appendChild(label);
            changeInfo.append(" ");
            const joinChoices = (list) => {
              if (!list.length) return "";
              if (list.length === 1) return list[0];
              return `${list.slice(0, -1).join(", ")} and ${list[list.length - 1]}`;
            };
            const formatChoice = (answerId, fallback) => {
              if (answerId == null) return fallback;
              const label2 = optionText(question, answerId);
              if (label2) return `"${label2}"`;
              return fallback;
            };
            const initialDisplay = formatChoice(changeDetails.initialAnswer, "your original choice");
            const finalDisplay = formatChoice(changeDetails.finalAnswer, "no answer");
            let message = "";
            if (changeDetails.changed) {
              if (changeDetails.direction === "right-to-wrong") {
                message = `You changed from ${initialDisplay} (correct) to ${finalDisplay} (incorrect).`;
              } else if (changeDetails.direction === "wrong-to-right") {
                message = `You changed from ${initialDisplay} (incorrect) to ${finalDisplay} (correct).`;
              } else if (changeDetails.initialCorrect === false && changeDetails.finalCorrect === false) {
                message = `You changed from ${initialDisplay} to ${finalDisplay}, but both choices were incorrect.`;
              } else {
                message = `You changed from ${initialDisplay} to ${finalDisplay}.`;
              }
            } else {
              const intermediateIds = [];
              changeDetails.sequence.slice(1, -1).forEach((id) => {
                if (id == null) return;
                if (id === changeDetails.initialAnswer) return;
                if (!intermediateIds.includes(id)) intermediateIds.push(id);
              });
              const intermediateLabels = intermediateIds.map((id) => optionText(question, id)).filter((label2) => label2 && label2.trim().length).map((label2) => `"${label2}"`);
              if (intermediateLabels.length) {
                const joined = joinChoices(intermediateLabels);
                message = `You tried ${joined} but returned to ${initialDisplay}.`;
              } else {
                message = `You briefly changed your answer but returned to ${initialDisplay}.`;
              }
            }
            changeInfo.append(message);
            insights.appendChild(changeInfo);
          }
          main.appendChild(insights);
        }
      }
      if (question.explanation && !isEmptyHtml(question.explanation)) {
        const explain = document.createElement("div");
        explain.className = "exam-explanation";
        const title = document.createElement("h3");
        title.textContent = "Explanation";
        const body = document.createElement("div");
        body.className = "exam-explanation-body";
        body.innerHTML = question.explanation;
        explain.appendChild(title);
        explain.appendChild(body);
        main.appendChild(explain);
      }
    }
    enhanceExamMedia(main);
    const paletteSummary = renderQuestionMap(sidebar, sess, render);
    renderSidebarMeta(sidebar, sess, paletteSummary);
    const nav = document.createElement("div");
    nav.className = "exam-nav";
    const navStart = document.createElement("div");
    navStart.className = "exam-nav-group exam-nav-group--start";
    const navMiddle = document.createElement("div");
    navMiddle.className = "exam-nav-group exam-nav-group--middle";
    const navEnd = document.createElement("div");
    navEnd.className = "exam-nav-group exam-nav-group--end";
    const prev = document.createElement("button");
    prev.className = "btn secondary";
    prev.textContent = "Previous";
    prev.disabled = sess.idx === 0;
    prev.addEventListener("click", () => {
      if (sess.idx > 0) {
        navigateToQuestion(sess, sess.idx - 1, render);
      }
    });
    navStart.appendChild(prev);
    if (sess.mode === "taking") {
      const nextBtn = document.createElement("button");
      nextBtn.className = "btn secondary";
      nextBtn.textContent = "Next Question";
      nextBtn.disabled = sess.idx >= questionCount - 1;
      nextBtn.addEventListener("click", () => {
        if (sess.idx < questionCount - 1) {
          navigateToQuestion(sess, sess.idx + 1, render);
        }
      });
      navStart.appendChild(nextBtn);
      const saveBtn = document.createElement("button");
      saveBtn.className = "btn secondary";
      saveBtn.textContent = "Save & Exit";
      saveBtn.addEventListener("click", async () => {
        await saveProgressAndExit(sess, render);
      });
      navMiddle.appendChild(saveBtn);
      if (sess.exam.timerMode !== "timed") {
        const checkBtn = document.createElement("button");
        checkBtn.className = "btn secondary";
        checkBtn.textContent = isInstantCheck ? "Hide Check" : "Check Answer";
        checkBtn.disabled = question.options.length === 0;
        checkBtn.addEventListener("click", () => {
          if (!sess.checked) sess.checked = {};
          if (isInstantCheck) {
            delete sess.checked[sess.idx];
          } else {
            sess.checked[sess.idx] = true;
          }
          render();
        });
        navMiddle.appendChild(checkBtn);
      }
      const submit = document.createElement("button");
      submit.className = "btn";
      submit.textContent = "Submit Exam";
      submit.addEventListener("click", async () => {
        await finalizeExam(sess, render);
      });
      navEnd.appendChild(submit);
    } else {
      const nextBtn = document.createElement("button");
      nextBtn.className = "btn secondary";
      nextBtn.textContent = "Next";
      nextBtn.disabled = sess.idx >= questionCount - 1;
      nextBtn.addEventListener("click", () => {
        if (sess.idx < questionCount - 1) {
          navigateToQuestion(sess, sess.idx + 1, render);
        }
      });
      navStart.appendChild(nextBtn);
      const exit = document.createElement("button");
      exit.className = "btn";
      if (sess.fromSummary) {
        exit.textContent = "Back to Summary";
        exit.addEventListener("click", () => {
          setExamSession({ mode: "summary", exam: sess.exam, latestResult: sess.fromSummary });
          render();
        });
      } else {
        exit.textContent = "Back to Exams";
        exit.addEventListener("click", () => {
          teardownKeyboardNavigation();
          setExamSession(null);
          render();
        });
      }
      navEnd.appendChild(exit);
    }
    nav.appendChild(navStart);
    nav.appendChild(navMiddle);
    nav.appendChild(navEnd);
    root2.appendChild(nav);
    const sameQuestion = prevIdx === sess.idx && prevMode === sess.mode;
    sess.__lastRenderedIdx = sess.idx;
    sess.__lastRenderedMode = sess.mode;
    const queueFrame = typeof window !== "undefined" && typeof window.requestAnimationFrame === "function" ? (cb) => window.requestAnimationFrame(cb) : (cb) => setTimeout(cb, 0);
    if (scroller) {
      if (sameQuestion) {
        storeScrollPosition(sess, sess.idx, prevScrollY);
        applyScrollPosition(scroller, prevScrollY);
      } else {
        const storedScroll = getStoredScroll(sess, sess.idx);
        const targetY = storedScroll ?? 0;
        if (typeof sess.idx === "number" && storedScroll == null) {
          storeScrollPosition(sess, sess.idx, targetY);
        }
        const restore = () => {
          applyScrollPosition(scroller, targetY);
        };
        queueFrame(restore);
      }
    }
  }
  function renderSidebarMeta(sidebar, sess, changeSummary) {
    const info = document.createElement("div");
    info.className = "exam-sidebar-info";
    const attempts = document.createElement("div");
    attempts.innerHTML = `<strong>Attempts:</strong> ${sess.exam.results?.length || 0}`;
    info.appendChild(attempts);
    if (sess.mode === "review") {
      if (sess.result.durationMs) {
        const duration = document.createElement("div");
        duration.innerHTML = `<strong>Duration:</strong> ${formatDuration(sess.result.durationMs)}`;
        info.appendChild(duration);
      }
      const summary = changeSummary || (sess.result ? summarizeAnswerChanges(sess.result.questionStats || [], sess.exam, sess.result.answers || {}) : null);
      if (summary) {
        const changeMeta = document.createElement("div");
        changeMeta.innerHTML = `<strong>Answer switches:</strong> ${summary.switched || 0} (Returned: ${summary.returnedToOriginal || 0}, Right \u2192 Wrong: ${summary.rightToWrong || 0}, Wrong \u2192 Right: ${summary.wrongToRight || 0})`;
        info.appendChild(changeMeta);
      }
    } else if (sess.mode === "taking") {
      if (sess.exam.timerMode === "timed") {
        const remaining = typeof sess.remainingMs === "number" ? sess.remainingMs : totalExamTimeMs(sess.exam);
        const timer = document.createElement("div");
        timer.innerHTML = `<strong>Time Remaining:</strong> ${formatCountdown(remaining)}`;
        info.appendChild(timer);
        const pace = document.createElement("div");
        pace.innerHTML = `<strong>Pace:</strong> ${sess.exam.secondsPerQuestion}s/question`;
        info.appendChild(pace);
      } else {
        const timerMode = document.createElement("div");
        timerMode.innerHTML = "<strong>Timer:</strong> Untimed";
        info.appendChild(timerMode);
        const elapsed = document.createElement("div");
        elapsed.innerHTML = `<strong>Elapsed:</strong> ${formatDuration(currentElapsedMs(sess))}`;
        info.appendChild(elapsed);
      }
    }
    sidebar.appendChild(info);
  }
  async function saveProgressAndExit(sess, render) {
    stopTimer(sess);
    const questionStats = snapshotQuestionStats(sess);
    const payload = {
      examId: sess.exam.id,
      exam: clone5(sess.exam),
      idx: sess.idx,
      answers: { ...sess.answers || {} },
      flagged: { ...sess.flagged || {} },
      checked: { ...sess.checked || {} },
      remainingMs: typeof sess.remainingMs === "number" ? Math.max(0, sess.remainingMs) : null,
      elapsedMs: sess.elapsedMs || 0,
      mode: "taking",
      baseExam: sess.baseExam ? clone5(sess.baseExam) : null,
      subsetIndices: Array.isArray(sess.subsetIndices) ? [...sess.subsetIndices] : null,
      questionStats
    };
    await saveExamSessionProgress(payload);
    lastExamStatusMessage = "Attempt saved. You can resume later.";
    teardownKeyboardNavigation();
    setExamSession(null);
    render();
  }
  async function finalizeExam(sess, render, options = {}) {
    const isAuto = Boolean(options.autoSubmit);
    stopTimer(sess);
    const unanswered = sess.exam.questions.map((_, idx) => sess.answers[idx] == null ? idx + 1 : null).filter(Number.isFinite);
    if (!isAuto && unanswered.length) {
      const list = unanswered.join(", ");
      const confirm = await confirmModal(`You have ${unanswered.length} unanswered question${unanswered.length === 1 ? "" : "s"} (Question${unanswered.length === 1 ? "" : "s"}: ${list}). Submit anyway?`);
      if (!confirm) return;
    }
    const answers = {};
    let correct = 0;
    let answeredCount = 0;
    const indexForQuestion = (idx) => {
      const question = sess.exam.questions?.[idx];
      const originalIndex = Number.isInteger(question?.originalIndex) ? question.originalIndex : null;
      return originalIndex ?? idx;
    };
    sess.exam.questions.forEach((question, idx) => {
      const ans = sess.answers[idx];
      if (ans != null) {
        const targetIdx = indexForQuestion(idx);
        answers[targetIdx] = ans;
        answeredCount += 1;
        if (ans === question.answer) correct += 1;
      }
    });
    const flagged = Object.entries(sess.flagged || {}).filter(([_, val]) => Boolean(val)).map(([idx]) => indexForQuestion(Number(idx))).filter(Number.isFinite);
    const questionStatsSnapshot = snapshotQuestionStats(sess);
    const mappedQuestionStats = [];
    questionStatsSnapshot.forEach((stat, idx) => {
      const targetIdx = indexForQuestion(idx);
      mappedQuestionStats[targetIdx] = stat;
    });
    const examForResult = sess.baseExam || sess.exam;
    const changeSummary = summarizeAnswerChanges(mappedQuestionStats, examForResult, answers);
    const result = {
      id: uid(),
      when: Date.now(),
      correct,
      total: sess.exam.questions.length,
      answers,
      flagged,
      durationMs: sess.elapsedMs || 0,
      answered: answeredCount,
      questionStats: mappedQuestionStats,
      changeSummary
    };
    if (sess.baseExam) {
      const subsetIndices = sess.exam.questions.map((_, idx) => indexForQuestion(idx)).filter(Number.isFinite);
      if (subsetIndices.length && subsetIndices.length < (sess.baseExam.questions?.length || 0)) {
        result.subsetIndices = subsetIndices;
      }
    }
    const updatedExam = clone5(examForResult);
    updatedExam.results = [...updatedExam.results || [], result];
    updatedExam.updatedAt = Date.now();
    await upsertExam(updatedExam);
    await deleteExamSessionProgress(updatedExam.id).catch(() => {
    });
    if (isAuto) {
      lastExamStatusMessage = "Time expired. Attempt submitted automatically.";
    }
    teardownKeyboardNavigation();
    setExamSession({ mode: "summary", exam: updatedExam, latestResult: result });
    render();
  }
  function renderSummary(root2, render, sess) {
    const wrap = document.createElement("div");
    wrap.className = "exam-summary";
    const title = document.createElement("h2");
    title.textContent = `${sess.exam.examTitle} \u2014 Results`;
    wrap.appendChild(title);
    const score = document.createElement("div");
    score.className = "exam-summary-score";
    const pct = sess.latestResult.total ? Math.round(sess.latestResult.correct / sess.latestResult.total * 100) : 0;
    score.innerHTML = `<span class="score-number">${sess.latestResult.correct}/${sess.latestResult.total}</span><span class="score-percent">${pct}%</span>`;
    wrap.appendChild(score);
    const metrics = document.createElement("div");
    metrics.className = "exam-summary-metrics";
    metrics.appendChild(createStat("Answered", `${sess.latestResult.answered}/${sess.latestResult.total}`));
    metrics.appendChild(createStat("Flagged", String(sess.latestResult.flagged.length)));
    metrics.appendChild(createStat("Duration", formatDuration(sess.latestResult.durationMs)));
    wrap.appendChild(metrics);
    const actions = document.createElement("div");
    actions.className = "exam-summary-actions";
    const wrongIndices = incorrectQuestionIndices(sess.exam, sess.latestResult);
    const reviewBtn = document.createElement("button");
    reviewBtn.className = "btn";
    reviewBtn.textContent = "Review Attempt";
    reviewBtn.addEventListener("click", () => {
      const reviewPacket = resolveReviewPacket(sess.exam, sess.latestResult);
      setExamSession({
        mode: "review",
        exam: clone5(reviewPacket.exam),
        result: clone5(reviewPacket.result),
        idx: 0,
        fromSummary: clone5(sess.latestResult)
      });
      render();
    });
    actions.appendChild(reviewBtn);
    const reviewWrongBtn = document.createElement("button");
    reviewWrongBtn.className = "btn secondary";
    reviewWrongBtn.textContent = "Review Incorrect";
    reviewWrongBtn.disabled = wrongIndices.length === 0;
    reviewWrongBtn.addEventListener("click", () => {
      const subset = subsetExamForIndices(sess.exam, sess.latestResult, wrongIndices);
      if (!subset) return;
      setExamSession({
        mode: "review",
        exam: subset.exam,
        result: subset.result,
        idx: 0,
        fromSummary: clone5(sess.latestResult)
      });
      render();
    });
    actions.appendChild(reviewWrongBtn);
    const retake = document.createElement("button");
    retake.className = "btn secondary";
    retake.textContent = "Retake Exam";
    retake.addEventListener("click", () => {
      setExamSession(createTakingSession(sess.exam));
      render();
    });
    actions.appendChild(retake);
    const retakeWrong = document.createElement("button");
    retakeWrong.className = "btn secondary";
    retakeWrong.textContent = "Retake Incorrect";
    retakeWrong.disabled = wrongIndices.length === 0;
    retakeWrong.addEventListener("click", () => {
      const subset = subsetExamForIndices(sess.exam, null, wrongIndices);
      if (!subset) return;
      const session = createTakingSession(subset.exam);
      session.baseExam = clone5(sess.exam);
      session.subsetIndices = [...wrongIndices];
      setExamSession(session);
      render();
    });
    actions.appendChild(retakeWrong);
    const exit = document.createElement("button");
    exit.className = "btn";
    exit.textContent = "Back to Exams";
    exit.addEventListener("click", () => {
      setExamSession(null);
      render();
    });
    actions.appendChild(exit);
    wrap.appendChild(actions);
    root2.appendChild(wrap);
  }
  function openExamEditor(existing, render) {
    const { exam } = ensureExamShape(existing || {
      id: uid(),
      examTitle: "New Exam",
      timerMode: "untimed",
      secondsPerQuestion: DEFAULT_SECONDS,
      questions: [],
      results: []
    });
    let dirty = false;
    const markDirty = () => {
      dirty = true;
    };
    const cleanupTasks = /* @__PURE__ */ new Set();
    function registerCleanup(fn) {
      if (typeof fn !== "function") {
        return () => {
        };
      }
      cleanupTasks.add(fn);
      return () => {
        cleanupTasks.delete(fn);
      };
    }
    function runAllCleanups() {
      cleanupTasks.forEach((fn) => {
        try {
          fn();
        } catch (err) {
          console.error("Failed to cleanup exam editor resources", err);
        }
      });
      cleanupTasks.clear();
    }
    let questionDisposers = [];
    function disposeQuestions() {
      questionDisposers.forEach((dispose) => {
        try {
          dispose();
        } catch (err) {
          console.error("Failed to dispose exam question editors", err);
        }
      });
      questionDisposers = [];
    }
    const floating = createFloatingWindow({
      title: existing ? "Edit Exam" : "Create Exam",
      width: 980,
      onClose: () => {
        disposeQuestions();
        runAllCleanups();
      },
      onBeforeClose: async (reason) => {
        if (reason === "saved") return true;
        if (!dirty) return true;
        const choice = await promptSaveChoice();
        if (choice === "cancel") return false;
        if (choice === "discard") return true;
        if (choice === "save") {
          const ok = await persistExam();
          if (ok) {
            dirty = false;
            render();
          }
          return ok;
        }
        return false;
      }
    });
    const form = document.createElement("form");
    form.className = "exam-editor";
    floating.body.appendChild(form);
    const error = document.createElement("div");
    error.className = "exam-error";
    form.appendChild(error);
    const metaSection = document.createElement("div");
    metaSection.className = "exam-editor-meta";
    form.appendChild(metaSection);
    const titleField = document.createElement("label");
    titleField.className = "exam-field";
    const titleLabel = document.createElement("span");
    titleLabel.className = "exam-field-label";
    titleLabel.textContent = "Title";
    const titleInput = document.createElement("input");
    titleInput.className = "input";
    titleInput.value = exam.examTitle;
    titleInput.addEventListener("input", () => {
      exam.examTitle = titleInput.value;
      markDirty();
    });
    titleField.append(titleLabel, titleInput);
    metaSection.appendChild(titleField);
    const timerRow = document.createElement("div");
    timerRow.className = "exam-timer-row";
    metaSection.appendChild(timerRow);
    const modeField = document.createElement("label");
    modeField.className = "exam-field";
    const modeSpan = document.createElement("span");
    modeSpan.className = "exam-field-label";
    modeSpan.textContent = "Timer Mode";
    const modeSelect = document.createElement("select");
    modeSelect.className = "input";
    ["untimed", "timed"].forEach((mode2) => {
      const opt = document.createElement("option");
      opt.value = mode2;
      opt.textContent = mode2 === "timed" ? "Timed" : "Untimed";
      modeSelect.appendChild(opt);
    });
    modeSelect.value = exam.timerMode;
    modeSelect.addEventListener("change", () => {
      exam.timerMode = modeSelect.value;
      secondsField.classList.toggle("is-hidden", exam.timerMode !== "timed");
      markDirty();
    });
    modeField.append(modeSpan, modeSelect);
    timerRow.appendChild(modeField);
    const secondsField = document.createElement("label");
    secondsField.className = "exam-field";
    const secondsSpan = document.createElement("span");
    secondsSpan.className = "exam-field-label";
    secondsSpan.textContent = "Seconds per question";
    const secondsInput = document.createElement("input");
    secondsInput.type = "number";
    secondsInput.min = "10";
    secondsInput.className = "input";
    secondsInput.value = String(exam.secondsPerQuestion);
    secondsInput.addEventListener("input", () => {
      const val = Number(secondsInput.value);
      if (!Number.isNaN(val) && val > 0) {
        exam.secondsPerQuestion = val;
        markDirty();
      }
    });
    secondsField.append(secondsSpan, secondsInput);
    if (exam.timerMode !== "timed") secondsField.classList.add("is-hidden");
    timerRow.appendChild(secondsField);
    const bodySection = document.createElement("div");
    bodySection.className = "exam-editor-body";
    form.appendChild(bodySection);
    const sidebar = document.createElement("aside");
    sidebar.className = "exam-editor-sidebar";
    const sidebarTitle = document.createElement("div");
    sidebarTitle.className = "exam-editor-sidebar-title";
    const sidebarHeading = document.createElement("h4");
    sidebarHeading.textContent = "Jump to question";
    const sidebarCount = document.createElement("span");
    sidebarCount.className = "exam-editor-sidebar-count";
    sidebarTitle.append(sidebarHeading, sidebarCount);
    sidebar.appendChild(sidebarTitle);
    const navList = document.createElement("div");
    navList.className = "exam-editor-nav-list";
    sidebar.appendChild(navList);
    bodySection.appendChild(sidebar);
    const mainColumn = document.createElement("div");
    mainColumn.className = "exam-editor-main";
    bodySection.appendChild(mainColumn);
    const questionsHeader = document.createElement("div");
    questionsHeader.className = "exam-question-header";
    const qTitle = document.createElement("h3");
    qTitle.textContent = "Questions";
    const addQuestion = document.createElement("button");
    addQuestion.type = "button";
    addQuestion.className = "btn secondary";
    addQuestion.textContent = "Add Question";
    addQuestion.addEventListener("click", () => {
      exam.questions.push(createBlankQuestion());
      markDirty();
      scheduleRenderQuestions();
    });
    questionsHeader.append(qTitle, addQuestion);
    mainColumn.appendChild(questionsHeader);
    const questionSection = document.createElement("div");
    questionSection.className = "exam-question-section";
    mainColumn.appendChild(questionSection);
    function renderQuestions() {
      disposeQuestions();
      questionSection.innerHTML = "";
      navList.innerHTML = "";
      sidebarCount.textContent = `${exam.questions.length} total`;
      if (!exam.questions.length) {
        const empty = document.createElement("p");
        empty.className = "exam-question-empty";
        empty.textContent = "No questions yet. Add your first question to get started.";
        questionSection.appendChild(empty);
        const navEmpty = document.createElement("p");
        navEmpty.className = "exam-editor-nav-empty";
        navEmpty.textContent = "Add questions to jump around.";
        navList.appendChild(navEmpty);
        return;
      }
      const fragment = document.createDocumentFragment();
      exam.questions.forEach((question, idx) => {
        const card = document.createElement("div");
        card.className = "exam-question-editor";
        const questionId = question.id || `idx-${idx}`;
        card.id = `exam-question-${questionId}`;
        const localDisposers = /* @__PURE__ */ new Set();
        const optionDisposers = /* @__PURE__ */ new Set();
        function trackEditor(editor) {
          if (!editor || typeof editor.destroy !== "function") {
            return () => {
            };
          }
          let disposed = false;
          const cleanup = () => {
            if (disposed) return;
            disposed = true;
            try {
              editor.destroy();
            } catch (err) {
              console.error("Failed to destroy exam editor instance", err);
            }
          };
          const unregister = registerCleanup(cleanup);
          const dispose = () => {
            if (disposed) return;
            unregister();
            cleanup();
            localDisposers.delete(dispose);
          };
          localDisposers.add(dispose);
          return dispose;
        }
        function cleanupOptionEditors() {
          for (const dispose of Array.from(optionDisposers)) {
            optionDisposers.delete(dispose);
            dispose();
          }
        }
        const header = document.createElement("div");
        header.className = "exam-question-editor-header";
        const label = document.createElement("h4");
        label.textContent = `Question ${idx + 1}`;
        header.appendChild(label);
        const remove = document.createElement("button");
        remove.type = "button";
        remove.className = "ghost-btn";
        remove.textContent = "Remove";
        remove.addEventListener("click", () => {
          exam.questions.splice(idx, 1);
          markDirty();
          scheduleRenderQuestions();
        });
        header.appendChild(remove);
        card.appendChild(header);
        const stemField = document.createElement("div");
        stemField.className = "exam-field exam-field--rich";
        const stemLabel = document.createElement("span");
        stemLabel.className = "exam-field-label";
        stemLabel.textContent = "Prompt";
        stemField.appendChild(stemLabel);
        const stemEditor = createRichTextEditor({
          value: question.stem,
          ariaLabel: `Question ${idx + 1} prompt`,
          onChange: () => {
            question.stem = stemEditor.getValue();
            markDirty();
          }
        });
        trackEditor(stemEditor);
        stemEditor.element.classList.add("exam-rich-input");
        stemField.appendChild(stemEditor.element);
        card.appendChild(stemField);
        const mediaField = document.createElement("div");
        mediaField.className = "exam-field exam-field--media";
        const mediaLabel = document.createElement("span");
        mediaLabel.className = "exam-field-label";
        mediaLabel.textContent = "Media (URL or upload)";
        mediaField.appendChild(mediaLabel);
        const mediaInput = document.createElement("input");
        mediaInput.className = "input";
        mediaInput.placeholder = "https://example.com/image.png";
        mediaInput.value = question.media || "";
        mediaInput.addEventListener("input", () => {
          question.media = mediaInput.value.trim();
          updatePreview();
          markDirty();
        });
        mediaInput.addEventListener("paste", (event) => {
          void handleMediaPaste(event);
        });
        mediaField.appendChild(mediaInput);
        const mediaUpload = document.createElement("input");
        mediaUpload.type = "file";
        mediaUpload.accept = "image/*,video/*,audio/*";
        mediaUpload.addEventListener("change", () => {
          const file = mediaUpload.files?.[0];
          if (!file) return;
          markDirty();
          const reader = new FileReader();
          reader.onload = () => {
            question.media = typeof reader.result === "string" ? reader.result : "";
            mediaInput.value = question.media;
            updatePreview();
            markDirty();
          };
          reader.readAsDataURL(file);
        });
        mediaField.appendChild(mediaUpload);
        const clearMedia = document.createElement("button");
        clearMedia.type = "button";
        clearMedia.className = "ghost-btn";
        clearMedia.textContent = "Remove media";
        clearMedia.addEventListener("click", () => {
          question.media = "";
          mediaInput.value = "";
          mediaUpload.value = "";
          updatePreview();
          markDirty();
        });
        mediaField.appendChild(clearMedia);
        card.appendChild(mediaField);
        const preview = document.createElement("div");
        preview.className = "exam-media-preview";
        async function handleMediaPaste(event) {
          if (!event?.clipboardData) return;
          const files = Array.from(event.clipboardData.files || []);
          const file = files.find((f) => f && typeof f.type === "string" && (f.type.startsWith("image/") || f.type.startsWith("video/") || f.type.startsWith("audio/")));
          if (!file) return;
          event.preventDefault();
          try {
            const dataUrl = await readFileAsDataUrl(file);
            if (typeof dataUrl === "string" && dataUrl) {
              question.media = dataUrl;
              mediaInput.value = question.media;
              updatePreview();
              markDirty();
            }
          } catch (err) {
            console.warn("Failed to read pasted media", err);
          }
        }
        function updatePreview() {
          preview.innerHTML = "";
          const el = mediaElement(question.media);
          if (el) preview.appendChild(el);
        }
        updatePreview();
        card.appendChild(preview);
        const tagsField = document.createElement("label");
        tagsField.className = "exam-field";
        const tagsLabel = document.createElement("span");
        tagsLabel.className = "exam-field-label";
        tagsLabel.textContent = "Tags (comma or | separated)";
        const tagsInput = document.createElement("input");
        tagsInput.className = "input";
        tagsInput.value = question.tags.join(", ");
        tagsInput.addEventListener("input", () => {
          question.tags = parseTagString(tagsInput.value);
          markDirty();
        });
        tagsField.append(tagsLabel, tagsInput);
        card.appendChild(tagsField);
        const explanationField = document.createElement("div");
        explanationField.className = "exam-field exam-field--rich";
        const explanationLabel = document.createElement("span");
        explanationLabel.className = "exam-field-label";
        explanationLabel.textContent = "Explanation";
        explanationField.appendChild(explanationLabel);
        const explanationEditor = createRichTextEditor({
          value: question.explanation,
          ariaLabel: `Question ${idx + 1} explanation`,
          onChange: () => {
            question.explanation = explanationEditor.getValue();
            markDirty();
          }
        });
        trackEditor(explanationEditor);
        explanationEditor.element.classList.add("exam-rich-input");
        explanationField.appendChild(explanationEditor.element);
        card.appendChild(explanationField);
        const optionsWrap = document.createElement("div");
        optionsWrap.className = "exam-option-editor-list";
        function renderOptions() {
          cleanupOptionEditors();
          optionsWrap.innerHTML = "";
          question.options.forEach((opt, optIdx) => {
            const row = document.createElement("div");
            row.className = "exam-option-editor";
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = `correct-${question.id}`;
            radio.checked = question.answer === opt.id;
            radio.addEventListener("change", () => {
              question.answer = opt.id;
              markDirty();
            });
            row.appendChild(radio);
            const editor = createRichTextEditor({
              value: opt.text,
              ariaLabel: `Option ${optIdx + 1}`,
              onChange: () => {
                opt.text = editor.getValue();
                markDirty();
              }
            });
            const disposeOptionEditor = trackEditor(editor);
            optionDisposers.add(disposeOptionEditor);
            editor.element.classList.add("exam-option-rich");
            row.appendChild(editor.element);
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "ghost-btn";
            removeBtn.textContent = "Remove";
            removeBtn.disabled = question.options.length <= 2;
            removeBtn.addEventListener("click", () => {
              question.options.splice(optIdx, 1);
              if (question.answer === opt.id) {
                question.answer = question.options[0]?.id || "";
              }
              markDirty();
              renderOptions();
            });
            row.appendChild(removeBtn);
            optionsWrap.appendChild(row);
          });
        }
        renderOptions();
        const addOption = document.createElement("button");
        addOption.type = "button";
        addOption.className = "btn secondary";
        addOption.textContent = "Add Option";
        addOption.addEventListener("click", () => {
          const opt = { id: uid(), text: "" };
          question.options.push(opt);
          markDirty();
          renderOptions();
        });
        card.appendChild(optionsWrap);
        card.appendChild(addOption);
        fragment.appendChild(card);
        const navButton = document.createElement("button");
        navButton.type = "button";
        navButton.className = "exam-editor-nav-item";
        navButton.textContent = String(idx + 1);
        navButton.title = `Jump to Question ${idx + 1}`;
        navButton.addEventListener("click", () => {
          card.classList.add("exam-question-editor--highlight");
          card.scrollIntoView({ behavior: "smooth", block: "start" });
          window.setTimeout(() => {
            card.classList.remove("exam-question-editor--highlight");
          }, 1200);
        });
        navList.appendChild(navButton);
        const disposeLocal = () => {
          cleanupOptionEditors();
          for (const dispose of Array.from(localDisposers)) {
            localDisposers.delete(dispose);
            dispose();
          }
        };
        questionDisposers.push(disposeLocal);
      });
      questionSection.appendChild(fragment);
    }
    const scheduleRenderQuestions = (() => {
      let scheduled = false;
      const schedule2 = typeof window !== "undefined" && typeof window.requestAnimationFrame === "function" ? window.requestAnimationFrame.bind(window) : (cb) => setTimeout(cb, 0);
      return () => {
        if (scheduled) return;
        scheduled = true;
        schedule2(() => {
          scheduled = false;
          renderQuestions();
        });
      };
    })();
    scheduleRenderQuestions();
    const actions = document.createElement("div");
    actions.className = "exam-editor-actions";
    const saveBtn = document.createElement("button");
    saveBtn.type = "submit";
    saveBtn.className = "btn";
    saveBtn.textContent = "Save Exam";
    actions.appendChild(saveBtn);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "btn secondary";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => {
      void floating.close("cancel");
    });
    actions.appendChild(closeBtn);
    form.appendChild(actions);
    async function persistExam() {
      error.textContent = "";
      const title = titleInput.value.trim();
      if (!title) {
        error.textContent = "Exam title is required.";
        return false;
      }
      if (!exam.questions.length) {
        error.textContent = "Add at least one question.";
        return false;
      }
      for (let i = 0; i < exam.questions.length; i += 1) {
        const question = exam.questions[i];
        question.stem = sanitizeRichText(question.stem);
        question.explanation = sanitizeRichText(question.explanation);
        question.media = question.media?.trim() || "";
        question.options = question.options.map((opt) => ({
          id: opt.id || uid(),
          text: sanitizeRichText(opt.text)
        })).filter((opt) => !isEmptyHtml(opt.text));
        question.tags = ensureArrayTags(question.tags);
        if (isEmptyHtml(question.stem)) {
          error.textContent = `Question ${i + 1} needs a prompt.`;
          return false;
        }
        if (question.options.length < 2) {
          error.textContent = `Question ${i + 1} needs at least two answer options.`;
          return false;
        }
        if (!question.answer || !question.options.some((opt) => opt.id === question.answer)) {
          question.answer = question.options[0].id;
        }
      }
      const payload = {
        ...exam,
        examTitle: title,
        updatedAt: Date.now()
      };
      await upsertExam(payload);
      return true;
    }
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const ok = await persistExam();
      if (!ok) return;
      dirty = false;
      await floating.close("saved");
      render();
    });
    function promptSaveChoice() {
      return new Promise((resolve) => {
        const modal = document.createElement("div");
        modal.className = "modal";
        const card = document.createElement("div");
        card.className = "card";
        const message = document.createElement("p");
        message.textContent = "Save changes before closing?";
        card.appendChild(message);
        const actionsRow = document.createElement("div");
        actionsRow.className = "modal-actions";
        const saveBtn2 = document.createElement("button");
        saveBtn2.type = "button";
        saveBtn2.className = "btn";
        saveBtn2.textContent = "Save";
        saveBtn2.addEventListener("click", () => {
          cleanup();
          resolve("save");
        });
        const discardBtn = document.createElement("button");
        discardBtn.type = "button";
        discardBtn.className = "btn secondary";
        discardBtn.textContent = "Discard";
        discardBtn.addEventListener("click", () => {
          cleanup();
          resolve("discard");
        });
        const cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "ghost-btn";
        cancelBtn.textContent = "Keep Editing";
        cancelBtn.addEventListener("click", () => {
          cleanup();
          resolve("cancel");
        });
        actionsRow.append(saveBtn2, discardBtn, cancelBtn);
        card.appendChild(actionsRow);
        modal.appendChild(card);
        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            cleanup();
            resolve("cancel");
          }
        });
        document.body.appendChild(modal);
        saveBtn2.focus();
        function cleanup() {
          if (modal.parentNode) document.body.removeChild(modal);
        }
      });
    }
    titleInput.focus();
  }
  var DEFAULT_SECONDS, CSV_MAX_OPTIONS, CSV_HEADERS, CSV_ROW_META, CSV_ROW_QUESTION, CSV_EXPLANATION_INDEX, CSV_TAGS_INDEX, CSV_MEDIA_INDEX, timerHandles, keyHandler, keyHandlerSession, lastExamStatusMessage, examViewScrollTop;
  var init_exams = __esm({
    "js/ui/components/exams.js"() {
      init_storage();
      init_state();
      init_utils();
      init_confirm();
      init_rich_text();
      init_media_upload();
      init_window_manager();
      DEFAULT_SECONDS = 60;
      CSV_MAX_OPTIONS = 8;
      CSV_HEADERS = (() => {
        const base = ["type", "examTitle", "timerMode", "secondsPerQuestion", "stem"];
        for (let i = 1; i <= CSV_MAX_OPTIONS; i += 1) {
          base.push(`option${i}`);
          base.push(`option${i}Correct`);
        }
        base.push("explanation", "tags", "media");
        return base;
      })();
      CSV_ROW_META = "meta";
      CSV_ROW_QUESTION = "question";
      CSV_EXPLANATION_INDEX = CSV_HEADERS.indexOf("explanation");
      CSV_TAGS_INDEX = CSV_HEADERS.indexOf("tags");
      CSV_MEDIA_INDEX = CSV_HEADERS.indexOf("media");
      timerHandles = /* @__PURE__ */ new WeakMap();
      keyHandler = null;
      keyHandlerSession = null;
      lastExamStatusMessage = "";
      examViewScrollTop = 0;
    }
  });

  // js/ui/components/entry-controls.js
  var entry_controls_exports = {};
  __export(entry_controls_exports, {
    createEntryAddControl: () => createEntryAddControl
  });
  function createEntryAddControl(onAdded, initialKind = "disease") {
    const wrapper = document.createElement("div");
    wrapper.className = "entry-add-control";
    const button = document.createElement("button");
    button.type = "button";
    button.className = "fab-btn";
    button.innerHTML = '<span class="sr-only">Add new entry</span><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    button.setAttribute("aria-label", "Add new entry");
    const menu = document.createElement("div");
    menu.className = "entry-add-menu hidden";
    const options = [...defaultOptions];
    if (initialKind) {
      const idx = options.findIndex((opt) => opt.value === initialKind);
      if (idx > 0) {
        const [preferred] = options.splice(idx, 1);
        options.unshift(preferred);
      }
    }
    options.forEach((opt) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "entry-add-menu-item";
      item.textContent = opt.label;
      item.addEventListener("click", () => {
        closeMenu();
        openEditor(opt.value, onAdded);
      });
      menu.appendChild(item);
    });
    function setOpen(open) {
      menu.classList.toggle("hidden", !open);
      wrapper.classList.toggle("open", open);
      button.setAttribute("aria-expanded", open ? "true" : "false");
      if (open) document.addEventListener("mousedown", handleOutside);
      else document.removeEventListener("mousedown", handleOutside);
    }
    function closeMenu() {
      setOpen(false);
    }
    function handleOutside(e) {
      if (!wrapper.contains(e.target)) {
        closeMenu();
      }
    }
    button.addEventListener("click", () => {
      const willOpen = menu.classList.contains("hidden");
      setOpen(willOpen);
    });
    wrapper.appendChild(button);
    wrapper.appendChild(menu);
    setOpen(false);
    return wrapper;
  }
  var defaultOptions;
  var init_entry_controls = __esm({
    "js/ui/components/entry-controls.js"() {
      init_editor();
      defaultOptions = [
        { value: "disease", label: "Disease" },
        { value: "drug", label: "Drug" },
        { value: "concept", label: "Concept" }
      ];
    }
  });

  // js/main.js
  var main_exports = {};
  __export(main_exports, {
    render: () => renderApp,
    renderApp: () => renderApp,
    resolveListKind: () => resolveListKind,
    tabs: () => tabs
  });
  init_state();
  init_storage();
  init_block_catalog();

  // js/app-shell.js
  function createAppShell({
    state: state2,
    setTab: setTab2,
    setSubtab: setSubtab2,
    setQuery: setQuery2,
    findItemsByFilter: findItemsByFilter2,
    renderSettings: renderSettings3,
    renderCardList: renderCardList3,
    renderCards: renderCards3,
    renderBuilder: renderBuilder3,
    renderLectures: renderLectures3,
    renderFlashcards: renderFlashcards3,
    renderReview: renderReview3,
    renderQuiz: renderQuiz3,
    renderBlockMode: renderBlockMode3,
    renderBlockBoard: renderBlockBoard3,
    renderExams: renderExams3,
    renderExamRunner: renderExamRunner3,
    createEntryAddControl: createEntryAddControl3
  }) {
    const tabs2 = ["Block Board", "Lists", "Cards", "Study", "Exams", "Lectures"];
    const listTabConfig = [
      { label: "Diseases", kind: "disease" },
      { label: "Drugs", kind: "drug" },
      { label: "Concepts", kind: "concept" }
    ];
    function resolveListKind2() {
      const active = state2?.subtab?.Lists;
      const match = listTabConfig.find((cfg) => cfg.label === active);
      return match ? match.kind : "disease";
    }
    let shell = null;
    let tabButtons = /* @__PURE__ */ new Map();
    let searchInput = null;
    let settingsBtn = null;
    let main = null;
    let pendingQuery = "";
    let queryUpdateTimer = 0;
    function ensureShell() {
      if (shell) return shell;
      ensureShell();
      tabButtons.forEach((btn, tab) => {
        btn.classList.toggle("active", state2.tab === tab);
      });
      if (settingsBtn) {
        settingsBtn.classList.toggle("active", state2.tab === "Settings");
      }
      if (searchInput && document.activeElement !== searchInput && searchInput.value !== state2.query) {
        searchInput.value = state2.query;
      }
      if (shouldRestoreSearch && searchInput) {
        requestAnimationFrame(() => {
          searchInput.focus();
          if (selectionStart !== null && selectionEnd !== null && searchInput.setSelectionRange) {
            searchInput.setSelectionRange(selectionStart, selectionEnd);
          } else {
            const len = searchInput.value.length;
            if (searchInput.setSelectionRange) searchInput.setSelectionRange(len, len);
          }
        });
      }
      main.innerHTML = "";
      const header = document.createElement("header");
      header.className = "header";
      const left = document.createElement("div");
      left.className = "header-left";
      const brand = document.createElement("div");
      brand.className = "brand";
      brand.textContent = "Arc";
      left.appendChild(brand);
      const nav = document.createElement("nav");
      nav.className = "tabs";
      nav.setAttribute("aria-label", "Primary sections");
      const tabClassMap = {
        "Block Board": "tab-block-board",
        Lists: "tab-lists",
        Lectures: "tab-lectures",
        Cards: "tab-cards",
        Study: "tab-study",
        Exams: "tab-exams"
      };
      tabButtons = /* @__PURE__ */ new Map();
      tabs2.forEach((t) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "tab";
        const variant = tabClassMap[t];
        if (variant) btn.classList.add(variant);
        btn.textContent = t;
        btn.addEventListener("click", () => {
          const wasActive = state2.tab === t;
          let needsRender = false;
          if (t === "Study" && wasActive && state2.subtab?.Study === "Review" && !state2.flashSession && !state2.quizSession) {
            needsRender = setSubtab2("Study", "Builder") || needsRender;
          }
          const tabChanged = setTab2(t);
          if (tabChanged || needsRender) {
            renderApp2();
          }
        });
        tabButtons.set(t, btn);
        nav.appendChild(btn);
      });
      left.appendChild(nav);
      header.appendChild(left);
      const right = document.createElement("div");
      right.className = "header-right";
      const searchField = document.createElement("label");
      searchField.className = "search-field";
      searchField.setAttribute("aria-label", "Search entries");
      const searchIcon = document.createElement("span");
      searchIcon.className = "search-icon";
      searchIcon.setAttribute("aria-hidden", "true");
      searchIcon.innerHTML = '<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 14.5L18 18" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/><circle cx="9" cy="9" r="5.8" stroke="currentColor" stroke-width="1.6"/></svg>';
      searchField.appendChild(searchIcon);
      searchInput = document.createElement("input");
      searchInput.type = "search";
      searchInput.placeholder = "Search entries";
      searchInput.value = state2.query;
      searchInput.autocomplete = "off";
      searchInput.spellcheck = false;
      searchInput.className = "search-input";
      searchInput.dataset.role = "global-search";
      pendingQuery = searchInput.value;
      const commitQuery = (value) => {
        const next = typeof value === "string" ? value : "";
        if (setQuery2(next)) {
          renderApp2();
        }
      };
      const scheduleQueryUpdate = (value) => {
        pendingQuery = typeof value === "string" ? value : "";
        if (queryUpdateTimer) {
          clearTimeout(queryUpdateTimer);
        }
        queryUpdateTimer = setTimeout(() => {
          queryUpdateTimer = 0;
          commitQuery(pendingQuery);
        }, 120);
      };
      searchInput.addEventListener("input", (e) => {
        scheduleQueryUpdate(e.target.value);
      });
      searchInput.addEventListener("search", (e) => {
        pendingQuery = typeof e.target.value === "string" ? e.target.value : "";
        if (queryUpdateTimer) {
          clearTimeout(queryUpdateTimer);
          queryUpdateTimer = 0;
        }
        commitQuery(pendingQuery);
      });
      searchField.appendChild(searchInput);
      right.appendChild(searchField);
      settingsBtn = document.createElement("button");
      settingsBtn.type = "button";
      settingsBtn.className = "header-settings-btn";
      settingsBtn.setAttribute("aria-label", "Settings");
      settingsBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a7.723 7.723 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.47 6.47 0 0 1-.22.128c-.331.183-.582.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a6.932 6.932 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.086.22-.128.332-.183.582-.495.644-.869z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="2.8" stroke="currentColor" stroke-width="1.6"/></svg>';
      settingsBtn.addEventListener("click", () => {
        if (setTab2("Settings")) {
          renderApp2();
        }
      });
      right.appendChild(settingsBtn);
      header.appendChild(right);
      root.appendChild(header);
      main = document.createElement("main");
      root.appendChild(main);
      shell = { root, header, main };
      return shell;
    }
    async function renderApp2() {
      if (typeof document !== "undefined") {
        document.body.classList.remove("is-deck-open");
        document.body.classList.remove("is-occlusion-workspace-open");
      }
      ensureShell();
      const activeEl = document.activeElement;
      const shouldRestoreSearch2 = activeEl && activeEl.dataset && activeEl.dataset.role === "global-search";
      const selectionStart2 = shouldRestoreSearch2 && typeof activeEl.selectionStart === "number" ? activeEl.selectionStart : null;
      const selectionEnd2 = shouldRestoreSearch2 && typeof activeEl.selectionEnd === "number" ? activeEl.selectionEnd : null;
      tabButtons.forEach((btn, tab) => {
        btn.classList.toggle("active", state2.tab === tab);
      });
      if (settingsBtn) {
        settingsBtn.classList.toggle("active", state2.tab === "Settings");
      }
      if (searchInput && document.activeElement !== searchInput && searchInput.value !== state2.query) {
        searchInput.value = state2.query;
      }
      if (shouldRestoreSearch2 && searchInput) {
        requestAnimationFrame(() => {
          searchInput.focus();
          if (selectionStart2 !== null && selectionEnd2 !== null && searchInput.setSelectionRange) {
            searchInput.setSelectionRange(selectionStart2, selectionEnd2);
          } else {
            const len = searchInput.value.length;
            if (searchInput.setSelectionRange) searchInput.setSelectionRange(len, len);
          }
        });
      }
      main.innerHTML = "";
      if (state2.tab === "Settings") {
        await renderSettings3(main);
      } else if (state2.tab === "Lists") {
        const kind = resolveListKind2();
        const listMeta = listTabConfig.find((cfg) => cfg.kind === kind) || listTabConfig[0];
        const createTarget = listMeta?.kind || "disease";
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        const entryControlPromise = Promise.resolve(createEntryAddControl3(renderApp2, createTarget)).then((control) => {
          if (control) {
            main.insertBefore(control, content);
          }
        }).catch((err) => {
          console.warn("Failed to create list entry control", err);
        });
        const selector = document.createElement("div");
        selector.className = "list-subtabs";
        selector.setAttribute("role", "tablist");
        listTabConfig.forEach((cfg) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "list-subtab";
          btn.textContent = cfg.label;
          btn.dataset.listKind = cfg.kind;
          btn.setAttribute("role", "tab");
          if (cfg.kind === kind) btn.classList.add("active");
          btn.addEventListener("click", () => {
            if (setSubtab2("Lists", cfg.label)) {
              renderApp2();
            }
          });
          selector.appendChild(btn);
        });
        content.appendChild(selector);
        const listHost = document.createElement("div");
        listHost.className = "list-host";
        content.appendChild(listHost);
        const filter = { ...state2.filters, types: [kind], query: state2.query };
        const query = findItemsByFilter2(filter);
        const renderPromise = renderCardList3(listHost, query, kind, renderApp2);
        await Promise.all([entryControlPromise, renderPromise]);
      } else if (state2.tab === "Block Board") {
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        const entryControlPromise = Promise.resolve(createEntryAddControl3(renderApp2, "disease")).then((control) => {
          if (control) {
            main.insertBefore(control, content);
          }
        }).catch((err) => {
          console.warn("Failed to create block board entry control", err);
        });
        const renderPromise = renderBlockBoard3(content, renderApp2);
        await Promise.all([entryControlPromise, renderPromise]);
      } else if (state2.tab === "Lectures") {
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        await renderLectures3(content, renderApp2);
      } else if (state2.tab === "Cards") {
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        const filter = { ...state2.filters, query: state2.query };
        const query = findItemsByFilter2(filter);
        const entryControlPromise = Promise.resolve(createEntryAddControl3(renderApp2, "disease")).then((control) => {
          if (control) {
            main.insertBefore(control, content);
          }
        }).catch((err) => {
          console.warn("Failed to create cards entry control", err);
        });
        const itemsPromise = query.toArray();
        const cardsPromise = itemsPromise.then((items) => renderCards3(content, items, renderApp2));
        await Promise.all([entryControlPromise, cardsPromise]);
      } else if (state2.tab === "Study") {
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        const entryControlPromise = Promise.resolve(createEntryAddControl3(renderApp2, "disease")).then((control) => {
          if (control) {
            main.insertBefore(control, content);
          }
        }).catch((err) => {
          console.warn("Failed to create study entry control", err);
        });
        if (state2.flashSession) {
          await Promise.all([
            entryControlPromise,
            renderFlashcards3(content, renderApp2)
          ]);
        } else if (state2.quizSession) {
          await Promise.all([
            entryControlPromise,
            renderQuiz3(content, renderApp2)
          ]);
        } else {
          const activeStudy = state2.subtab.Study === "Blocks" ? "Blocks" : state2.subtab.Study || "Builder";
          if (activeStudy === "Review") {
            await Promise.all([
              entryControlPromise,
              renderReview3(content, renderApp2)
            ]);
          } else if (activeStudy === "Blocks") {
            await Promise.all([
              entryControlPromise,
              renderBlockMode3(content, renderApp2)
            ]);
          } else {
            const wrap = document.createElement("div");
            const builderPromise = renderBuilder3(wrap, renderApp2).then(() => {
              content.appendChild(wrap);
            });
            await Promise.all([entryControlPromise, builderPromise]);
          }
        }
      } else if (state2.tab === "Exams") {
        const content = document.createElement("div");
        content.className = "tab-content";
        main.appendChild(content);
        const entryControlPromise = Promise.resolve(createEntryAddControl3(renderApp2, "disease")).then((control) => {
          if (control) {
            main.insertBefore(control, content);
          }
        }).catch((err) => {
          console.warn("Failed to create exams entry control", err);
        });
        if (state2.examSession) {
          await Promise.all([
            entryControlPromise,
            renderExamRunner3(content, renderApp2)
          ]);
        } else {
          await Promise.all([
            entryControlPromise,
            renderExams3(content, renderApp2)
          ]);
        }
      } else {
        main.textContent = `Currently viewing: ${state2.tab}`;
      }
    }
    return { renderApp: renderApp2, tabs: tabs2, resolveListKind: resolveListKind2 };
  }

  // js/main.js
  function createLazyRenderer(loader, exportName) {
    let cachedPromise;
    const load = () => {
      if (!cachedPromise) {
        cachedPromise = loader().then((mod) => {
          const resolved = exportName ? mod[exportName] : mod?.default;
          if (typeof resolved !== "function") {
            throw new TypeError(`Expected ${exportName || "default"} export to be a function`);
          }
          return resolved;
        }).catch((err) => {
          cachedPromise = null;
          throw err;
        });
      }
      return cachedPromise;
    };
    const runner = async (...args) => {
      const fn = await load();
      return fn(...args);
    };
    runner.preload = () => load().then(() => void 0);
    return runner;
  }
  var renderSettings2 = createLazyRenderer(() => Promise.resolve().then(() => (init_settings2(), settings_exports)), "renderSettings");
  var renderCardList2 = createLazyRenderer(() => Promise.resolve().then(() => (init_cardlist(), cardlist_exports)), "renderCardList");
  var renderCards2 = createLazyRenderer(() => Promise.resolve().then(() => (init_cards(), cards_exports)), "renderCards");
  var renderBuilder2 = createLazyRenderer(() => Promise.resolve().then(() => (init_builder(), builder_exports)), "renderBuilder");
  var renderLectures2 = createLazyRenderer(() => Promise.resolve().then(() => (init_lectures2(), lectures_exports)), "renderLectures");
  var renderFlashcards2 = createLazyRenderer(() => Promise.resolve().then(() => (init_flashcards(), flashcards_exports)), "renderFlashcards");
  var renderReview2 = createLazyRenderer(() => Promise.resolve().then(() => (init_review(), review_exports)), "renderReview");
  var renderQuiz2 = createLazyRenderer(() => Promise.resolve().then(() => (init_quiz(), quiz_exports)), "renderQuiz");
  var renderBlockMode2 = createLazyRenderer(() => Promise.resolve().then(() => (init_block_mode(), block_mode_exports)), "renderBlockMode");
  var renderBlockBoard2 = createLazyRenderer(() => Promise.resolve().then(() => (init_block_board(), block_board_exports)), "renderBlockBoard");
  var renderExams2 = createLazyRenderer(() => Promise.resolve().then(() => (init_exams(), exams_exports)), "renderExams");
  var renderExamRunner2 = createLazyRenderer(() => Promise.resolve().then(() => (init_exams(), exams_exports)), "renderExamRunner");
  var createEntryAddControl2 = createLazyRenderer(() => Promise.resolve().then(() => (init_entry_controls(), entry_controls_exports)), "createEntryAddControl");
  var { renderApp, tabs, resolveListKind } = createAppShell({
    state,
    setTab,
    setSubtab,
    setQuery,
    findItemsByFilter,
    renderSettings: renderSettings2,
    renderCardList: renderCardList2,
    renderCards: renderCards2,
    renderBuilder: renderBuilder2,
    renderLectures: renderLectures2,
    renderFlashcards: renderFlashcards2,
    renderReview: renderReview2,
    renderQuiz: renderQuiz2,
    renderBlockMode: renderBlockMode2,
    renderBlockBoard: renderBlockBoard2,
    renderExams: renderExams2,
    renderExamRunner: renderExamRunner2,
    createEntryAddControl: createEntryAddControl2
  });
  async function bootstrap() {
    try {
      const performanceReady = Promise.resolve().then(() => (init_performance(), performance_exports));
      await initDB();
      if (typeof window === "undefined") {
        loadBlockCatalog().catch((err) => {
          console.warn("Failed to prime block catalog", err);
        });
      } else {
        const schedule2 = typeof window.requestIdleCallback === "function" ? window.requestIdleCallback.bind(window) : (cb) => setTimeout(cb, 200);
        schedule2(() => {
          loadBlockCatalog().catch((err) => {
            console.warn("Failed to prime block catalog", err);
          });
        });
      }
      await performanceReady;
      await renderApp();
      schedulePrefetch();
    } catch (err) {
      const root2 = document.getElementById("app");
      if (root2) root2.textContent = "Failed to load app";
      console.error(err);
    }
  }
  function schedulePrefetch() {
    if (typeof window === "undefined") return;
    const tasks = [
      () => renderSettings2.preload(),
      () => renderCardList2.preload(),
      () => renderCards2.preload(),
      () => renderBuilder2.preload(),
      () => renderLectures2.preload(),
      () => renderFlashcards2.preload(),
      () => renderReview2.preload(),
      () => renderQuiz2.preload(),
      () => renderBlockMode2.preload(),
      () => renderBlockBoard2.preload(),
      () => renderExams2.preload(),
      () => renderExamRunner2.preload(),
      () => createEntryAddControl2.preload()
    ];
    const schedule2 = typeof window.requestIdleCallback === "function" ? window.requestIdleCallback.bind(window) : (cb) => setTimeout(cb, 200);
    schedule2(() => {
      tasks.reduce((chain, task) => chain.then(task).catch(() => void 0), Promise.resolve());
    });
  }
  if (typeof window !== "undefined" && !globalThis.__ARC_TEST__) {
    bootstrap();
  }
  return __toCommonJS(main_exports);
})();
